---
title: 排序(2) 插入排序
tags: [InsertionSort, sort]
date: 2019-04-01 16:13:17
permalink: insertion-sort
categories: Sorting
description:
---
<p class="description">插入排序重复地将新的元素插入到一个排好序的子线性表中，直到整个线性表排好序。</p>


<!-- more -->

## 插入排序 
### 思想
插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

对线性表{2, 9, 5, 4, 8, 1, 6}进行排序，可以在纸上依次对{9, 5, 4, 8, 1, 6}排序，直到线性表排好序。

这个算法可以描述为：
```java 插入排序伪代码
for (int i = 1; i < arr.length; i++) {
    将arr[i]插入到已排好序的只线性表中，这样arr[0 ... i]也是排好序的
}
```

插入arr[i]到arr[0 ... i-1]中有下面的过程：
- 将arr[i]存储在一个名为currentElement的临时变量中
- 如果arr[i-1] > currentElement，就将arr[i-1]移到arr[i]中
- 如果arr[i-2] > currentElement，就将arr[i-2]移到arr[i-1]中
- 依此类推，直到arr[i-k] <= currentElement 或者 k > i(传递的是排好序的数列的第一个元素)， 将currentElement赋值给arr[i-k+1]

### java实现
将伪代码扩展和执行
```java 插入排序
public class InsertionSort {
    public static void insertionSort(int[] arr) {
        for (int i = 1; i < list.length; i++) {
            // 插入arr[i]到已经排好序的子线性表arr[0 ... i-1]中
            int currentElement = arr[i];
            int k;

            for (k = i - 1; k > 0 && arr[k] > currentElement; k--) {
                arr[k+1] = arr[k];
            }

            //  插入当前元素到arr[k+1]中
            arr[k + 1] = currentElement;
        }
    }

    public static void main(String[] args) {
        int[] list = {2, 32, 3, 34, 45, 8, 89, 20, 23, -1};        
        insertionSort(list);
        
        for (int i: list)
            System.out.print(i + " ");
    }
}
```

外层循环（循环控制变量i）的迭代是为了获取已屁啊好序的子线性表，其范围是arr[0] 到arr[i]。
内层循环（循环控制变量k）将arr[i]插入到arr[0]到arr[i-1]的子线性表。

### 算法复杂度
时间复杂度（平均）： O(n^2)
时间复杂度（最坏）： O(n^2)
时间复杂度（最好）： O(n)

空间复杂度：  O(1)

因为在有序部分元素和待插入元素相等的时候，可以将待插入的元素放在前面，所以插入排序是 **稳定的**。

插入排序（Insertion Sort）的一个重要的特点是，如果原始数据的大部分元素已经排序，那么插入排序的速度很快（因为需要移动的元素很少）。从这个事实我们可以想到，如果原始数据只有很少元素，那么排序的速度也很快。
－－希尔排序就是基于这两点对插入排序作出了改进。

<hr />