---
title: 排序(6) 归并排序
tags: [MergeSort, sort]
date: 2019-04-01 16:13:56
permalink: merge-sort
categories: Sorting
description:
---
<p class="description">归并排序算法将数组分为两半，对每部分递归地应用归并排序。在两部分都排好序后，对他们进行归并。</p>


<!-- more -->

## 引言
归并排序（Merge Sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分支法（Divide and Conquer）的一个典型应用。将已有序的子序列合并，得到完全有序的徐俩；即先使每个子序列有序，再使系序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。

归并排序的算法伪代码：
```java
public static void mergeSort(int[] arr) {
    if (arr.length > 1) {
        mergeSort(arr[0 ... arr.length/2]);
        mergeSort(arr[arr.length/2 + 1 ... arr.length]);
        merge arr[0 ... arr.length / 2] with 
            arr[arr.length/2 + 1 ... arr.length];
    }
}
```

对元素{2, 9, 5, 4, 8, 1, 6, 7}进行归并排序。 先进行 **拆分**数组，直到数组只有一个元素为止，然后，再将其 **归并**为一个新的有序数组。
递归调用持续将数组划分为只数组，直到每个只数组只包含一个元素。然后，该算法将这些小的只数组归并为稍大的有序子数组，直到最后形成一个有序的数组。



## java实现一

```java
/*
 * 归并排序利用的是分治的思想实现的，对于给定的一组数据，利用递归与分治技术将数据序列划分成*为越来越小的子序列，之后对子序列排序，
 * 最后再用递归方法将排好序的子序列合并成为有序序列。合并两个子序列时，需要申请两个子序列加*起来长度的内存，临时存储新的生成序列，
 * 再将新生成的序列赋值到原数组相应的位置。
 */
public class MergeSort {
	
	public static void mergeSort(int[] list) {
		if (list.length > 1) {
			// Merge sort the first half
			int[] firstHalf = new int[list.length / 2];
			System.arraycopy(list, 0, firstHalf, 0, list.length / 2);
			mergeSort(firstHalf);

			// Merge sort the second half
			int secondHalfLength = list.length - list.length / 2;
			int[] secondHalf = new int[secondHalfLength];
			System.arraycopy(list, list.length / 2, secondHalf, 0, secondHalfLength);
			mergeSort(secondHalf);

			// Merge firstHalf with secondHalf into list
			merge(firstHalf, secondHalf, list);
		}
	}

	public static void merge(int[] list1, int[] list2, int[] temp) {
		int current1 = 0;
		int current2 = 0;
		int current3 = 0;

		while (current1 < list1.length && current2 < list2.length) {
			if (list1[current1] < list2[current2])
				temp[current3++] = list1[current1++];
			else
				temp[current3++] = list2[current2++];
		}

		while (current1 < list1.length)
			temp[current3++] = list1[current1++];

		while (current2 < list2.length)
			temp[current3++] = list2[current2++];
	}

	public static void main(String[] args) {
		int[] list = { 2, 3, 2, 5, 6, 1, -2, 3, 14, 12 };
		mergeSort(list);
		for (int i = 0; i < list.length; i++)
			System.out.print(list[i] + " ");
	}
}

```

MergeSort方法在分节过程中创建两个临时数组，将数组前半部分和后半部分复制到临时数组中，对临时数组排序，然后将它们归并到原始数组中。这样产生很多额外的空间开销，在方法二中，递归地对数组的前半部分和后半部分进行排序，而不创建新的临时数组，然后把两个数组归并到一个临时数组中并将它的内容复制到初始数组中。

## 归并排序方法二

```java
public class MergeSort {
	public static void mergeSort(int[] arr, int left, int right) {
		if (left == right) {
			return;
		} else {
			//  取中间的数进行拆分
			int mid = (left + right) / 2;
			//  左边的数不断进行拆分
			mergeSort(arr, left, mid);
			//  右边的数不断进行拆分
			mergeSort(arr, mid + 1, right);

			// 合并
			merge(arr, left, mid + 1, right);
		}
	}

	public static void merge(int[] arr, int left, int right) {
		int[] leftArray = new int[mid - left];
		int[] rightArray = new int[right - mid + 1];
		for (int i = left; i < mid; i++) {
			leftArray[i - left] = arr[i];
		}
		for (int i = mid; i <= right; i++) {
			rightArray[i - mid] = arr[i];
		}

		int i = 0, j = 0;
		int k = left;

		while (i < leftArray.length && j < rightArray.length) {
			if (leftArray[i] < rightArray[j]) {
				arr[k++] = leftArray[i++];
			} else {
				arr[k++] = rigthArray[j++];
			}
		}

		while (i < leftArray.length) {
			arr[k++] = leftArray[i++];
		}
		while (j < rightArray.length) {
			arr[k++] = rigthArray[j++];
		}
	}

	public static void main(String[] args) {
		int[] arrays = { 9, 2, 5, 1, 3, 2, 1, 3, 2, 8, 7, 10 };
		//设置4个值的断点查看递归调用栈变化
		//int[] arrays = { 9, 2, 5, 1 };
		mergeSort(arrays, 0, arrays.length - 1);
		System.out.println(Arrays.toString(arrays));
	}
}
````

可以在Eclipse的debug中设置断点，查看递归调用的次序，注意变量是在变化的。


## 总结及算法复杂度

算法复杂度：
时间复杂度（平均）： O(nlogn)
时间复杂度（最坏）： O(nlogn)
时间复杂度（最好）： O(nlogn)

空间复杂度：  O(n)


在这里我们只不过是利用了递归的思想，将数组每一次都分解为原来的一半大小的两个子数组，当分解到了右边界比左边界还大的时候，不再分解，开始排序。然后将排序好的子数组逐级合并，最后得到的结果就是排序好的数组


原数组的长度为n，则细分得最大深度为logn，每一层需要排序的元素为n；则归并排序的时间复杂度为O(nlogn)
稳定性：因为交换元素时，可以在相等的情况下做出不移动的限制，所以归并排序是可以稳定的；






<hr />