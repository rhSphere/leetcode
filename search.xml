<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LinkedStack && ArrayStack]]></title>
    <url>%2Fleetcode%2F2019%2F05%2F28%2Flinked-and-array-stack.html</url>
    <content type="text"><![CDATA[链表实现链式栈思路 用链表结点存储栈顶top节点，存储链表长度 实现isEmpty()方法、size()方法 push()用增加的节点作为头节点 链表实现栈的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package Stack;import java.util.*;/** * @description: 实现链表栈，使用泛型的单链表 * @author: rhsphere * @since: 2019-05-28 15:57 by jdk 1.8 */public class LinkedStack&lt;E&gt; implements Iterable&lt;E&gt; &#123; //栈顶节点top和栈的大小 private Node&lt;E&gt; top; private int n; //内部静态类，因为不用接触类的任何实例对象和方法 //外部类可以访问内部类的private/protected变量，就像访问自己的private/protected变量一样. private static class Node&lt;E&gt; &#123; private E e; private Node&lt;E&gt; next; &#125; //构造一个空的stack public LinkedStack() &#123; top = null; n = 0; &#125; //判断栈顶结点是不是null public boolean isEmpty() &#123; return top == null; &#125; public int size() &#123; return n; &#125; /** * 添加一个元素 * @param e 待添加的元素 */ public void push(E e) &#123; Node&lt;E&gt; oldTop = top; top = new Node&lt;E&gt;(); top.e = e; top.next = oldTop; n++; &#125; /** * 删除并返回最近添加的元素 * @return 最近添加的元素 * @throws NoSuchElementException 如果栈为空 */ public E pop() &#123; if (isEmpty()) throw new NoSuchElementException("LinkedStack underflow"); E e = top.e; top = top.next; n--; return e; &#125; /** * 返回但不移除最近添加的栈顶元素 * @return 最近添加的元素 * @throws NoSuchElementException 如果栈为空 */ public E peek() &#123; if (isEmpty()) throw new NoSuchElementException("LinkedStack underflow"); return top.e; &#125; //foreach的写法是因为LinkedStack的对象实现了Iterable接口 public String toString() &#123; StringBuilder sb = new StringBuilder(); for (E e : this) &#123; sb.append(e); sb.append(' '); &#125; return sb.toString(); &#125; /** * 返回一个以LIFO顺序遍历栈元素的迭代器 * @return 一个以LIFO顺序遍历栈元素的迭代器 */ public Iterator&lt;E&gt; iterator() &#123; return new ListIterator&lt;E&gt;(top); &#125; private class ListIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123; private Node&lt;E&gt; cur; public ListIterator(Node&lt;E&gt; top) &#123; cur = top; &#125; public boolean hasNext() &#123; return cur != null; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public E next() &#123; if (!hasNext()) throw new NoSuchElementException("LinkedStack underflow"); E e = cur.e; cur = cur.next; return e; &#125; &#125;&#125; 数组实现顺序栈数组实现栈的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package Stack;import java.util.*;/** * @description: 数组实现栈，使用支持动态调整数组大小的泛型数组 * @author: rhsphere * @since: 2019-05-28 16:43 by jdk 1.8 */public class ArrayStack&lt;E&gt; implements Iterable&lt;E&gt; &#123; private E[] arr; private int n; public ArrayStack()&#123; arr = (E[]) new Object[2]; n = 0; &#125; public boolean isEmpty() &#123; return n == 0; &#125; public int size() &#123; return n; &#125; private void resize(int capacity) &#123; assert capacity &gt;= 0; E[] tmp = (E[]) new Object[capacity]; for (int i = 0; i &lt; n; i++) &#123; tmp[i] = arr[i]; &#125; arr = tmp; &#125; public void push(E e) &#123; if (n == arr.length) resize(2 * arr.length); arr[n++] = e; &#125; public E pop() &#123; if (isEmpty()) throw new NoSuchElementException("Stack underflow"); E e = arr[n - 1]; arr[n - 1] = null; n--; if (n &gt; 0 &amp;&amp; n == arr.length / 4) resize(arr.length / 2); return e; &#125; public E peek() &#123; if (isEmpty()) throw new NoSuchElementException("Stack underflow"); return arr[n - 1]; &#125; public Iterator&lt;E&gt; iterator() &#123; return new ArrayIterator(); &#125; private class ArrayIterator implements Iterator&lt;E&gt; &#123; private int i; public ArrayIterator() &#123; i = n - 1; &#125; public boolean hasNext() &#123; return i &gt;= 0; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public E next() &#123; if (!hasNext()) throw new NoSuchElementException(); return arr[i--]; &#125; &#125;&#125; 链式和顺序栈测试代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package Stack;/** * @description: * @author: rhsphere * @since: 2019-05-28 16:28 by jdk 1.8 */public class TestStack &#123; public static void main(String[] args) &#123; System.out.println("==========测试ArrayStack=========="); LinkedStack&lt;String&gt; stack = new LinkedStack&lt;String&gt;(); stack.push("! "); stack.push("world"); stack.push(", "); stack.push("Hello"); stack.push("Hi. "); System.out.println("栈顶元素是：" + stack.peek()); // 使用foreach遍历栈元素 for(String s : stack) System.out.print(s); System.out.println(); while (!stack.isEmpty()) &#123; System.out.print(stack.pop()); &#125; System.out.println("\n(now " + stack.size() + " left on linked stack)"); System.out.println("==========测试ArrayStack=========="); ArrayStack&lt;String&gt; arrStack = new ArrayStack&lt;String&gt;(); arrStack.push("! "); arrStack.push("world"); arrStack.push(", "); arrStack.push("Goodbye"); arrStack.push("woo. "); System.out.println("栈顶元素是：" + arrStack.peek()); // 使用foreach遍历栈元素 for(String s : arrStack) System.out.print(s); System.out.println(); while (!arrStack.isEmpty()) &#123; System.out.print(arrStack.pop()); &#125; System.out.println("\n(now " + arrStack.size() + " left on array stack)"); &#125;&#125;]]></content>
      <categories>
        <category>Sum-up</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>LinkedStack</tag>
        <tag>ArrayStack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedList(链表)]]></title>
    <url>%2Fleetcode%2F2019%2F05%2F28%2Flinkedlist-sum-up.html</url>
    <content type="text"><![CDATA[LinkedList(链表)Last Modified: 2019/5/28 09:24 by dp 01. Reverse Linked List（反转链表） 02. Linked List Cycley Ⅰ（检测链表是否有环Ⅰ） 03. Linked List Cycley Ⅱ（检测链表是否有环Ⅱ） 04. Merge Two Sorted Lists（合并两个有序链表） 05. Reverse Nodes in k-Group（以 k 为一组反转链表） 06. Remove Nth Node From End of List（删除链表的倒数第N个节点） 07. Middle of the Linked List（链表的中间节点） 08. Merge k Sorted Lists（合并 k 个排序链表）]]></content>
      <categories>
        <category>Sum-up</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Sum-up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23. Merge k Sorted Lists]]></title>
    <url>%2Fleetcode%2F2019%2F05%2F28%2F23.html</url>
    <content type="text"><![CDATA[合并 k 个排序链表题目合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例: 输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * @description: 采用merge算法，一次合并两个 * @author: rhsphere * @since: 2019-05-28 08:32 by jdk 1.8 */public class MergeKLists &#123; public ListNode mergeKLists(ListNode[] lists) &#123; return mergeKLists(lists, 0, list.length - 1); &#125; private ListNode mergeKLists(ListNode[] listNodes, int start, int end) &#123; if (start &gt; end) return null; if (start == end) return listNodes[start]; mid = start + ((end - start) &gt;&gt; 1); ListNode p = mergeKLists(listNodes, start, mid); ListNode q = mergeKLists(listNodes, mid + 1, end); ListNode res = merge(p, q); return res; &#125; public ListNode merge(ListNode p, ListNode q) &#123; ListNode head = new ListNode(0); ListNode r = head; while (true) &#123; if (p == null &amp;&amp; q == null) &#123; break; &#125; else if(p != null &amp;&amp; (q == null || p.val &lt;= q.val)) &#123; r.next = p; p = p.next; &#125; else if (p == null || q.val &lt; p.val) &#123; r.next = q; q = q.next; &#125; r = r.next; &#125; return head.next; &#125; public class ListNode &#123; int val; ListNode next; ListNode(int val) &#123; this.val = val; &#125; &#125;&#125; 总结失误的地方 else if(p != null &amp;&amp; (q == null || p.val &lt;= q.val)) 条件中少了判等， 写成了p.val &lt; q.val。 mergeKLists(ListNode[] listNodes, int start, int end) start和end的形参类型写成了ListNode 这题就是归并排序的衍生，理解归并排序，就能理解这里面的递归调用。]]></content>
      <categories>
        <category>Hard</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Divide and Conquer</tag>
        <tag>Heap</tag>
        <tag>MergeSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[876. Middle of the Linked List]]></title>
    <url>%2Fleetcode%2F2019%2F05%2F28%2F876.html</url>
    <content type="text"><![CDATA[链表的中间节点题目给定一个带有头结点 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 示例 1： 输入：[1,2,3,4,5]输出：此列表中的结点 3 (序列化形式：[3,4,5])返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。注意，我们返回了一个 ListNode 类型的对象 ans，这样：ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.示例 2： 输入：[1,2,3,4,5,6]输出：此列表中的结点 4 (序列化形式：[4,5,6])由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 提示： 给定链表的结点数介于 1 和 100 之间。 思路头结点误导人 快慢指针： 1.慢指针一次走一步，快指针一次走2步，快指针走到末端，慢指针正好指向中间结点； 2.这里分两种情况： 快指针的next为null，慢指针正好指向中间结点，链表结点数为偶数；快指针为null，慢指针正好指向第二个中间结点，链表结点数为奇数； java代码12345678910111213141516171819202122232425262728293031/** * @description: 快慢指针，找到链表的中间节点 * @author: rhsphere * @since: 2019-05-28 08:02 by jdk 1.8 */public class MiddleNode &#123; public static ListNode middleNode(ListNode head) &#123; // 如果没有头结点 //if (head == null) return head; ListNode fast = head, slow = head; //while (fast.next != null &amp;&amp; fast.next.next != null) &#123; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; &#125; return slow; &#125; public static class ListNode&#123; int val; ListNode next; public ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19. Remove Nth Node From End of List]]></title>
    <url>%2Fleetcode%2F2019%2F05%2F27%2F19.html</url>
    <content type="text"><![CDATA[删除链表的倒数第N个节点题目给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ 思路使用fast指针先远离头结点 n-1 的位置，然后slow指针和fast再同时移动到链表尾部，此时slow指针的位置就是倒数第n个节点，提前保存slow的prev节点，然后prev.next = prev.next.next即可完成任务。 注意： 链表为空的情况； 链表只有一个元素的情况 java代码1234567891011121314151617181920212223242526272829303132333435363738/** * @description: * @author: rhsphere * @since: 2019-05-27 20:45 by jdk 1.8 */public class RemoveNthFromEnd &#123; public static ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode fast = head; int i = 1; while (fast != null &amp;&amp; i &lt; n) &#123; fast = fast.next; i++; &#125; //链表为空 if (fast == null) return head; ListNode slow = head, prev = null; while (fast.next != null) &#123; fast = fast.next; prev = slow; slow = slow.next; &#125; //链表只有一个元素 if (prev == null) head = head.next; else prev.next = prev.next.next; return head; &#125; private static class ListNode&#123; int val; ListNode next; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Medium</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[25. Reverse Nodes in k-Group]]></title>
    <url>%2Fleetcode%2F2019%2F05%2F27%2F25.html</url>
    <content type="text"><![CDATA[k 个一组翻转链表题目给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。 示例 : 给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5 当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5 当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5说明 : 你的算法只能使用常数的额外空间。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 java代码思路见注释 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @description: * @author: rhsphere * @since: 2019-05-27 20:10 by jdk 1.8 */public class ReverseKGroup &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; //计数器 int length = 0; //当前组头结点 ListNode r = head; //遍历剩余链表,用计数器记录,每当链表还满足长度&gt;=k,则终止操作 while (r != null &amp;&amp; length != k) &#123; r = r.next; length++; &#125; //如果长度 == k,说明当前剩余链表长度&gt;=k,还可以再分组 if (length == k) &#123; //对于剩余链表调用自身函数再进行分组,直至剩余长度不足k为止 //用tail 接受此组的下一组反转完成之后的新头结点 ListNode pre = reverseKGroup(r, k); //对于此组的节点进行指向反转 while (k-- &gt; 0) &#123; ListNode next = head.next; head.next = pre; pre = head; head = next; &#125; //值得注意的是:当上述的while循环结束的时候,head 指向的已经是下一组的原头结点了,所以 //不要直接返回head //应该返回head 的上一个元素 ,如上面用pre记录了. return pre; &#125; //如果长度不满足k,则剩余链表不需要进行任何操作,直接返回剩余链表的头结点即可. return head; &#125; private static class ListNode&#123; int val; ListNode next; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; &#125;&#125; 总结 while(k– &gt; 0)的循环体内就是 反转链表的代码，这里reverse节点是下一组链表的头结点。]]></content>
      <categories>
        <category>Hard</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[21. Merge Two Sorted Lists]]></title>
    <url>%2Fleetcode%2F2019%2F05%2F27%2F21.html</url>
    <content type="text"><![CDATA[合并两个有序链表题目将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748** * @description: 合并两个有序链表 * @author: rhsphere * @since: 2019-05-27 19:41 by jdk 1.8 */public class MergeSortedLists &#123; public static ListNode mergeSortedLists(ListNode la, ListNode lb) &#123; if (la == null) return lb; if (lb == null) return la; ListNode p = la, q = lb, head; if (p.val &lt; q.val) &#123; head = p; p = p.next; &#125; else &#123; head = q; q = q.next; &#125; ListNode r = head; while (p != null &amp;&amp; q != null) &#123; if (p.val &lt; q.val) &#123; r.next = p; p = p.next; &#125; else &#123; r.next = q; q = q.next; &#125; r = r.next; &#125; if (p != null) &#123; r.next = p; &#125; else &#123; r.next = q; &#125; return head; &#125; public static class ListNode&#123; int val; ListNode next; public ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; &#125;&#125; 总结脑袋要清楚知道指针是如何移动的！]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[141. Linked List Cycle 1]]></title>
    <url>%2Fleetcode%2F2019%2F05%2F27%2F141.html</url>
    <content type="text"><![CDATA[环形链表Ⅰ题目给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1：输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2：输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3：输入：head = [1], pos = -1输出：false解释：链表中没有环。 进阶：你能用 O(1)（即，常量）内存解决此问题吗？ 思路 如果链表中没有环，则fast指针最终将到达终点，返回false； 对于环形链表，fast和slow指针是两个围绕跑道的跑者。 快速跑步者最终会遇到慢跑者。 为什么？ 考虑这种情况（将其命名为情形A） ： 快速跑步者仅仅是慢跑者的一步。 在下一次迭代中，它们分别增加一步和两步并相互会合。 例如，我们还没有考虑过快速跑步者落后慢跑者两到三步的情况。 这很简单，因为在下一次或下次的下一次迭代中，这种情况将简化为上面的情形A。 证明方法采用了，归纳法。 java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @description: * @author: rhsphere * @since: 2019-05-27 18:06 by jdk 1.8 */public class HasCycle &#123; public static boolean hasCycle(ListNode head) &#123; if (head == null) return false; ListNode fast = head.next; ListNode slow = head; // while (fast != null &amp;&amp; slow != null) &#123; // 错误示范 while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; if (fast == slow) &#123; return true; &#125; &#125; return false; &#125; private static class ListNode&#123; int val; ListNode next; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; &#125; public static void main(String[] args) &#123; ListNode head = new ListNode(3, null); ListNode second = new ListNode(2, null); ListNode third = new ListNode(0, null); ListNode fourth = new ListNode(-4, null); head.next = second; second.next = third; third.next = fourth; fourth.next = second; boolean hasCycle = hasCycle(head); System.out.println(hasCycle); &#125;&#125; 总结 错误示范 while (fast != null &amp;&amp; slow != null) {]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[142. Linked List Cycle 2]]></title>
    <url>%2Fleetcode%2F2019%2F05%2F27%2F142.html</url>
    <content type="text"><![CDATA[环形链表Ⅱ题目给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。说明：不允许修改给定的链表。 示例 1： 输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0输出：tail connects to node index 0解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1输出：no cycle解释：链表中没有环。 进阶：你能用 O(1)（即，常量）内存解决此问题吗？ 思路分两个步骤，首先通过快慢指针的方法判断链表是否有环；接下来如果有环，则寻找入环的第一个节点。 具体的方法为，首先假定链表起点到入环的第一个节点A的长度为a【未知】，到快慢指针相遇的节点B的长度为（a + b）【这个长度是已知的】。 现在我们想知道a的值，注意到快指针 fast 始终是慢指针 slow 走过长度的2倍，所以慢指针 slow 从B继续走（a + b）又能回到B点，如果只走a个长度就能回到节点A。 但是a的值是不知道的，解决思路是曲线救国，注意到起点到A的长度是a，那么可以用一个从起点开始的新指针head和从节点B开始的慢指针slow同步走，相遇的地方必然是入环的第一个节点A。 画个图就一目了然了~ java代码12345678910111213141516171819202122232425262728293031323334353637/** * @description: 链表有环，返回节点 * @author: rhsphere * @since: 2019-05-27 18:58 by jdk 1.8 */public class DetectCycle &#123; public ListNode detectCycle(ListNode head) &#123; if (head == null || head.next == null) return null; ListNode slow = head; ListNode fast = head; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; if (fast == slow) &#123; while (head != fast) &#123; fast = fast.next; head = head.next; &#125; return head; &#125; &#125; return null; &#125; private static class ListNode&#123; int val; ListNode next; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Medium</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[206. Reverse Linked List]]></title>
    <url>%2Fleetcode%2F2019%2F05%2F27%2F206.html</url>
    <content type="text"><![CDATA[反转链表题目反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 思路有很多种写法：1）迭代方式的解答为了完成这个任务，需要记录链表中三个连续的节点：reverse、head、second。在每一轮迭代中，从原始链表中提取节点head并将它插入到逆链表的开头。我们需要一直保持head指向原链表中所有剩余节点的首节点，second指向原链表中所有剩余节点的第二个节点，reverse指向结果链表中的首节点。 2）假设链表有N个节点，首先递归颠倒最后N-1个节点，然后小心地将原链表的首节点插入到结果链表的末端。 java代码迭代和递归写法，见代码注释。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * @description: 反转一个链表 * @author: rhsphere * @since: 2019-05-27 16:32 by jdk 1.8 */public class ReverseLinkedList &#123; //迭代解法 public static ListNode reverse(ListNode head) &#123; ListNode reverse = null; while (head != null) &#123; ListNode second = head.next; head.next = reverse; reverse = head; head = second; &#125; return reverse; &#125; //递归解法 public static ListNode reverseRecursive(ListNode head) &#123; if (head == null) return head; if (head.next == null) return head; ListNode second = head.next; ListNode res = reverseRecursive(second); second.next = head; head.next = null; return res; &#125; private class ListNode&#123; private int val; private ListNode next; public ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; public int getData() &#123;return val;&#125; &#125;&#125; 总结 编写和链表相关的代码时，必须要小心处理异常情况（链表为空或是只有一个或两个节点）和边界情况（处理首尾节点）。这些情况通常更加需，要画图等手段来看清楚指针变化。]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array&&GenericArray]]></title>
    <url>%2Fleetcode%2F2019%2F05%2F27%2Farray-and-genericarray.html</url>
    <content type="text"><![CDATA[自己实现动态数组： 实现一个大小固定的有序数组，支持动态增删改操作 实现一个支持动态扩容的泛型数组 大小固定的有序数组，支持动态增删改操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * @description: 实现一个大小国定的有序数组，支持动态增删改操作。 * 1)数组的插入、删除、按照下标随机访问操作； * 2）数组中的数据是int类型的。 * @author: rhsphere * @since: 2019-05-27 10:21 by jdk 1.8 */public class Array &#123; //定义整型数据data保存数据 public int data[]; //定义数组长度 private int n; //定义实际中的个数 private int count; //构造方法，定义数组大小 public Array(int capacity) &#123; this.data = new int[capacity]; this.n = capacity; this.count = 0; //初始化后没有存数 &#125; //根据索引找到数据中的元素并返回 public int find(int index) &#123; if (index &lt; 0 || index &gt;= count) return -1; return data[index]; &#125; //插入元素，尾部插入 public boolean insert(int index, int value) &#123; // 数组空间已满 if (count == n) &#123; System.out.println("没有可插入的位置"); return false; &#125; // 如果count还没满，那么就可以插入数据到数组中 // 位置不合法 if (index &lt; 0 || index &gt; count) &#123; System.out.println("位置不合法"); return false; &#125; //位置合法 for (int i = count; i &gt; index; --i) &#123; data[i] = data[i - 1]; &#125; data[index] = value; ++count; return true; &#125; //根据索引，删除数组中元素 public boolean delete(int index) &#123; if (index &lt; 0 || index &gt;= count) return false; //从删除位置开始，将后面的元素向前移动一位 for (int i = index + 1; i &lt; count; i++) &#123; data[i - 1] = data[i]; &#125; count--; return true; &#125; public void printAll() &#123; for (int i = 0; i &lt; count; i++) &#123; System.out.print(data[i] + " "); &#125; System.out.println(); &#125; public static void main(String[] args) &#123; Array arr = new Array(5); arr.printAll(); arr.insert(0, 3); arr.insert(0, 4); arr.insert(1, 5); arr.insert(3, 9); arr.insert(3, 10); arr.printAll(); &#125;&#125; 支持动态扩容的泛型数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168/** * @description: 实现一个支持动态扩容的泛型数组 * @author: rhsphere * @since: 2019-05-27 10:43 by jdk 1.8 */public class GenericArray&lt;T&gt; &#123; private T[] data; private int size; // 根据传入容量，构造Array public GenericArray(int capacity) &#123; data = (T[]) new Object[capacity]; size = 0; &#125; // 无参构造方法，默认数组容量为10 public GenericArray() &#123; this(10); &#125; // 获取数组容量 public int getCapacity() &#123; return data.length; &#125; // 获取当前元素个数 public int count() &#123; return size; &#125; // 判断数组是否为空 public boolean isEmpty() &#123; return size == 0; &#125; // 修改 index 位置的元素 public void set(int index, T e) &#123; checkIndex(index); data[index] = e; &#125; // 获取对应 index 位置的元素 public T get(int index) &#123; checkIndex(index); return data[index]; &#125; // 查看数组是否包含元素e public boolean contains(T e) &#123; for (int i = 0; i &lt; size; i++) &#123; if (data[i].equals(e)) &#123; return true; &#125; &#125; return false; &#125; // 获取对应元素的下标, 未找到，返回 -1 public int find(T e) &#123; for ( int i = 0; i &lt; size; i++) &#123; if (data[i].equals(e)) &#123; return i; &#125; &#125; return -1; &#125; // 在 index 位置，插入元素e, 时间复杂度 O(m+n) public void add(int index, T e) &#123; checkIndex(index); // 如果当前元素个数等于数组容量，则将数组扩容为原来的2倍 if (size == data.length) &#123; resize(2 * data.length); &#125; for (int i = size - 1; i &gt;= index; i--) &#123; data[i + 1] = data[i]; &#125; data[index] = e; size++; &#125; // 向数组头插入元素 public void addFirst(T e) &#123; add(0, e); &#125; // 向数组尾插入元素 public void addLast(T e) &#123; add(size, e); &#125; // 删除 index 位置的元素，并返回 public T remove(int index) &#123; checkIndexForRemove(index); T ret = data[index]; for (int i = index + 1; i &lt; size; i++) &#123; data[i - 1] = data[i]; &#125; size --; data[size] = null; // 缩容 if (size == data.length / 4 &amp;&amp; data.length / 2 != 0) &#123; resize(data.length / 2); &#125; return ret; &#125; // 删除第一个元素 public T removeFirst() &#123; return remove(0); &#125; // 删除末尾元素 public T removeLast() &#123; return remove(size - 1); &#125; // 从数组中删除指定元素 public void removeElement(T e) &#123; int index = find(e); if (index != -1) &#123; remove(index); &#125; &#125; @Override public String toString() &#123; StringBuilder builder = new StringBuilder(); builder.append(String.format("Array size = %d, capacity = %d \n", size, data.length)); builder.append('['); for (int i = 0; i &lt; size; i++) &#123; builder.append(data[i]); if (i != size - 1) &#123; builder.append(", "); &#125; &#125; builder.append(']'); return builder.toString(); &#125; // 扩容方法，时间复杂度 O(n) private void resize(int capacity) &#123; T[] newData = (T[]) new Object[capacity]; for (int i = 0; i &lt; size; i++) &#123; newData[i] = data[i]; &#125; data = newData; &#125; private void checkIndex(int index) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException("Add failed! Require index &gt;=0 and index &lt;= size."); &#125; &#125; private void checkIndexForRemove(int index) &#123; if(index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException("remove failed! Require index &gt;=0 and index &lt; size."); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Sum-up</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>GenericArray</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array(数组)]]></title>
    <url>%2Fleetcode%2F2019%2F05%2F27%2Farrays-in-leetcode.html</url>
    <content type="text"><![CDATA[Array(数组)Last Modified: 2019/5/27 11:09 by dp 01. Two Sum（两数之和） 02. Three Sum（三数之和） 03. Majority Element（在数组中出现次数超过一半的数） 04. FizzBuzz（3 和 5 的倍数） 05. Merge Sorted Array（合并两个有序数组） 06. First Missing Positive（寻找缺失的最小正数） 07. Kth Largest Element in an Array（查找第K大的数） 08. Single Number（数组中只出现一次的数） 09. Find All Duplicates in an Array（数组中重复的数字） 10. 实现动态数组（泛型）]]></content>
      <categories>
        <category>Sum-up</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Sum-up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[442. Find All Duplicates in an Array]]></title>
    <url>%2Fleetcode%2F2019%2F05%2F27%2F442.html</url>
    <content type="text"><![CDATA[数组中重复的数据题目给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。 找到所有出现两次的元素。 你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？ 示例： 输入:[4,3,2,7,8,2,3,1] 输出:[2,3] 思路 元素的值在不超过数组的长度，我们遍历数组，将元素值映射的下标改为负数，当遇到负数时，说明该元素下标映射的值已经出现过了。 和41. First Missing Positive中取负值的思路差不多，但是方法略有不同，所以不要死记硬背！ java代码1234567891011121314151617181920212223242526272829/** * @description: 元素的值在不超过数组的长度，遍历数组将元素映射的下标改成负数，当遇到负数时，说明该元素下标映射的值已经出现过了 * @author: rhsphere * @since: 2019-05-27 09:30 by jdk 1.8 */public class FindAllDuplicates &#123; public static List&lt;Integer&gt; findDuplicates(int[] nums) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (nums.length &lt;= 0) return list; for (int i = 0; i &lt; nums.length; i++) &#123; int v = Math.abs(nums[i]); if (nums[v - 1] &gt; 0) &#123; nums[v - 1] *= -1; &#125; else &#123; list.add(Math.nums[i]); &#125; &#125; return list; &#125; public static void main(String[] args) &#123; int[] arr = &#123;4,3,2,7,8,2,3,1&#125;; List&lt;Integer&gt; list = findDuplicates(arr); System.out.println(list); &#125;&#125;]]></content>
      <categories>
        <category>Medium</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[136. Single Number]]></title>
    <url>%2Fleetcode%2F2019%2F05%2F27%2F136.html</url>
    <content type="text"><![CDATA[数组中只出现一次的数题目给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1]输出: 1示例 2: 输入: [4,1,2,1,2]输出: 4 java代码1234567891011121314151617181920212223/** * @description: 异或操作最秀的用法了 * @author: rhsphere * @since: 2019-05-27 09:06 by jdk 1.8 */public class SingleNumber &#123; public static int singleNumber(int[] nums) &#123; int ans = 0; /* for (int i : nums) ans ^= i; */ for (int i = 0; i &lt; nums.length; i++) ans ^= nusm[i]; return ans; &#125; public static void main(String[] args) &#123; int[] arr = &#123;4,1,2,1,2&#125;; int a = singleNumber(arr); System.out.println(a); &#125;&#125; 总结 由于题目原因，用异或太简单了，但是foreach比正常for循环执行速度要慢很多]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[215. Kth Largest Element in an Array]]></title>
    <url>%2Fleetcode%2F2019%2F05%2F27%2F215.html</url>
    <content type="text"><![CDATA[数组中的第K个最大元素题目在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 输入: [3,2,1,5,6,4] 和 k = 2输出: 5示例 2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @description: 用快排的思想，partition函数 * @author: rhsphere * @since: 2019-05-26 10:49 by jdk 1.8 */public class KthLarget &#123; public static int findKthLargest(int[] nums, int k) &#123; int start = 0; int end = nums.length - 1; int index = nums.length - 1; while (start &lt; end) &#123; int pivotIndex = partition(nums, start, end); if (pivotIndex &lt; index) &#123; start = pivotIndex + 1; &#125; else if (pivotIndex &gt; index) &#123; end = startIndex - 1; &#125; else &#123; return nums[pivotIndex]; &#125; &#125; return nums[start]; &#125; private static int partition(int[] nums, int start, int end) &#123; int pivot = nums[start]; int mark = start; for (int i = start + 1; i &lt;= end; i++) &#123; if (nums[i] &lt; pivot) &#123; mark++; int tmp = nums[i]; nums[i] = nums[mark]; nums[mark] = tmp; &#125; &#125; nums[start] = nums[mark]; nums[mark] = pivot; return mark; &#125; public static void main(String[] args) &#123; int[] arr = &#123;3,2,1,5,6,4&#125;; int a = findKthLargest(arr, 2); System.out.println(a); &#125;&#125; 总结 应用了快排中partition的函数，参看partition函数的单边循环法 这种方法在提交时，运行时间效果不是很好，不知道有什么可以改进的地方吗? partition单边循环时，可以用一个数组（4 7 6 5 3 2 8 1）演示一下就知道怎么写了]]></content>
      <categories>
        <category>Medium</category>
      </categories>
      <tags>
        <tag>Divide and Conquer</tag>
        <tag>Heap</tag>
        <tag>Quick Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[41. First Missing Positive]]></title>
    <url>%2Fleetcode%2F2019%2F05%2F25%2F41.html</url>
    <content type="text"><![CDATA[缺失的第一个正数题目给定一个未排序的整数数组，找出其中没有出现的最小的正整数。 示例 1: 输入: [3,4,-1,1]输出: 2示例 3: 输入: [7,8,9,11,12]输出: 1说明: 你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。 思路整个的思路就是把nums[i]存储的数放到，下标为nums[i]的位置，处理小于等于0和大于数组长度的nums[i]，交换nums[i]到下标nums[i]是做一下取负值处理，离开的位置i不做处理，把整个数组处理一遍后，遍历数组找到第一个正数所对应的位置，就是第一个缺失的正数。 和剑指offer中3. 数组中重复中的数字差不多，数组存储的数（长度范围内）放在对应下标的位置，离开的位置保持不变，如果没有人填回来说明这个位置空缺，这是只要遍历一次数组，找到第一个空缺的位置就是第一个缺失的正数。 缺失的位置巧妙的用数组的0、1来辅助，先判断是否有1，如果有1那这个位置就可以拿出来放 数组中存储的不在长度范围内的数，把这些数置为1， 如果说这个数离开现在的位置，到nums[i]的位置（比如数组长度6， i = 3, nums[i] = 4, nums[i]去填到i = 4的位置），把这个数变成负数，所以这种方法，最后统计有多少正数，还能统计在数组范围内缺失多少正数。 java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class FindMissingPositive &#123; public static int findMissingPositive(int[] nums) &#123; //1. 判断1是否存在 int n = nums.length; boolean isOneExists = false; for (int i : nums) &#123; // foreach语句出错，错成nums[i] == 1 if (i == 1) isOneExists = true; &#125; if (!isOneExists) return 1; // n == 2判断出错 if (n == 1) return 2; //2. 因为上面判断出1存在的（否则程序结束了），所以可以借用数组下标为1的位置， // 存放不在数组长度范围内的数（小于0和大于数组长度的），将值设置为1，等下在搬移时 //会一直搬移到下标为1的位置进行覆盖 for (int i = 0; i &lt; n; i++) &#123; if (nums[i] &lt;= 0 || nums[i] &gt; n) nums[i] = 1; &#125; //3. 把数组长度内的数都给置为负值， for (int i = 0; i &lt; n; i++) &#123; int v = Math.abs(nums[i]); if (v == n) &#123; //避免越界，而且0位置不是正数 nums[0] = -1 * Math.abs(nums[0]); &#125; else &#123; //由于这个位置v可能会反复访问，所以要加绝对值再取负值 nums[v] = -1 * Math.abs(nums[v]); &#125; &#125; //4. 从下标为1的位置遍历 for (int i = 1; i &lt; n; i++) &#123; if (nums[i] &gt; 0) return i; &#125; //若执行到此步，上面的for循环，说明n-1的位置都是在的， if (nums[0] &gt; 0) return n; return n + 1; &#125; public static void main(String[] args) &#123; int[] nums = &#123;3,4,-1,1&#125;; int a = firstMissingPositive(nums); System.out.println(a); &#125; &#125; 总结 O(2n)的意思是遍历两遍！！！ 本题思路借鉴了剑指Offer3. 重复的数字，请复习 犯了两个错误1. // foreach语句出错，错成nums[i] == 1 2. // n == 2判断出错 可以看本题的思路]]></content>
      <categories>
        <category>Hard</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[88. Merge Sorted Array]]></title>
    <url>%2Fleetcode%2F2019%2F05%2F25%2F88.html</url>
    <content type="text"><![CDATA[合并两个有序数组题目给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。示例: 输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3 输出: [1,2,2,3,5,6] java实现123456789101112131415161718192021222324252627282930313233/** * @description: 合并两个有序数组，考虑在归并排序中的merge函数，需要额外的空间， *本题目中，限制了数组的长度 * @author: rhsphere * @since: 2019-05-25 21:30 by jdk 1.8 */public class MergeSorted &#123; public static void merge(int[] nums1, int m, int[] nums2, int n) &#123; int index = n + m - 1; m--; n--; while (m &gt;= 0 || n &gt;= 0) &#123; if (n == -1) &#123; return; &#125; else if (m &lt; 0) &#123; nums1[index--] = nums2[n--]; &#125; else if (nums1[m] &gt; nums1[n]) &#123; nums1[index--] = nums1[m--]; &#125; else &#123; nums1[index--] = nums2[n--]; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] nums1 = &#123;1,2,7,0,0,0&#125;; int[] nums2 = &#123;4,5,6&#125;; int m = 3, n = 3; merge(nums1, m, nums2, n); System.out.println(Arrays.toString(nums1)); &#125;&#125; 总结 善用断点调试，看清流程怎么走的 合并两个有序数组，虽然没有额外的控件，但是nums1数组的长度题目中是大于等于 m+n的，和归并排序中的merge函数是完全不一样的，归并排序中用了O(n)的空间，来存储合并后的数组 对于 i– 的合理利用]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[412. Fizz Buzz]]></title>
    <url>%2Fleetcode%2F2019%2F05%2F25%2F412.html</url>
    <content type="text"><![CDATA[3和5的倍数题目写一个程序，输出从 1 到 n 数字的字符串表示。 如果 n 是3的倍数，输出“Fizz”； 如果 n 是5的倍数，输出“Buzz”； 3.如果 n 同时是3和5的倍数，输出 “FizzBuzz”。 示例： n = 15, 返回:[ “1”, “2”, “Fizz”, “4”, “Buzz”, “Fizz”, “7”, “8”, “Fizz”, “Buzz”, “11”, “Fizz”, “13”, “14”, “FizzBuzz”] java实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * @description: 比较简单，分别判断3和5的倍数标志 * @author: rhsphere * @since: 2019-05-25 20:51 by jdk 1.8 */public class FizzBuzz &#123; /* public List&lt;String&gt; fizzBuzz(int n) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); if (n &lt;= 0) return list; int i = 0; while (i &lt;= n) &#123; String out = ""; boolean t = false, f = false; if (i % 3 == 0) t = true; if (i % 5 == 0) f = true; if (t &amp; f) &#123; out = "FizzBuzz"; &#125; else if (t) &#123; out = "Fizz"; &#125; else if (f) &#123; out = "Buzz"; &#125; else &#123; out = Integer.toString(i); &#125; list.add(out); i++; &#125; return list; &#125; */ public List&lt;String&gt; fizzBuzz(int n) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= n; i++) &#123; list.add(isMultiple(i)); &#125; return ans; &#125; private String isMultiple(int n) &#123; if (n % 3 == 0 &amp;&amp; n % 5 != 0) &#123; return "Fizz"; &#125; else if (n % 3 != 0 &amp;&amp; n % 5 == 0) &#123; return "Buzz"; &#125; else if (n % 15 == 0) &#123; return "FizzBuzz"; &#125; else &#123; return String.valueOf(n); &#125; &#125;&#125; 总结 几个方法 String.valueOf(int n)、 Integer.toString(int n)、 list.add() 注释的方法也有可取之处，比如 t &amp; f]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[169. Majority Element]]></title>
    <url>%2Fleetcode%2F2019%2F05%2F25%2F169.html</url>
    <content type="text"><![CDATA[求众数题目给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 输入: [3,2,3]输出: 3示例 2: 输入: [2,2,1,1,1,2,2]输出: 2 java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950** * @description: leetcode上说明, 一定是具有众数存在的，则可以计算出一个初始值 count,从数组的下标1开始， * 如果与下一个数组下标的数字不相等，则count-- 当count 为0 就切换为下一个比较的数字 * @author: rhsphere * @since: 2019-05-25 20:19 by jdk 1.8 */public class MajorityElement &#123; public static int majorityElement(int[] nums) &#123; int maj = nums[0]; int count = 1; int i = 1; while (i &lt; nums.length) &#123; if (nums[i] == maj) count++; else &#123; count--; if (count == 0) &#123; maj = nums[i]; count = 1; &#125; &#125; i++; &#125; return maj; &#125; /*另一种写法 public static int majorityElement(int[] nums) &#123; int maj = nums[0]; int count = 1; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] == maj) &#123; count++; &#125; else &#123; count--; &#125; if (count == 0) &#123; maj = nums[i + 1]; &#125; &#125; return maj; &#125; */ public static void main(Sting[] args) &#123; int[] test1 = &#123;2, 2, 1, 1, 1, 2, 2&#125;; int a = majorityElement(test1); System.out.println(a); &#125;&#125; 总结 O(n) time and O(n) space O(n) time and O(1) space 使用 major 变量记录众数，count 记录遇到 major +1，非 major -1，最终 count 会大于0，major 即代表众数。]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Bit Manipulation</tag>
        <tag>Divide and Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[15. Three Sum]]></title>
    <url>%2Fleetcode%2F2019%2F05%2F25%2F15.html</url>
    <content type="text"><![CDATA[三数之和题目给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ] java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.ArrayList;import java.util.Arrays;import java.util.List;/** * @description: 先排序，然后有两个指针 head 和 tail。 要计算的第一个数一定是负数,所以只要后两个数相加等于0-第一个数即可。 * @author: rhsphere * @since: 2019-05-25 18:57 by jdk 1.8 */public class ThreeSum&#123; public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(nums); for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] &gt; 0) return res; //如果上一次匹配成功了在nums[i-1]，相同的nums[i]显然会重复 if (i &gt; 0 &amp;&amp; nums[i] = nums[i - 1]) continue; //双指针的做法谨记 int head = i + 1, tail = nums.length - 1; int val = 0 - nums[i]; while (head &lt; tail) &#123; if (nums[head] + nums[tail] == val) &#123; List&lt;Integer&gt; list = Arrays.asList(nums[i], nums[head], nums[tail]); res.add(list); while (head &lt; tail &amp;&amp; nums[tail] = nums[tail - 1]) tail--; while (head &lt; tail &amp;&amp; nums[head] = nums[head + 1]) head++; tail--; head++; &#125; else if (nums[head] + nums[tail] &gt; val) &#123; tail--; &#125; else &#123; head++; &#125; &#125; &#125; return res; &#125; public static void main(String[] args) &#123; int nums = &#123;-1, 0, 1, 2, -1, -4&#125;; List&lt;List&lt;Integer&gt;&gt; list = threeSum(nums); System.out.println(list); &#125;&#125; 总结 排序后再进行规约成两数之和 记住几个函数 Arrays.asList()、 Arrays.sort()、 list.add()、 List res = new ArrayList() (接口和抽象类不能实例化) 去重的考虑，有三处做了去重 双指针的方法]]></content>
      <categories>
        <category>Medium</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01. Two Sum]]></title>
    <url>%2Fleetcode%2F2019%2F05%2F25%2F1.html</url>
    <content type="text"><![CDATA[两数之和给定一个整数数组nums和一个目标值target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 Java代码12345678910111213141516import java.util.*;public class TwoSum&#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int key = target - nums[i]; if (map.contains(key)) return new int[]&#123;map.get(key), i&#125;; map.put(nums[i], i); &#125; throw new IllegalArgumentException("No two sum solution"); &#125;&#125;]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(15) 二进制中1的个数]]></title>
    <url>%2Fleetcode%2F2019%2F04%2F21%2Fnumber-of-1-in-binary.html</url>
    <content type="text"><![CDATA[用机器语言编写程序，经常需要直接处理二进制数值，并在位级别上执行操作。位操作可以解决各种各样的问题。有的问题会明确要求用位操作来解决，而在其他的情况下，位操作也是优化代码的实用技巧。写代码要熟悉位操作，同时也要熟悉位操作的手工运算。写好代码后一定要进行充分测试，也可以边写代码边测试。 位操作手工运算其实二进制的位运算不是很难掌握，因为位运算总共只有7种运算：与、或、非(取反)、异或、左移位、带符号位右移位和无符号位右移位。位操作符仅适用于整数类型（byte、short、int和long）。位操作涉及的字符将转换为整数。所有的位操作符可以构成位赋值操作符，如 &amp;=， |=， ~=， ^=， &lt;&lt;=， &gt;&gt;=， &gt;&gt;&gt;=。 对于复杂一点的位操作，可以使用若干技巧来解决。假定操作数的位宽为4。（1）0110 + 0110相当于 0110 * 2，也就是将0110左移1位。 （2）0100 00110100相当于4，上面就等于 4 0011，也就是2^2，于是将0011左移2位得到1100。**一个数与2^n相乘，相当于将这个数左移n位。 （3）1101 ^ (~1101)逐比特分解这个操作。一个比特与对它去烦的数值做异或操作，结果总是1。因此 x ^ (~x)的结果是一串1。 （4）1011 &amp; (~0 &lt;&lt; 2)类似 x &amp; (~0 &lt;&lt; n)的操作会将x最右边的n位清零。 ~0的值是一串1（0在内存中为0x00000000，故取反后为一串1），将它左移n位后的结果为一串1后面跟n个0。将这个数与x进行“位与”操作，相当于将x最右边的n位清零。 位操作原理与技巧处理位操作问题时，理解下面的原理会有很大帮助。下面的示例中，“1s”和“0s”分别表示一串1和一串0。异或x ^ 0s = x x ^ 1s = ~x x ^ x = 0与x &amp; 0s = 0 x &amp; 1s = x x &amp; x = x或x | 0s = x x | 1s = 1s x | x = x 要理解这些表达式的含义，需要记住 所有操作都是按位进行的，某一位的运算结果不会影响其余位。 清零取数要用与，某位置一可用或若要取反和交换，轻轻松松用异或 常见位操作常见操作有：获取、设置、清除及更新位数据以下这些位操作很重要，不过不要死记硬背，否则会滋生一些难以觉察的错误，相反，要吃透这些操作方法，学会举一反三，灵活处理问题。 获取该方法将1左移i位，接着，对这个值与num执行“位与”操作，从而将i位之外的所有位清零。最后，检查该结果是否为零。不为零说明i位为1，否则，i位为0。 n &amp; (1 &lt;&lt; (k - 1)) 第k位置为1 123boolean getBit(int num, int i) &#123; return ((num &amp; (1 &lt;&lt; i)) != 0);&#125; 置位将1左移i位，然后对这个值和num执行“位或”操作，这样只会改变i位的数据。该掩码i位除外的位均为零，孤儿不会影响num的其余位。 123int setBit(int num, int i) &#123; return num | (1 &lt;&lt; i);&#125; 清零将给定操作数n的第k位清零，可以用表达式 n &amp; ~(1 &lt;&lt; (k-1)) 将掩码和num执行位与操作，这样只会清零num的i位，其余位保持不变。1234int clearBit(int num, int i) &#123; int mask = ~(1 &lt;&lt; i); return num &amp; mask;&#125; 将num最高位至i位（含）清零的做法如下：1234int clearBitsMSBthroughI(int num, int i) &#123; int mask = (1 &lt;&lt; i) - 1; return num &amp; mask;&#125; 将i位至0位（含）清零的做法：1234int clearBitsIthrough0(int num, int i) &#123; int mask = ~((1 &lt;&lt; (i + 1)) - 1); return num &amp; mask;&#125; 更新这个方法将setBit与clearBit合二为一。首先，用诸如11101111的掩码将num的第i位清零。接着，将带写入值val左移i位，得到一个i位为val但其余位都为0的数。最后，对之前去的的两个结果执行“位或”操作，val为1则将num的i位更新为1，否则该位仍为0。 1234int updateBit(int num, int i, int val) &#123; int mask = ~(1 &lt;&lt; i); return (num &amp; mask) | (val &lt;&lt; i);&#125; (n &amp; (n - 1) == 0) 的含义 （A &amp; B） == 0 的含义 意思是，A和B二进制表示的同一位置绝不会同时为1。因此，如果n &amp; (n - 1) == 0，则 n 和 n-1 就不会有共同的1。 表达式 (n &amp; (n - 1) == 0) 是用来检查n是否为2的某次方（或者检查n是否为0）。 二进制中1的个数题目请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制是1001，有2位是1。因此如果输入9，该函数输出2。 思路遇到与二进制有关的题目，应该想到位运算(与、或、异或、左移、右移)。 方法一：“位与”有一个性质：通过与对应位上为1，其余位为0的数进行与运算，可以判断某一整数指定位上的值是否为1。这道题中，先把整数n与1做与运算，判断最低位是否为1；接着把1左移一位，与n做与运算，可以判断次低位是否为1……反复左移，即可对每一个位置都进行判断，从而可以获得1的个数。这种方法需要循环判断32次。 方法二（better）：如果一个整数不为0，把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1。其余所有位将不会受到影响。再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。因此，把一个整数减1，再和原来的整数做与运算，会把该整数最右边的1变成0。这种方法，整数中有几个1，就只需要循环判断几次。 测试用例1.正数（包括边界值1、0x7FFFFFFF）2.负数（包括边界值0x80000000、0xFFFFFFFF）3.0 java代码123456789101112131415161718192021public class NumberOf1InBinary &#123; public int numberOf1_Solution1(int n) &#123; int count = 0; int flag = 1; while (flag != 0) &#123; if ((flag &amp; n) != 0) count++; flag &lt;&lt;= 1;) &#125; return count; &#125; public int numberOf1_Solution2(int n) &#123; int count = 0; while (n != 0) &#123; count++; n = n &amp; (n - 1); &#125; return count; &#125;&#125; 总结 注意：负数右移还是负数！即如果对n=0x8000 0000右移，最高位的1是不会变的。如果这道题目通过令n=n&gt;&gt;1来计算n中1的个数，该数最终会变成0xFFFF FFFF而陷入死循环！ 把一个整数减1，再和原来的整数做与运算，会把该整数最右边的1变成0。这种方法一定要牢牢记住，很多情况下都可能用到，例如： 一句话判断一个整数是否为2的整数次方； 对两个整数m和n，计算需要改变m二进制表示中的几位才能得到n。 与数字操作有关的题目，测试时注意边界值的问题。对于32位数字，其正数的边界值为1、0x7FFFFFFF，负数的边界值为0x80000000、0xFFFFFFFF。 (flag &amp; n！=0)，而非(flag &amp; n == 1)； 也就不能写成count += (flag &amp; 1)。 if语句中，不能写为if(flag &amp; n != 0) ，而要写成 if((flag &amp; n) != 0)，需要加上括号 扩展题题目编写一个函数，确定需要改变几个位，才能将整数A转成整数B。这道题可以分两步解决：第一步求这两个数的异或；第二步统计异或结果中1的位数。 只要输出a^b有几个位为1即可。1234567int bitSwapRequired(int a, int b) &#123; int count = 0; for (int c = a ^ b; c != 0; c &gt;&gt;= 1) &#123; count += c &amp; 1; &#125; return count;&#125; 上面的代码的做法是不断对c执行移位操作，然后检查最低有效位，但是其实可以不断翻转最低有效位，计算要多少次才会变成0。操作c = c &amp; (c - 1)会清楚c的最低有效位。 1234567public static int bitSwapRequired(int a, int b) &#123; int count = 0; for (int c = a ^ b; c != 0; c = c &amp; (c - 1)) count++; return count;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>bit</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(14) 剪绳子]]></title>
    <url>%2Fleetcode%2F2019%2F04%2F21%2Fcut-rope.html</url>
    <content type="text"><![CDATA[动态规划(Dynamic Programming, DP)是一项虽简单但较难掌握的技术，一个容易识别和求解DP问题的方法时通过求解尽可能多的问题。”Programming”一词并不是指编程，而是填充表格（类似线性规划）。 递归和动态规划递归尽管递归问题五花八门，但题型大都类似。一个问题是不是递归的，就看它能不能分解成子问题进行求解。当你听到问题是这么开头的：“设计一个算法，计算第n个……”，“编写代码列出前n个……”，“实现一个方法，计算所有……”等等，那么这个问题基本就是一个递归问题。 递归的解法，根据定义，就是从较小的子问题逐渐逼近原始问题。很多时候，只要在f(n-1)的解法中 加入、移除某些东西或者稍作修改就能计算出f(n)。而在其他情况下，答案可能更为复杂。 你应该双管齐下，自下而上和自上而下两种递归解法都要考虑。简单构造法对递归问题就很奏效。自下而上的递归：自下而上的递归往往最为直观。首先要知道如何解决简单情况下的问题，比如，只有一个元素的列表，找出有两个、三个元素的列表的解法，依此类推。这种接法的关键在于，如何从先前解出来的答案，构建出后续情况的答案。 自上而下的递归：自上而下的递归可能比较复杂，不过对某些问题很有必要。遇到此类问题时，我们要思考如何才能将情况N下的问题分解成多个子问题。同时注意子问题是否重叠了。 分治分治（Divide and Conquer）法递归地将问题分解成两个或多个同类型的子问题，直到这些子问题简单到能够直接求解，然后将这些子问题的解合成为原始问题的解。 分治一般包括如下步骤： 分（divide）：将初始问题分割成多个子问题，这些子问题是与初始问题同类型的规模更小的实例。 递归（recursion）：递归求解子问题。 治（conquer）：合理地组合子问题的解。 分治法递归地求解子问题，所有问题一般按照递归进行定义，用 主定理（Master theorem）容易求得这些递归问题的时间复杂度。 分治法的应用 二分查找 归并排序 快速排序 中间值查找 最大最小值查找 矩阵乘法 最近点对问题 动态规划如果听到问题是求一个最优解（通常是求最大值或最小值），而且该问题能够分解成若干子问题，并且子问题之间还有重叠的更小的子问题，就可以考虑用动态规划来解决这个问题。 动态规划的四个特点（剑指Offer总结）： 求一个问题的最优解 整体问题的最优解是依赖各个子问题的最优解 把大问题分解成若干小问题，这些小问题之间还有相互重叠的更小的子问题 由于子问题在分解大问题的过程中重复出现，为了避免重复求解子问题，用从下往上的顺序先计算小问题的最优解并存储下来，再以此为基础求取大问题的最优解。 从上往下分析问题，从下往上求解问题。 动态规划的四个特点： 最优子结构 子问题重叠 有边界 子问题独立 动态规划和分治法的主要区别是：对于分治法，子问题是相互独立的，而在动态规划中子问题可能是重叠的，通过使用备忘录（用一个表来保存已解决子问题的答案），对于大部分问题，动态规划能够将待求解问题的复杂度由指数级降低为多项式级。动态规划主要包含以下两个部分： 递归： 递归求解子问题。 备忘录： 将已计算的值存储在表中。 动态规划 = 递归 + 备忘录 动态规划算法例子 许多字符串算法，如最长公共子序列、最长递增子序列、最长公共子串、编辑距离等 关于图的有效求解算法，如寻找图中最短距离的Bellman-Ford算法、Floyd的所有定点间最短路径算法等 链矩阵乘法 子集和 0/1背包问题 旅行商问题等 贪婪算法贪婪算法将问题分为多个阶段。在每一个阶段，选取当前状态下的最优决策，而不考虑对后续决策的影响。这意味着算法在执行过程中会选取某些 局部最优解。贪婪算法假设通过局部最优解可以获得全局最优解。 贪婪算法的要素： 贪婪选择性质 最优子结构 贪婪选择性质： 全局最优解可以通过寻找局部最优解获得（贪婪），局部最优解的选择可能依赖于之前的决策。通过迭代方式算法进行一个个贪婪选择，将原问题简化为规模更小的问题。 最优子结构： 如果原问题的最优解包含子问题的最优解，则认为该问题具有最优子结构。这意味着可以对子问题求解并构建规模更大的解。 贪婪算法的优缺点优点：直观，易于理解和编程实现。当前的决策不会对已经计算出的结果有任何影响，因此不需要再对已有的局部解进行检查。 缺点：选择局部最优不是对于所有问题都是用，所以贪婪算法并不总能得到最优解。在许多情况下，无法保证最优解能够产生局部最优解。 通常需要用数学的方式来证明贪婪选择是正确的。 贪婪算法的应用 排序问题，选择排序、拓扑排序 优先队列，堆排序 哈夫曼编码 Prim和Kruskal算法 加权图的最短路径算法（Dijkstra算法） 硬币找零问题 分数背包问题 并查集的按大小或高度合并问题（或排名） 任务调度算法 求解复杂问题的近似算法 剪绳子题目给你一根长度为n绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m≥1）。每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]·k[1]·…·k[m]可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。 思路本题采用动态规划或者贪婪算法可以实现。一开始没有思路时，可以从简单的情况开始想，试着算以下比较短的绳子是如何剪的。当n=1时，最大乘积只能为0； 当n=2时，最大乘积只能为1； 当n=3时，最大乘积只能为2； 当n=4时，可以分为如下几种情况:1·1·1·1，1·2·1，1·3，2·2，最大乘积为4； 往下推时，发现n≥4时，可以把问题变成几个小问题，即：如果把长度n绳子的最大乘积记为f(n)，则有：f(n)=max(f(i) · f(n - 1))，0 &lt; i &lt; n。所以思路就很容易出来了：自底向上，先算小的问题，再算大的问题，大的问题通过寻找小问题的最优组合得到。 贪婪算法依赖于数学证明，当绳子大于5时，尽量多地剪出长度为3的绳子是最优解。 测试用例1.功能测试（长度大于5）2.边界测试（长度1,2,3,4） 完整java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class CuttingRope &#123; // ======动态规划====== public int maxProductAfterCutting_solution1(int length) &#123; if (length &lt;= 1) return 0; if (length == 2) return 1; if (length == 3) return 2; int[] product = new int[length + 1]; // 用于存放最大乘积值 // 下面几个不是乘积，因为其本身长度比乘积大 product[0] = 0; product[1] = 1; product[2] = 2; product[3] = 3; // 开始从下到上计算长度为i绳子的最大乘积值product[i] for (int i = 4; i &lt;= length; i++) &#123; int max = 0; // 算不同子长度的乘积，找出最大的乘积 for (int j = 1; j &lt;= i / 2; j++) &#123; if (max &lt; product[j] * product[i - j]) max = product[j] * product[i - j]; &#125; product[i] = max; &#125; return product[length]; &#125; / =======贪婪算法======== public int maxProductAfterCutting_solution2(int length) &#123; if (length &lt;= 1) return 0; if (length == 2) return 1; if (length == 3) return 2; int timesOf3 = length / 3; int timesOf2 = 0; if (length - timesOf3 * 3 == 1) &#123; timesOf3--; // timesOf2=2; //错误！ &#125; timesOf2 = (length - timesOf3 * 3) / 2; return (int) (Math.pow(3, timesOf3) * Math.pow(2, timesOf2)); &#125;&#125; 总结1.最优解问题，经常使用动态规划法，关键要刻画最优解的结构特征（本题的f(n)），从下往上计算最优解的值，没有思路时，从简单情况先算一下。 2.动态规划法中，子问题的最优解一般存放于一个数组中。 3.本题贪婪规划的代码中，timeOf2别忘记等于1的情况。 复习时补充： 动态规划法可以直接令 f(n)=max{f(n-2)2,f(n-3)3} 就可以了。 贪婪算法，核心部分可改为 1234567int timesOf3 = n / 3;if (n % 3 == 0) return (int)(Math.pow(3, timesOf3));if (n % 3 == 1) return (int)(Math.pow(3, timesOf3 - 1) *４)；return (int)(Math.pow(3, timesOf3) * 2);]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>recursive</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(13) 机器人的运动范围]]></title>
    <url>%2Fleetcode%2F2019%2F04%2F19%2Frobot-move.html</url>
    <content type="text"><![CDATA[递归回溯本质上是一种枚举法，可以看成蛮力法的升级版。回溯法用于多个步骤，内个步骤都有多个选项的问题：若当前步骤满足条件，给定一个标记，当发现之后的步骤不满足条件时，去除标记。 机器人的移动范围题目地上有一个m行n列的方格。一个机器人从坐标(0, 0)的格子开始移动，它每一次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格(35, 37)，因为3+5+3+7=18。但它不能进入方格(35, 38)，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 思路与剑指offer(12) 矩阵中的路径类似，也采用回溯法，先判断机器人能否进入(i,j)，再判断周围4个格子。这题返回的是int值。 测试用例1.功能测试（多行多列矩阵，k为正数） 2.边界值测试（矩阵只有一行或一列；k=0） 3.特殊输入测试（k为负数） 程序已验证代码正确性，测试部分去除。 面试题13：机器人的运动范围12345678910111213141516171819202122232425262728293031public class RobotMove &#123; public int movingCount(int threshold, int rows, int cols) &#123; if (rows &lt;= 0 || cols &lt;= 0 || threshold &lt; 0) &#123; return 0; &#125; boolean[] isVisited = new boolean[rows * cols]; int count = movingCountCore(threshold, rows, cols, 0, 0, isVisited); return count; &#125; private int movingCountCore(int threshold, int rows, int cols, int row, int col, boolean[] isVisited) &#123; if (row &lt; 0 || col &lt; 0 || row &gt;= rows || col &gt;= cols || isVisited[row * cols + col] || cal(row) + cal(col) &gt; threshold) return 0; isVisited[row * cols + col] = true; return 1 + movingCountCore(threshold, rows, cols, row - 1, col, isVisited) + movingCountCore(threshold, rows, cols, row + 1, col, isVisited) + movingCountCore(threshold, rows, cols, row, col - 1, isVisited) + movingCountCore(threshold, rows, cols, row, col + 1, isVisited); &#125; private int cal(int num) &#123; int sum = 0; while (num &gt; 0) &#123; sum += num % 10; num /= 10; &#125; return sum; &#125;&#125; 总结]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(12) 矩阵中的路径]]></title>
    <url>%2Fleetcode%2F2019%2F04%2F18%2Fstring-path-in-matrix.html</url>
    <content type="text"><![CDATA[递归回溯本质上是一种枚举法，可以看成蛮力法的升级版。回溯法用于多个步骤，内个步骤都有多个选项的问题：若当前步骤满足条件，给定一个标记，当发现之后的步骤不满足条件时，去除标记。 矩阵中的路径题目请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用下划线标出）。但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。 A B T G C F C S J D E H 思路首先对整个矩阵遍历，找到第一个字符，然后向上下左右查找下一个字符，由于每个字符都是相同的判断方法（先判断当前字符是否相等，再向四周查找），因此采用 递归回溯。由于字符查找过后不能重复进入，所有还要定义一个字符矩阵相同大小的 布尔值矩阵，进入过的格子标记为true。如果不满足的情况下，需要进行 回溯，此时，要将当前位置的布尔值标记回false。（所谓的回溯无非就是对使用过的字符进行标记和对处理后的字符去标记） 测试用例1.功能测试（多行多列矩阵中存在或者不存在路径） 2.边界值测试（矩阵只有一行；矩阵与路径的所有字符都相同） 3.特殊输入测试（null） java代码测试代码太长，未上传。 面试题12：矩阵中的路径1234567891011121314151617181920212223242526272829303132333435363738394041public class StringPathInMatrix &#123; public boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; if (matrix == null || rows &lt; 1 || cols &lt; 1 || str == null) &#123; return false; &#125; boolean[] isVisited = new boolean[rows * cols]; for (boolean v : isVisited) &#123; v = false; &#125; int pathLength = 0; for (int row = 0; row &lt; rows; row++) &#123; for (int col = 0; col &lt; cols; col++) &#123; if (hasPathCore(matrix, rows, cols, row, col, str, pathLength, isVisited)) return true; &#125; &#125; return false; &#125; private boolean hasPathCore(char[] matrix, int rows, int cols, int row, int col, char[] str, int pathLength, boolean[] isVisited) &#123; if (row &lt; 0 || col &lt; 0 || row &gt;= rows || col &gt;= cols || isVisited[row * cols + col] == true || str[pathLength] != matrix[row * cols + col]) return false; if (pathLength == str.length - 1) return true; boolean hasPath = false; isVisited[row * cols + col] = true; hasPath = hasPathCore(matrix, rows, cols, row - 1, col, str, pathLength + 1, isVisited) || hasPathCore(matrix, rows, cols, row + 1, col, str, pathLength + 1, isVisited) || hasPathCore(matrix, rows, cols, row, col - 1, str, pathLength + 1, isVisited) || hasPathCore(matrix, rows, cols, row, col + 1, str, pathLength + 1, isVisited); if (!hasPath) &#123; isVisited[row * cols + col] = false; &#125; return hasPath; &#125;&#125; 总结 回溯法用于多个步骤，内个步骤都有多个选项的问题：若当前步骤满足条件，给定一个标记，当发现之后的步骤不满足条件时，去除标记。 字符串转化为以为字符数组，使用toCharArray()方法。 二维数组下标在一维数组中的计算： row · cols + col。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(11) 旋转数组中的最小数字]]></title>
    <url>%2Fleetcode%2F2019%2F04%2F16%2Fmin-number-in-rotate-array.html</url>
    <content type="text"><![CDATA[数组在一定程度上是排序的，很容易分析出：可以采用二分法来寻找最小数字。 查找和排序在面试时，如果面试官要求实现一个排序算法，那么一定要问清楚这个排序应用的环境是什么、有哪些约束条件。 题目把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组 {3, 4, 5, 1, 2} 为 {1, 2, 3, 4, 5} 的一个旋转，该数组的最小值为1。 思路数组在一定程度上是排序的，很容易分析出：可以采用二分法来寻找最小数字。 但是这里面有一些陷阱： 1.递增排序数组的本身是自己的旋转，则最小数字是第一个数字 2.中间数字与首尾数字大小相等，如 {1, 0, 1, 1, 1, 1} 和 {1, 1, 1, 1, 0, 1}，无法采用二分法，只能顺序查找。 测试用例1.功能测试（正常旋转数组，中间有或者无重复数字） 2.边界值测试（升序数组，1个数字的数组） 3.特殊输入测试（null，空数组） 完整java代码旋转数组中的最小数字123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class MinNumberInRotateArray &#123; public int minNumberInRotateArray(int[] arr) &#123; if (arr == null || arr.length &lt;= 0) return 0; int low = 0; int high = arr.length - 1; int mid = low + (high - low) &gt;&gt; 1; // 升序数组 if (arr[low] &lt; arr[high]) return arr[low]; // 中间数字与首尾数字相等 if (arr[mid] == arr[high] &amp;&amp; arr[mid] == arr[low]) &#123; for (int i = 1; i &lt;= high; i++) &#123; if (arr[i] &lt; arr[i - 1]) return arr[i]; &#125; return arr[low]; &#125; // 正常情况 while (low &lt; high) &#123; if (high - low == 1) break; mid = (low + high) / 2; if (arr[mid] &lt;= arr[high]) &#123; high = mid; &#125; else &#123; low = mid; &#125; &#125; return arr[high]; &#125; public void test1() &#123; int[] array = null; System.out.println("test1:" + minNumberInRotateArray(array)); &#125; public void test2() &#123; int[] array = &#123;&#125;; System.out.println("test2:" + minNumberInRotateArray(array)); &#125; public void test3() &#123; int[] array = &#123; 1 &#125;; System.out.println("test3:" + minNumberInRotateArray(array)); &#125; public void test4() &#123; int[] array = &#123; 1, 2, 3, 4, 5, 6 &#125;; System.out.println("test4:" + minNumberInRotateArray(array)); &#125; public void test5() &#123; int[] array = &#123; 2, 2, 2, 2, 1, 2 &#125;; System.out.println("test5:" + minNumberInRotateArray(array)); &#125; public void test6() &#123; int[] array = &#123; 2, 1, 2, 2, 2, 2 &#125;; System.out.println("test6:" + minNumberInRotateArray(array)); &#125; public void test7() &#123; int[] array = &#123; 6, 6, 8, 9, 10, 1, 2, 2, 3, 3, 4, 5, 6 &#125;; System.out.println("test7:" + minNumberInRotateArray(array)); &#125; public static void main(String[] args) &#123; MinNumberInRotateArray demo = new MinNumberInRotateArray(); demo.test1(); demo.test2(); demo.test3(); demo.test4(); demo.test5(); demo.test6(); demo.test7(); &#125;&#125; 牛客网优秀代码牛客网中的FINACK写的代码1234567891011121314151617public class Solution&#123; public int minNuberInRotateArray(int[] arr) &#123; int low = 0; int high = arr.length - 1; while (low &lt; high) &#123; int mid = low + (high - low) &gt;&gt; 1; if (arr[mid] &gt; arr[high]) &#123; low = mid + 1; &#125; else if (arr[mid] == arr[high]) &#123; high = high - 1; &#125; else &#123; high = mid; &#125; &#125; return arr[low]; &#125;&#125; 这段代码的细节：1.使用low = mid + 1，而不是low = mid，最终会使得low = high（左右指针重合）而跳出循环。2.使用high = mid，而不是high = mid - 1，因为mid有可能就是最小值点，不能减1。3.升序数组的情况可以直接在循环中一起搞定，不用单独列出来判断。 不好的地方：1.1.该程序在array[mid] = array[high]时直接顺序查找。但其实这还有可能可以用二分法的，除非还满足array[mid] = array[low]，才只能使用顺序查找。所以可以先排除掉必须顺序查找的情况（类似自己上面的程序，提前判断掉），之后就可以直接删除else if(array[mid] == array[high]){high = high - 1;这两行了。 2.缺少null的判断。 总结1.题目中给定的特殊条件一定要去关注，往往就是解法的题眼，尤其是接触到一个新的概念时，要能快速理解并考虑全面。2.要注意一些特例，如递增数组的本身是自己的旋转、相同数字数组。3.如果数组一定程度上是排序的，可以考虑使用二分法来解题。对于数组的方法（如二分法等），可以用low、high、mid或者left、right、mid来表示左右指针，也即数组下标。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>BinarySearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(10) 斐波那契数列及青蛙跳台阶问题]]></title>
    <url>%2Fleetcode%2F2019%2F04%2F16%2Ffibonacci.html</url>
    <content type="text"><![CDATA[如果我们需要重复地多次计算相同的问题，则通常可以选择用递归或循环两种不同的方法。 递归就是把问题层层分解，直到程序出口处。而循环则是通过设置计算的初始值及终止条件，在一个范围内重复运算。 递归和循环递归虽然有简洁的优点，但它同时也有显著的缺点。递归由于是函数调用自身，而函数调用是有时间和空间的消耗的：每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址及临时变量，而且往栈里压入数据和弹出数据都需要时间。另外，递归中有可能很多计算都是重复的，从而对性能带来很大的负面影响。递归的本质是把一个问题分解成两个或者多个小问题。如果多个小问题存在相互重叠的部分，就存在重复的计算。 通常应用动态规划解决问题时，我们都是用递归的思路分析问题，但由于递归分解的子问题中存在大量的重复，因此我们总是用自上而下的循环来实现代码。 除了效率，递归还有可能引起更严重的问题：调用栈溢出。每一次函数调用在内存栈中分配空间，而每个进程的栈的容量是有限的。当递归调用层级太多时，就会超出栈的容量，从而导致调用栈溢出。 斐波那契数列思路如果直接写递归函数，由于会出现很多重复计算，效率非常底，不采用。 要避免重复计算，采用从下往上计算，可以把计算过了的保存起来，下次要计算时就不必重复计算了：先由f(0)和f(1)计算f(2)，再由f(1)和f(2)计算f(3)……以此类推就行了，计算第n个时，只要保存第n-1和第n-2项就可以了。 测试用例1.功能测试（3，5，8等） 2.边界值测试（0，1，2等） 3.性能测试（50，100等） 4.特殊（负数） 完整java代码时间复杂度为O(n) 斐波那契数列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Fibonacci &#123; public long Fib(long n) &#123; if (n &lt; 0) throw new RuntimeException("下标错误，应从0开始！"); if (n == 0) return 0; if (n == 1) return 1; long prePre = 0; long pre = 1; long result = 1; for (long i = 2; i &lt;= n; i++) &#123; result = prePre + pre; prePre = pre; pre = result; &#125; return result; &#125; // 附：缩略版（考虑到代码的可读性，其实还是上面的方法比较好） public long Fib2(long n) &#123; if (n &lt; 0) throw new RuntimeException("下标错误，应从0开始！"); if (n == 0) return 0; if (n == 1) return 1; long pre = 0; long result = 1; for (long i = 2; i &lt;= n; i++) &#123; result += pre; pre = result - pre; &#125; return result; &#125; public static void main(String[] args) &#123; Fibonacci demo = new Fibonacci(); System.out.println(demo.Fib(0)); System.out.println(demo.Fib(1)); System.out.println(demo.Fib(2)); System.out.println(demo.Fib(8)); System.out.println(demo.Fib(50)); System.out.println(demo.Fib(100)); System.out.println(demo.Fib(-5)); &#125;&#125; 牛客网提交牛客网提交版12345678910111213141516public class Solution &#123; public int Fibonacci(int n) &#123; int[] result = &#123;0, 1&#125;; if (n &lt; 2) return result[n]; int fib1 = 0; int fib2 = 1; int fibN = 0; for (int i = 2; i &lt;=n; i++) &#123; fibN = fib1 + fib2; fib1 = fib2; fib2 = fibN; &#125; return fibN; &#125;&#125; 青蛙跳台阶问题题目1一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 将跳法总数记为f(n)，可以知道f(1)=1，f(2)=2。当n&gt;2时，第一次跳1级的话，还有f(n-1)种跳法；第一次跳2级的话，还有f(n-2)种跳法，所以可以推得f(n)=f(n-1)+f(n-2)，即为斐波那契数列。 题目2一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 解法1： 当n=1时，f(1)=1。 当n大于1时，归纳总结可知：跳上n级台阶，第一次跳1级的话，有f(n-1)种方法；第一次跳2级的话，有f(n-2)种方法……第一次跳n-1级的话，有f(1)种方法；直接跳n级的话，有1种方法，所以可以得到如下公式： f(n) = f(n-1)+f(n-2)+……f(1)+1 （n≥2） f(n-1) = f(n-2)+f(n-3)+…..f(1)+1 （n&gt;2） 由上面两式相减可得，f(n)-f(n-1)=f(n-1)，即f(n) = 2*f(n-1) (n&gt;2) 最终结合f(1)和f(2)，可以推得：f(n)=2^(n-1) 解法2： 假设跳到第n级总共需要k次，说明要在中间n-1级台阶中选出任意k-1个台阶，即C(n-1,k-1)种方法。 所以：跳1次就跳上n级台阶，需要C(n-1,0)种方法；跳2次需要C(n-1,1)种方法……跳n次需要C(n-1,n-1)种方法 总共需要跳C(n-1,0)+C(n-1,1)+C(n-1,2)+……C(n-1,n-1)=2^(n-1)种方法。 解法3： 除了必须到达最后一级台阶，第1级到第n-1级台阶都可以有选择的跳，也就是说对于这n-1个台阶来说，每个台阶都有跳上和不跳上2种情况，所以一共有2^(n-1)种方法。 矩形覆盖问题题目用n个2 · 1的小矩形无重叠地覆盖一个2 · n的大矩形，总共有多少种方法？ 当n = 1时，有一种方法。 当n = 2时，有两种方法。 当n &gt;= 3时，和斐波那契数列类似。第一步竖着放，有f(n-1)种方法；第一步横着放，有f(n-2)种方法。所以f(n)=f(n-1)+f(n-2)。 总结1.求n次方时，可以利用递归来降低时间复杂度 2.当遇到涉及n的问题时（类似青蛙跳台阶问题），不要紧张，可以进行归纳分析，特别注意f(n)与f(n-1)、f(n-2)等的关联，从而找出规律，进行合理建模。 3.return (int)Math.pow(2,target-1); 1) 转int类型]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>fibonacci</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2Fleetcode%2F2019%2F04%2F15%2Fbinary-search.html</url>
    <content type="text"><![CDATA[查找不外乎顺序查找、二分查找、哈希表查找和二叉排序树查找。 二分查找是一个基础的算法，也是面试中常考的一个知识点。二分查找就是将查找的键和子数组的中间键作比较，如果被查找的键小于中间键，就在左子数组继续查找；如果大于中间键，就在右子数组中查找，否则中间键就是要找的元素。 二分查找如果题目中要求在排序的数组（或者部分排序的数组）中查找一个数字或者统计某个数字出现的次数，那么都可以尝试用二分查找算法。哈希表和二叉树炸找的重点在于考查对应的数据结构而不是算法。 二分查找代码每次移动left和right指针的时候，需要在mid的基础上+1或者-1， 防止出现死循环， 程序也就能够正确的运行。 注意：代码中的判断条件必须是while (left &lt;= right)，否则的话判断条件不完整，比如：array[3] = {1, 3, 5};待查找的键为5，此时在(low &lt; high)条件下就会找不到，因为low和high相等时，指向元素5，但是此时条件不成立，没有进入while()中。 二分查找12345678910111213141516171819/** * 二分查找，找到该值在数组中的下标，否则为-1*/public static int binarySearch(int[] arr, int key) &#123; int left = 0; int right = arr.length - 1; // 这里必须是 &lt;= while (left &lt;= right) &#123; int mid = left + (right - left) &gt;&gt; 1; if (arr[mid] == key) &#123; return mid; &#125; else if (arr[mid] &lt; key) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; return -1;&#125; 二分查找的变种关于二分查找，如果条件稍微变换一下，比如：数组之中的数据可能可以重复，要求返回匹配的数据的最小（或最大）的下标；更近一步， 需要找出数组中第一个大于key的元素（也就是最小的大于key的元素的）下标，等等。 这些，虽然只有一点点的变化，实现的时候确实要更加的细心。 二分查找的变种和二分查找原理一样，主要就是变换判断条件（也就是边界条件），如果想直接看如何记忆这些变种的窍门，请直接翻到本文最后。下面来看几种二分查找变种的代码： 查找第一个与key相等的元素查找第一个相等的元素，也就是说等于查找key值的元素有好多个，返回这些元素最左边的元素下标。 查找第一个相等的元素12345678910111213141516public static int fingFirstEqual(int[] arr, int key) &#123; int left = 0; int right = arr.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) &gt;&gt; 1; if (arr[mid] &gt;= key) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; if (left &lt; arr.length &amp;&amp; arr[left] == key) &#123; return left; &#125; return -1;&#125; 查找最后一个与key相等的元素查找最后一个相等的元素，也就是说等于查找key值的元素有好多个，返回这些元素最右边的元素下标。查找最后一个与key相等的元素1234567891011121314151617public static int findLastEqual(int[] arr, int key) &#123; int left = 0; int right = arr.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) &gt;&gt; 1; if (arr[mid] &lt;= key) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; if (right &gt;= 0 &amp;&amp; arr[right] == key) &#123; return right; &#125; return -1;&#125; 查找最后一个等于或小于key的元素查找最后一个等于或小于key的元素，也就是说等于查找key值的元素有好多个，返回这些元素最右边的元素下标；如果没有等于key值的元素，则返回小于key的最右边元素下标。 查找最后一个等于或小于key的元素12345678910111213public static int findLastEqualSmaller(int[] arr, int key) &#123; int left = 0; int right = arr.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) &gt;&gt; 1; if (arr[mid] &gt; key) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return right;&#125; 查找最后一个小于key的元素查找最后一个小于key的元素，也就是说返回小于key的最右边元素下标。 返回最后一个小于key的元素12345678910111213public static int findLastSmaller(int[] arr, int key) &#123; int left = 0; int right = arr.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) &gt;&gt; 1; if (arr[mid] &gt;= key) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return right;&#125; 查找第一个等于或者大于key的元素查找第一个等于或者大于key的元素，也就是说等于查找key值的元素有好多个，返回这些元素最左边的元素下标；如果没有等于key值的元素，则返回大于key的最左边元素下标。 查找第一个大于等于key的元素12345678910111213public static int findFirstEqualLarger(int[] arr, int key) &#123; int left = 0; int rigth = arr.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) &gt;&gt; 1; if (arr[mid] &gt;= key) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return left;&#125; 查找第一个大于key的元素查找第一个等于key的元素，也就是说返回大于key的最左边元素下标。 查找第一个大于key的元素12345678910111213public static int findFirstLarger(int[] arr, int key) &#123; int left = 0; int right = arr.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) &gt;&gt; 1; if (arr[mid] &gt; key) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return left;&#125; 二分查找变种总结而分查找核心123456789while (left &lt;= right) &#123; int mid = (left + right) / 2; if (arr[mid] ? key) &#123; //...right = mid - 1; &#125; else &#123; //...left = mid + 1; &#125;&#125;return xxx; 首先判断出返回left，还是right因为最后跳出 while (left &lt;= right) 循环条件是 right &lt; left 且 right = left - 1。最后right和left一定卡在“边界值”的左右两边，如果比较值是key，查找小于等于（或是小于）key的元素，则边界值就是等于key的所有元素的最左边那个，其实应该返回left。 判断出比较符号二分查找判断符号123456int mid = (left + right) / 2;if (arr[mid] ? key) &#123; //...right = mid - 1;&#125; else &#123; //...left = mid + 1;&#125; 也就是这里的if (array[mid] ? key) 中的判断符号，结合步骤1和给出的条件，如果是查找小于等于key的元素，则知道应该使用判断符号&gt;=，因为是要返回left，所以如果array[mid]等于或者大于key，就应该使用&gt;=，以下是完整代码 查找小于等于key的元素123456int mid = (left + right) / 2;if (arr[mid] &gt;= key) &#123; right = mid - 1;&#125; else &#123; left = mid + 1;&#125;]]></content>
      <categories>
        <category>Search</category>
      </categories>
      <tags>
        <tag>BinarySearch</tag>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序总结]]></title>
    <url>%2Fleetcode%2F2019%2F04%2F10%2Fsort-summary.html</url>
    <content type="text"><![CDATA[排序算法可以说是一项基本功，解决实际问题中经常遇到，针对实际数据的特点选择合适的排序算法可以使程序获得更高的效率，有时候排序的稳定性还是实际问题中必须考虑的，这篇博客对常见的排序算法进行整理，包括：选择排序、插入排序、希尔排序、冒泡排序、鸡尾酒排序、归并排序、快速排序、堆排序、计数排序、桶排序、基数排序(代码略)。 十大经典排序算法 比较和非比较排序比较排序常见的快速排序、归并排序、堆排序、冒泡排序等排序算法属于比较排序，在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。在冒泡排序之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。 非比较排序计数排序、基数排序、桶排序则属于非比较排序。因为数据本身包含了定位特征，所有才能不通过比较来确定元素的位置。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr之前有多少个元素，则唯一确定了arr在排序后数组中的位置。非比较排序只要确定每个元素之前的已有的元素个数即可，所以一次遍历即可解决。算法时间复杂度O(n)。非比较排序时间复杂度低，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。 比较排序时间复杂度证明比较排序的时间复杂度通常为O(n²)或者O(nlogn)，比较排序的时间复杂度下界就是O(nlogn)，而非比较排序的时间复杂度可以达到O(n)，但是都需要额外的空间开销。 比较排序时间复杂度为O(nlogn)的证明： a1, a2, a3, ……, an数列的所有排序有n!种，所以满足要求的排序a1’, a2’, a3’, ……, an’（其中a1’&lt;=a2’&lt;=a3’……&lt;=an’）的概率为1/n!。基于输入元素的比较排序，每一次比较的返回不是0就是1，这恰好可以作为决策树的一个决策将一个事件分成两个分支。比如冒泡排序时通过比较a1和a2两个数的大小，可以把序列分成a1, a2, ……, an与a2, a1, ……, an（气泡a2上升一个身位）两种不同的结果，因此比较排序也可以构造决策树。根节点代表原始序列a1, a2, a3, ……, an，所有叶子节点都是这个序列的重排（共有n!个，其中有一个就是我们排序的结果a1’, a2’, a3’, ……, an’）。如果每次比较的结果都是等概率的话（恰好划分为概率空间相等的两个事件），那么二叉树就是高度平衡的，深度至少是log(n!)。 又因为： n! &lt; n^n ，两边取对数就得到log(n!) &lt; nlog(n)，所以 log(n!) = O(nlogn)。 n! = n(n-1)(n-2)(n-3)…1 &gt; (n/2)^(n/2) 两边取对数得到 log(n!) &gt; (n/2)log(n/2) = Ω(nlogn)，所以 log(n!) = Ω(nlogn)。 因此log(n!)的增长速度与 nlogn 相同，即 log(n!) = Θ(nlogn)，这就是通用排序算法的最低时间复杂度为 O(nlogn) 的依据。 排序稳定性和复杂度不稳定选择排序 （Selection Sort）— O(n²) 希尔排序 （Shell Sort）— O(nlogn) 快速排序 （Quick Sort）— O(nlogn) 平均时间， O(n²)最坏情况;对于大的、乱序串列一般认为是最快的已知排序。 堆排序 （Heap Sort）— O(nlogn) 基数排序 （Radix Sort）— O(n·k); 需要 O(n) 额外存储空间 （K为特征个数） 稳定插入排序 （Insertion Sort）— O(n²) 冒泡排序 （Bubble Sort） — O(n²) 归并排序 （Merge Sort）— O(nlogn); 需要 O(n) 额外存储空间 二叉树排序（Binary Tree Sort） — O(nlogn); 需要 O(n) 额外存储空间 计数排序 (Counting Sort) — O(n+k); 需要 O(n+k) 额外存储空间，k为序列中 Max-Min+1 桶排序 （Bucket Sort）— O(n); 需要 O(k) 额外存储空间 10种排序的原理和实现(基数排序和二叉树排序暂无)选择排序（Selection Sort）选择排序的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 遍历数组，遍历到i时，a0, a1, …, ai-1是已经排好序的，然后从i到n选择出最小的，记录下位置，如果不是第i个，则和第i个元素交换。此时第i个元素可能会排到相等元素之后，造成排序的不稳定。 选择排序实现部分1234567891011121314151617181920212223242526public static void selectionSort(int[] arr) &#123; if (arr == null || arr.length &lt; = 1) &#123; return; &#125; int currentMin; int currentMinIndex; for (int i = 0; i &lt; arr.length - 1; i++) &#123; // 找到最小值和最小值下标位置，在范围arr[i ... arr.length-1] currentMin = arr[i]; currentMinIndex = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (currentMin &gt; arr[j]) &#123; currentMin = arr[j]; currentMindIndex = j; &#125; &#125; if (currentMinIndex != i) &#123; arr[currentMinIndex] = arr[i]; arr[i] = currentMin; &#125; &#125;&#125; 插入排序（Insertion Sort）插入排序的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 遍历数组，遍历到i时，a0,a1…ai-1是已经排好序的，取出ai，从ai-1开始向前和每个比较大小，如果小于，则将此位置元素向后移动，继续先前比较，如果不小于，则放到正在比较的元素之后。 可见相等元素比较是，原来靠后的还是排在后边，所以插入排序是稳定的。当待排序的数据基本有序时，插入排序的效率比较高，只需要进行很少的数据移动。 插入排序实现部分1234567891011121314public static void insertionSort(int[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; // 插入arr[i]到已经排好序的子线性表arr[0 ... i-1]中 int currentElement = arr[i]; int k; for (k = i - 1; k &gt; 0 &amp;&amp; arr[k] &gt; currentElement; k--) &#123; arr[k+1] = arr[k]; &#125; // 插入当前元素到arr[k+1]中 arr[k + 1] = currentElement; &#125;&#125; 希尔排序（Shell Sort）希尔排序又叫缩小增量排序，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。 希尔排序是对插入排序的优化，基于以下两个认识：1.数据量较小时插入排序速度较快，因为n和n²差距很小；2.数据基本有序时插入排序效率很高，因为比较和移动的数据量少。 因此，希尔排序的基本思想是，将需要排序的序列划分成为若干个较小的子序列，对子序列进行插入排序，通过插入排序能够使得原来序列成为基本有序。这样通过对较小的序列进行插入排序，然后对基本有序的数列进行插入排序，能够提高插入排序算法的效率。 希尔排序的划分子序列不是像归并排序那种的二分，而是采用的叫做增量的技术，例如有十个元素的数组进行希尔排序，首先选择增量为10/2=5，此时第1个元素和第（1+5）个元素配对成子序列使用插入排序进行排序，第2和（2+5）个元素组成子序列，完成后增量继续减半为2，此时第1个元素、第（1+2）、第（1+4）、第（1+6）、第（1+8）个元素组成子序列进行插入排序。这种增量选择方法的好处是可以使数组整体均匀有序，尽可能的减少比较和移动的次数。二分法中即使前一半数据有序，后一半中如果有比较小的数据，还是会造成大量的比较和移动，因此这种增量的方法和插入排序的配合更佳。 希尔排序的时间复杂度和增量的选择策略有关，上述增量方法造成希尔排序的不稳定性。 希尔排序实现部分123456789101112131415public static int[] shellSort(int[] arr) &#123; for (int gap = arr.length / 2; gap &gt;= 1; gap /= 2) &#123; // 对子序列插入排序 for (int i = gap; i &lt; arr.length; i++) &#123; int j = i; int currentElement = arr[i]; while (j - gap &gt;= 0 &amp;&amp; arr[j - gap] &gt; currentElement) &#123; arr[j] = arr[j - gap]; j -= gap; &#125; arr[j] = currentElement; &#125; &#125; return arr;&#125; 冒泡排序（Bubble Sort）冒泡排序，重复地走访要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 冒泡排序的名字很形象，实际实现是相邻两节点进行比较，大的向后移一个，经过第一轮两两比较和移动，最大的元素移动到了最后，第二轮次大的位于倒数第二个，依次进行。这是最基本的冒泡排序，还可以进行一些优化。优化一：如果某一轮两两比较中没有任何元素交换，这说明已经都排好序了，算法结束，可以使用一个isSorted做标记，默认为true，如果发生交换则置为false，每轮结束时检测isSorted，如果为false则继续，如果为true则返回。优化二：某一轮结束位置为j，但是这一轮的最后一次交换发生在lastExchangedIndex的位置，则lastExchangedIndex到j之间是排好序的，下一轮的结束点就不必是j–了，而直接到lastExchangedIndex即可。 优化一实现123456789101112131415161718192021public static void bubbleSort(int[] arr) &#123; int tmp = 0; for (int i = 0; i &lt; arr.length; i++) &#123; boolean isSorted = true; for (int j = 0; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; isSorted = false; &#125; &#125; if (isSorted) &#123; break; &#125; &#125;&#125; 优化二实现123456789101112131415161718192021222324252627282930public static void bubbleSort(int[] arr) &#123; int tmp = 0; //记录最后一次交换的位置 int lastExchangedIndex = 0; //无序数列的边界，每次比较只需要比到这里为止 int sortBorder = arr.length - 1; for (int i = 0; i &lt; arr.length; i++) &#123; //有序标记，每一轮的初始是true boolean isSorted = true; for (int j = 0; j &lt; sortBorder; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; //有元素交换，所以不是有序，标记变为false isSorted = false; //把无序数列的边界更新为最后一次交换元素的位置 lastExchangedIndex = j; &#125; &#125; sortBorder = lastExchangedIndex; if (isSorted) &#123; break; &#125; &#125;&#125; 鸡尾酒排序（Cocktail Sort）回顾冒泡排序的思想：冒泡排序的每一个元素都可以像一个小气泡一样，根据自身大小，一点一点向着数组的一侧移动。算法的每一轮都是 从左到右比较元素，进行单向的位置交换。那么鸡尾酒排序做了怎样的优化呢？鸡尾酒排序的元素比较和交换过程是 双向的。 鸡尾酒排序代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static void cockTailSort(int[] arr) &#123; int tmp = 0; int lastRightExchangedIndex = 0; //记录右侧最后一次交换的位置 int lastLeftExchangedIndex = 0; //记录左侧最后一次交换的位置 //无序数列的右边界，每次比较只需要比到这里为止 int rigthSortBorder = arr.length - 1; //无序数列的左边界，每次比较只需要比到这里为止 int leftSortBorder = 0; for (int i = 0; i &lt; arr.length / 2; i++) &#123; boolean isSorted = true; //奇数轮，从左向右比较和交换 for (int j = leftSortBorder; j &lt; rigthSortBorder; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; isSorted = false; lastRightExchangedIndex = j; &#125; &#125; rigthSortBorder = lastRightExchangedIndex; if (isSorted) &#123; break; &#125; isSorted = true; //偶数轮，从右向左比较和交换 for (int j = rigthSortBorder; j &gt; leftSortBorder; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; tmp = arr[j]; arr[j] = arr[j - 1]; arr[j - 1] = tmp; isSorted = false; lastLeftExchangedIndex = j; &#125; &#125; leftSortBorder = lastLeftExchangedIndex; if (isSorted) &#123; break; &#125; &#125;&#125; 归并排序（Merge Sort）归并排序是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 首先考虑下如何将二个有序数列合并。这个非常简单，只要从比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。这需要将待排序序列中的所有记录扫描一遍，因此耗费O(n)时间，而由完全二叉树的深度可知，整个归并排序需要进行 logn次，因此，总的时间复杂度为O(nlogn)。 归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果，因此空间复杂度为O(n)。归并算法需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法。 归并排序实现1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void mergeSort(int[] arr, int left, int right) &#123; if (left == right) &#123; return; &#125; else &#123; // 取中间的数进行拆分 int mid = (left + right) / 2; // 左边的数不断进行拆分 mergeSort(arr, left, mid); // 右边的数不断进行拆分 mergeSort(arr, mid + 1, right); // 合并 merge(arr, left, mid + 1, right); &#125;&#125;public static void merge(int[] arr, int left, int mid, int right) &#123; int[] leftArray = new int[mid - left]; int[] rightArray = new int[right - mid + 1]; for (int i = left; i &lt; mid; i++) &#123; leftArray[i - left] = arr[i]; &#125; for (int i = mid; i &lt;= right; i++) &#123; rightArray[i - mid] = arr[i]; &#125; int i = 0, j = 0; int k = left; while (i &lt; leftArray.length &amp;&amp; j &lt; rightArray.length) &#123; if (leftArray[i] &lt; rightArray[j]) &#123; arr[k++] = leftArray[i++]; &#125; else &#123; arr[k++] = rigthArray[j++]; &#125; &#125; while (i &lt; leftArray.length) &#123; arr[k++] = leftArray[i++]; &#125; while (j &lt; rightArray.length) &#123; arr[k++] = rigthArray[j++]; &#125;&#125; 快速排序（Quick Sort）快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。其中，最重要的partition主要有两种方法：A.先把选定为pivot的元素放到最后，然后设定指针low和指针high，low指针左移，high指针右移，当两个指针相撞后停止移动。期间如果符合交换条件，两元素交换。最后把pivot元素放到中间。B.类似冒泡排序的思路，把比pivot大的元素“往下沉”，把比pivot小的元素“往上浮”。快速排序是目前被认为最好的一种内部排序方法。快速排序算法处理的最好情况指每次都是将待排序数列划分为均匀的两部分，通常认为快速排序的平均时间复杂度是O(nlogn)。 但是，快速排序的最差情况就是基本逆序或者基本有序的情况，那么此时快速排序将蜕化成冒泡排序，其时间复杂度为O(n^2) 快排实现（挖坑法）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public static void quickSort(int[] arr, int startIndex, int endIndex) &#123; //递归结束条件 if (startIndex &gt;= endIndex) &#123; return; &#125; // 得到基准元素位置 int pivotIndex = partition(arr, startIndex, endIndex); // 用分治法递归数列两部分 quickSort(arr, startIndex, pivotIndex - 1); quickSort(arr, startIndex + 1, endIndex);&#125;private static int partition(int[] arr, int startIndex, int endIndex) &#123; // 取第一个位置的元素作为基准元素 int pivot = arr[startIndex]; int left = startIndex; int right = endIndex; // 坑的位置，初始等于pivot的位置 int index = startIndex; // 大循环左右指针重合或者指针交换时结束 while (right &gt;= left) &#123; // right指针从右向左进行比较 while (right &gt;= left) &#123; if (arr[right] &lt; pivot) &#123; arr[left] = arr[right]; index = right; left++; break; &#125; right--; &#125; //left指针从左向右进行比较 while (right &gt;= left) &#123; if (arr[left] &gt; pivot) &#123; arr[right] = arr[left]; index = left; right--; break; &#125; left++; &#125; &#125; arr[index] = pivot; return index;&#125; 快排实现（指针交换法）12345678910111213141516171819202122232425262728293031323334353637383940public static quickSort(int[] arr, int startIndex, int endIndex) &#123; if (startIndex &gt;= endIndex) &#123; return; &#125; // 得到基准信息 int pivotIndex = partition(arr, startIndex, endIndex); //根据基准元素，分成两部分进行递归 quickSort(arr, startIndex, pivotIndex - 1); quickSort(arr, pivotIndex + 1, endIndex);&#125;private static int partition(int[] arr, int startIndex, int endIndex) &#123; // 取第一个元素作为基准元素 int pivot = arr[startIndex]; int left = startIndex; int right = endIndex; while (left != right) &#123; // 控制right指针比较并左移 while (left &lt; right &amp;&amp; arr[right] &gt; pivot) &#123; right--; &#125; // 控制left指针比较并左移 while (left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123; left++; &#125; // 交换left和right指向的元素 if (left &lt; right) &#123; int tmp = arr[left]; arr[left] = arr[right]; arr[right] = tmp; &#125; &#125; // pivot和指针重合交换 int tmp = arr[left]; arr[left] = arr[startIndex]; arr[startIndex] = tmp; return left;&#125; 单边循环法1234567891011121314151617181920212223242526public static void quickSort(int[] arr, int startIndex, int endIndex) &#123; if (startIndex &gt;= endIndex) &#123; return; &#125; int pivotIndex = partition(arr, startIndex, endIndex); quickSort(arr, startIndex, pivotIndex - 1); quickSort(arr, pivotIndex + 1, endIndex);&#125;private static int partition(int[] arr, int startIndex, int endIndex) &#123; int pivot = arr[startIndex]; int mark = startIndex; for (int i = startIndex + 1; i &lt;= endIndex; i++) &#123; if (arr[i] &lt; pivot) &#123; mark++; int tmp = arr[mark]; arr[mark] = arr[i]; arr[i] = tmp; &#125; &#125; arr[startIndex] = arr[mark]; arr[mark] = pivot; return mark;&#125; 计数排序（Count Sort）如果通过比较进行排序，那么复杂度的下界是O(nlogn)，但是如果数据本身有可以利用的特征，可以不通过比较进行排序，就能使时间复杂度降低到O(n)。 计数排序要求待排序的数组元素都是整数，有很多地方都要求是 0-K 的正整数，其实负整数也可以通过都加一个偏移量解决的。 计数排序的思想是，考虑待排序数组中的某一个元素a，如果数组中比a小的元素有s个，那么a在最终排好序的数组中的位置将会是s+1，如何知道比a小的元素有多少个，肯定不是通过比较去觉得，而是通过数字本身的属性，即累加数组中最小值到a之间的每个数字出现的次数（未出现则为0），而每个数字出现的次数可以通过扫描一遍数组获得。 计数排序的步骤： 1.找出待排序的数组中最大和最小的元素（计数数组C的长度为max-min+1，其中位置0存放min，依次填充到最后一个位置存放max）2.统计数组中每个值为i的元素出现的次数，存入数组C的第i项3.对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）4.反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1（反向填充是为了保证稳定性） 计数排序适合数据分布集中的排序，如果数据太分散，会造成空间的大量浪费，假设数据为（1,2,3,1000000），这就需要1000000的额外空间，并且有大量的空间浪费和时间浪费。 计数排序实现1234567891011121314151617181920212223242526272829303132333435363738394041public static int[] countSort(int[] arr) &#123; // 1. 得到数列的最大值和最小值，并计算出差值d int max = arr[0]; int min = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; if (arr[i] &lt; min) &#123; min = arr[i]; &#125; &#125; int d = max - min; // 2. 创建统计数组并统计对应元素个数 int[] countArray = new int[d + 1]; for (int i = 0; i &lt; arr.length; i++) &#123; countArray[arr[i] - min]++; &#125; // 3. 统计数组做变型，后面的元素等于前面的元素之和 int sum = 0; for (int i = 0; i &lt; countArray.length; i++) &#123; sum += countArray[i]; countArray[i] = sum; &#125; // 4. 倒序遍历原始数组，从统计数组找到正确位置，输出到结果数组 int[] sortedArray = new int[arr.length]; for (int i = arr.length - 1; i &gt;= 0; i--) &#123; // arr[i]-min找到这个数在countArray中的位置 int sumCount = countArray[arr[i] - min]; //得到实际排序后的位置 int sortedPos = sumCount - 1; // 向最终结果里存放元素 sortedArray[sortedPos] = arr[i]; // 针对重复的元素，先放后面，然后减1，下次循环就会放在前面 countArray[arr[i] - min]--; &#125; return sortedArray;&#125; 桶排序（Bucket Sort） 假设有一组长度为N的待排关键字序列K[1….n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标i) ，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]….B[M]中的全部内容即是一个有序序列。 桶排序利用函数的映射关系，减少了计划所有的比较操作，是一种Hash的思想，可以用在海量数据处理中。计数排序也可以看作是桶排序的特例，数组关键字范围为N，划分为N个桶。 桶排序实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public static double[] bucketSort(double[] arr) &#123; // 1. 得到数列的最大值和最小值，并计算出差值d double max = arr[0]; double min = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; if (arr[i] &lt; min) &#123; min = arr[i]; &#125; &#125; double d = max - min; // 2. 初始化桶 int bucketNum = arr.length; ArrayList&lt;LinkedList&lt;Double&gt;&gt; bucketList = new ArrayList&lt;&gt;(bucketNum); for (int i = 0; i &lt; bucketNum; i++) &#123; bucketList.add(new LinkedList&lt;Double&gt;()); &#125; // 3. 遍历原始数组，将每个元素放入桶中 for (int i = 0; i &lt; arr.length; i++) &#123; int num = (int) ((arr[i] - min) * (bucketNum - 1) / d); bucketList.get(num).add(arr[i]); &#125; // 4. 对每个桶内部进行排序 for (int i = 0; i &lt; bucketList.size(); i++) &#123; // JDK低层采用了归并排序或归并的优化版本 Collections.sort(bucketList.get(i)); &#125; // 5. 输出全部元素 double[] sortedArray = new double[arr.length]; int index = 0; for (LinkedList&lt;Double&gt; list : bucketList) &#123; for (double element : list) &#123; sortedArray[index] = element; index++; &#125; &#125; return sortedArray;&#125; 堆排序（Heap Sort） 堆排序是把数组看作堆，第i个结点的孩子结点为第2i + 1和2i + 2个结点（不超出数组长度前提下），堆排序的第一步是建堆，然后是取堆顶元素然后调整堆。建堆的过程是自底向上不断调整达成的，这样当调整某个结点时，其左节点和右结点已经是满足条件的，此时如果两个子结点不需要动，则整个子树不需要动，如果调整，则父结点交换到子结点位置，再以此结点继续调整。 下述代码使用的大顶堆，建立好堆后堆顶元素为最大值，此时取堆顶元素即使堆顶元素和最后一个元素交换，最大的元素处于数组最后，此时调整小了一个长度的堆，然后再取堆顶和倒数第二个元素交换，依次类推，完成数据的非递减排序。 堆排序的主要时间花在初始建堆期间，建好堆后，堆这种数据结构以及它奇妙的特征，使得找到数列中最大的数字这样的操作只需要O(1)的时间复杂度，维护需要logn的时间复杂度。堆排序不适宜于记录数较少的文件。 堆排序实现12345678910111213141516171819202122232425262728293031323334353637//堆排序 arr为待调整的堆public static void heapSort(int[] arr) &#123; // 1. 把无序数组构建成二叉堆 for (int i = (arr.length - 2) / 2; i &gt;= 0; i--) &#123; downAdjust(arr, i, arr.length); &#125; System.out.println(Arrays.toString(arr)); // 2.循环删除栈顶元素，移到集合尾部，调整堆产生新的栈顶 for (int i = arr.length - 1; i &gt; 0; i--) &#123; //最后一个元素和第一个元素进行交换 int tmp = arr[i]; arr[i] = arr[0]; arr[0] = tmp; // 下沉调整最大堆 downAdjust(arr, 0, i); &#125;&#125;public static downAdjust(int[] arr, int parentIndex, int length) &#123; int tmp = arr[parentIndex]; int childIndex = 2 * parentIndex + 1; while (childIndex &lt; length) &#123; // 如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子 if (childIndex + 1 &lt; length &amp;&amp; arr[childIndex + 1] &gt; arr[childIndex]) &#123; childIndex++; &#125; //如果父节点大于任何一个孩子的值，直接跳出 if (tmp &gt;= arr[childIndex]) break; //无需真正交换，单向赋值即可 arr[parentIndex] = arr[childIndex]; parentIndex = childIndex; childIndex = 2 * childIndex + 1; &#125; arr[parentIndex] = tmp;&#125;]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序(11) 外部排序]]></title>
    <url>%2Fleetcode%2F2019%2F04%2F01%2Fexternal-sort.html</url>
    <content type="text"><![CDATA[前面讨论的排序算法，都假定要排序的所有数据在内存中都同时可用，如数组。要对存储在外部文件中的数据排序，首先要将数据送入内存，然后对它们进行内部排序。然而，如果文件太大，那么文件中的所有数据不能都同时送入内存。在大型外部文件中对数据排序，称为外部排序(external sort)。 创建大文件创建一个200万int值存储在一个名为largedata.dat的二进制文件中。使用下面的程序创建： 123456789101112131415161718import java.io.*;public class CreateLargeFile &#123; public static void main(String[] args) throws Exception &#123; DataOutputStream output = new DataOutputStream( new BufferedOutputStream(new FileOutputStream("largedata.dat"))); for (int i = 0; i &lt; 800004; i++)&#123; output.writeInt((int)(Math.random() * 1000000)); &#125; output.close(); DataInputStream input = new DataInputStream( new BufferedInputStream(new FileInputStream("largedata.dat"))); for (int i = 0; i &lt; 100; i++) &#123; System.out.print(input.readInt() + " "); &#125; input.close(); &#125;&#125; 归并排序实现实现阶段1重复将数据从文件读入数组，并使用内部排序算法堆数组排序，然后将数据从数组输出到一个临时文件中。下面的代码给出了一个方法，它从文件中读取每个数据段，并对分段进行排序，然后将排好序的分段存在一个心文件中。该方法返回分段的个数。 创建初始的有序分段1234567891011121314151617181920212223242526272829private static int initializeSegments (int segmentSize, String originalFile, String f1) throws Exception &#123; int[] list = new int[segmentSize]; DataInputStream input = new DataInputStream( new BufferedInputStream(new FileInputStream(originalFile))); DataOutputStream output = new DataOutputStream( new BufferedOutputStream(new FileOutputStream(f1))); int numberOfSegments = 0; while (input.available() &gt; 0) &#123; numberOfSegments++; // 读取一段数据到数组中 int i = 0; for ( ; input.available() &gt; 0 &amp;&amp; i &lt; segmentSize; i++) &#123; list[i] = input.readInt(); &#125; // 对数组排序 java.util.Arrays.sort(list, 0, i); // 将数组中的数据写入到临时文件中 for (int j = 0; j &lt; i; j++) &#123; output.writeInt(list[j]); &#125; &#125; input.close(); output.close(); //返回分段个数，除了最后一个分段的元素数可能较少外，其他分段都有 //MAX_ARRAY_SIZE个元素 return numberOfSegments; &#125; MAX_ARRAY_SIZE，数组的最大尺寸依赖于操作系统分配给JVM的内存大小。假定数组的最大尺寸为100 000个int值，那么在临时文件中就是对每100 000个int值进行的排序。将它们标记为S1，S2，…，Sk，最后一段包含的数值可能会少于100 000个。 实现阶段2将每对有序分段（比如S1，S2，…，Sk）归并到一个大一些的有序分段中，并将新分段存储到新的临时文件中。继续同样的过程直到得到仅仅一个有序分段。每步归并都将两个有序分段归并成一个新分段。新段的元素数目是原来的两倍，因此，每次归并后分段的个数减少一半。如果一个分段太大，它将不能放到内存的数组中。为了实现归并步骤，要将文件f1.dat中的一半数目的分段复制到临时文件f2.dat中。然后，将f1.dat中剩下的收割分段与f2.dat中的首个分段归并到名为f3.dat的临时文件中。复制前半部分的分段复制前半部分的分段123456private static void copyHalfToF2(int numberOfSegments, int segmentSize, DataInputStream f1, DataOutputStream f2) throws Exception &#123; for (int i = 0; i &lt; (numberOfSegments / 2) * segmentSize; i++) &#123; f2.writeInt(f1.readInt()); &#125;&#125; 归并所有分段归并所有分段1234567891011private static void mergeSegments(int numberOfSegments, int segmentSize, DataInputStream f1, DataInputStream f2, DataOutputStream f3) throws Exception &#123; for (int i = 0; i &lt; numberOfSegments; i++) &#123; mergeTwoSegments(segmentSize, f1, f2, f3); &#125; while (f1.available() &gt; 0) &#123; f3.writeInt(f1.readInt()); &#125; &#125; 归并两个阶段归并两个阶段12345678910111213141516171819202122232425262728293031323334353637private static void mergeTwoSegments(int segmentSize, DataInputStream f1, DataInputStream f2, DataOutputStream f3) throws Exception &#123; int intFromF1 = f1.readInt(); int intFromF2 = f2.readInt(); int f1Count = 1; int f2Count = 1; while (true) &#123; if (intFromF1 &lt; intFromF2) &#123; f3.writeInt(intFromF1); if (f1.available() == 0 || f1Count++ &gt;= segmentSize) &#123; f3.writeInt(intFromF2); break; &#125; else &#123; intFromF1 = f1.readInt(); &#125; &#125; else &#123; f3.writeInt(intFromF2); if (f2.available() == 0 || f2Count++ &gt;= segmentSize) &#123; f3.writeInt(intFromF1); break; &#125; else &#123; intFromF2 = f2.readInt(); &#125; &#125; &#125; while (f1.available() &gt; 0 &amp;&amp; f1Count++ &lt;segmentSize) &#123; f3.writeInt(f1.readInt()); &#125; while (f2.available() &gt; 0 &amp;&amp; f2Count++ &lt; segmentSize) &#123; f3.writeInt(f2.readInt()); &#125; &#125; 结合两个阶段完整代码外部排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153package sorting;import java.io.*;public class SortLargeFile &#123; public static final int MAX_ARRAY_SIZE = 43; public static final int BUFFER_SIZE = 100000; public static void main(String[] args) throws Exception &#123; sort("largedata.dat", "sortedfile.dat"); displayFile("sortedfile.dat"); &#125; public static void sort(String sourcefile, String targetfile) throws Exception &#123; int numberOfSegments = initializeSegments(MAX_ARRAY_SIZE, sourcefile, "f1.dat"); merge(numberOfSegments, MAX_ARRAY_SIZE, "f1.dat", "f2.dat", "f3.dat", targetfile); &#125; private static int initializeSegments (int segmentSize, String originalFile, String f1) throws Exception &#123; int[] list = new int[segmentSize]; DataInputStream input = new DataInputStream( new BufferedInputStream(new FileInputStream(originalFile))); DataOutputStream output = new DataOutputStream( new BufferedOutputStream(new FileOutputStream(f1))); int numberOfSegments = 0; while (input.available() &gt; 0) &#123; numberOfSegments++; int i = 0; for ( ; input.available() &gt; 0 &amp;&amp; i &lt; segmentSize; i++) &#123; list[i] = input.readInt(); &#125; java.util.Arrays.sort(list, 0, i); for (int j = 0; j &lt; i; j++) &#123; output.writeInt(list[j]); &#125; &#125; input.close(); output.close(); return numberOfSegments; &#125; private static void merge(int numberOfSegments, int segmentSize, String f1, String f2, String f3, String targetfile) throws Exception &#123; if (numberOfSegments &gt; 1) &#123; mergeOneStep(numberOfSegments, segmentSize, f1, f2, f3); merge((numberOfSegments + 1) / 2, segmentSize * 2, f3, f1, f2, targetfile); &#125; else &#123; File sortedFile = new File(targetfile); if (sortedFile.exists()) sortedFile.delete(); new File(f1).renameTo(sortedFile); &#125; &#125; private static void mergeOneStep(int numberOfSegments, int segmentSize, String f1, String f2, String f3) throws Exception &#123; DataInputStream f1Input = new DataInputStream( new BufferedInputStream(new FileInputStream(f1), BUFFER_SIZE)); DataOutputStream f2Output = new DataOutputStream( new BufferedOutputStream(new FileOutputStream(f2), BUFFER_SIZE)); copyHalfToF2(numberOfSegments, segmentSize, f1Input, f2Output); f2Output.close(); DataInputStream f2Input = new DataInputStream( new BufferedInputStream(new FileInputStream(f2), BUFFER_SIZE)); DataOutputStream f3Output = new DataOutputStream( new BufferedOutputStream(new FileOutputStream(f3), BUFFER_SIZE)); mergeSegments(numberOfSegments / 2, segmentSize, f1Input, f2Input, f3Output); f1Input.close(); f2Input.close(); f3Output.close(); &#125; private static void copyHalfToF2(int numberOfSegments, int segmentSize, DataInputStream f1, DataOutputStream f2) throws Exception &#123; for (int i = 0; i &lt; (numberOfSegments / 2) * segmentSize; i++) &#123; f2.writeInt(f1.readInt()); &#125; &#125; private static void mergeSegments(int numberOfSegments, int segmentSize, DataInputStream f1, DataInputStream f2, DataOutputStream f3) throws Exception &#123; for (int i = 0; i &lt; numberOfSegments; i++) &#123; mergeTwoSegments(segmentSize, f1, f2, f3); &#125; while (f1.available() &gt; 0) &#123; f3.writeInt(f1.readInt()); &#125; &#125; private static void mergeTwoSegments(int segmentSize, DataInputStream f1, DataInputStream f2, DataOutputStream f3) throws Exception &#123; int intFromF1 = f1.readInt(); int intFromF2 = f2.readInt(); int f1Count = 1; int f2Count = 1; while (true) &#123; if (intFromF1 &lt; intFromF2) &#123; f3.writeInt(intFromF1); if (f1.available() == 0 || f1Count++ &gt;= segmentSize) &#123; f3.writeInt(intFromF2); break; &#125; else &#123; intFromF1 = f1.readInt(); &#125; &#125; else &#123; f3.writeInt(intFromF2); if (f2.available() == 0 || f2Count++ &gt;= segmentSize) &#123; f3.writeInt(intFromF1); break; &#125; else &#123; intFromF2 = f2.readInt(); &#125; &#125; &#125; while (f1.available() &gt; 0 &amp;&amp; f1Count++ &lt;segmentSize) &#123; f3.writeInt(f1.readInt()); &#125; while (f2.available() &gt; 0 &amp;&amp; f2Count++ &lt; segmentSize) &#123; f3.writeInt(f2.readInt()); &#125; &#125; public static void displayFile(String filename) &#123; try &#123; DataInputStream input = new DataInputStream(new FileInputStream(filename)); for (int i = 0; i &lt; 100; i++) &#123; System.out.print(input.readInt() + " "); &#125; input.close(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125;&#125; 外部排序复杂度在外部排序中，主要开销是在IO上。假设n是文件中要排序的元素个数。在阶段1，从原始文件读取元素个数n，然后将它输出给一个临时文件。因此，阶段1的IO复杂度为O(n)。 对于阶段2，在第一个合并步骤之前，排好序的分段的个数为 n/c，其中c是MAX_ARRAY_SIZE。每一个合并步骤都会使分段的个数减半。因此，在第一次合并步骤之后，分段个数为 n/2c。在第二次合并步骤之后，分段个数为 n/4c。 在第三次合并步骤之后，分段个数为 n/8c。在第log(n/c)次合并步骤之后，分段个数减到1。因此，合并步骤的总数为log(n/c)。 在每次合并步骤中，从文件f1读取一半数量的分段，然后将它们写入到一个临时文件f2。合并f1中剩余的分段和f2中的分段。每一个合并步骤中IO的次数为O(n)。因为合并步骤的总数是log(n/c)，IO的总数是 O(n) * log(n/c) = O(nlogn)。因此外部排序的复杂度是O(nlogn)]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>ExternalSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序(10) 堆排序(非泛型)]]></title>
    <url>%2Fleetcode%2F2019%2F04%2F01%2Fheapsort-easy.html</url>
    <content type="text"><![CDATA[堆排序是把数组看作堆，第i个结点的孩子结点为第 2i + 1和 2i + 2个结点（不超出数组长度前提下），堆排序的第一步是建堆，然后是取堆顶元素然后调整堆。建堆的过程是自底向上不断调整达成的，这样当调整某个结点时，其左节点和右结点已经是满足条件的，此时如果两个子结点不需要动，则整个子树不需要动，如果调整，则父结点交换到子结点位置，再以此结点继续调整。 二叉堆回顾最大（小）堆二叉堆本质上是一种完全二叉树，它分为两个类型：1.最大堆2.最小堆 完全二叉树定义：如果一棵二叉树的每一层都是满的，或者最后一层可以不填满并且最后一层的叶子都是靠左放置的，这可二叉树是完全的。 堆排序使用的是二叉堆（binary heap），二叉堆是一棵具有如下属性的二叉树：形状属性：它是一棵完全二叉树。堆属性：什么是最大堆呢？最大堆任何一个父节点的值，都 大于等于它左右孩子节点的值。什么是最小堆呢？最小堆任何一个父节点的值，都 小于等于它左右孩子节点的值。 二叉堆的根节点叫做堆顶。 最大堆和最小堆的特点，决定了在最大堆的堆顶是整个堆中的 最大元素；最小堆的堆顶是整个堆中的 最小元素。 堆的三种操作对于二叉堆，如下有几种操作： 插入节点，二叉堆的节点插入，插入位置是完全二叉树的最后一个位置。 删除节点，二叉堆的节点删除过程和插入过程正好相反，所删除的是处于堆顶的节点。 构建二叉堆，也就是把一个无序的完全二叉树调整为二叉堆。这几种操作都是基于堆的自我调整。 构建二叉堆构建二叉堆，也就是把一个无序的完全二叉树调整为二叉堆，本质上就是让所有非叶子节点依次下沉。 堆的代码实现二叉堆虽然是一颗完全二叉树，但它的存储方式并不是链式存储，而是顺序存储。换句话说，二叉堆的所有节点都存储在数组当中。数组中，在没有左右指针的情况下，如何定位到一个父节点的左孩子和右孩子呢？ 可以依靠数组下标来计算。假设父节点的下标是parent，那么它的左孩子下标就是 2parent+1；它的右孩子下标就是 2parent+2 。 堆的上浮和下浮调整操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class HeapOperator &#123; // 上浮调整 arr为待调整的堆 public static void upAdjust(int[] arr) &#123; int childIndex = arr.length - 1; int parentIndex = (childIndex - 1) / 2; // 用tmp保存插入的叶子节点值，用于最后的赋值 int tmp = arr[childIndex]; while (childIndex &gt; 0 &amp;&amp; tmp &lt; arr[parentIndex]) &#123; // 无须真正交换，单向赋值即可 arr[childIndex] = arr[parentIndex]; childIndex = parentIndex; parentIndex = (parentIndex - 1) / 2; &#125; arr[childIndex] = tmp; &#125; // 下沉调整，arr为待调整的堆，parentIndex为要下沉的父节点，length为堆的有效大小 public static void downAdjust(int[] arr, int parentIndex, int length) &#123; int tmp = arr[parentIndex]; int childIndex = 2 * parentIndex + 1; while (childIndex &lt; length) &#123; // 如果有右孩子，且右孩子小于左孩子的值，则定位到右孩子 // arr[childIndex + 1] &gt; arr[childIndex] if (childIndex + 1 &lt; length &amp;&amp; arr[childIndex + 1] &lt; arr[childIndex]) &#123; childIndex++; &#125; // 如果父节点小于任何一个孩子的值，直接跳出 // if (tmp &gt; arr[childIndex]) if (tmp &lt;= arr[childIndex]) break; // 无需真正交换，单向赋值即可 arr[parentIndex] = arr[childIndex]; parentIndex = childIndex; childIndex = 2 * childIndex + 1; &#125; arr[parentIndex] = tmp; &#125; //构建堆 arr为待调整的堆 public static void buildHeap(int[] arr) &#123; // 从最后一个叶子节点开始，依次下沉调整 for (int i = arr.length / 2; i &gt;= 0; i--) &#123; downAdjust(arr, i, arr.length - 1); &#125; &#125; public static void main(String[] args) &#123; int[] arr = &#123; 1, 3, 2, 6, 5, 7, 8, 9, 10, 0 &#125;; upAdjust(arr); System.out.println(Arrays.toString(array)); array = new int[] &#123; 7, 1, 3, 10, 5, 2, 8, 9, 6 &#125;; buildHeap(array); System.out.println(Arrays.toString(array)); &#125;&#125; 代码中有一个优化的点，就是父节点和孩子节点做连续交换时，并不一定要真的交换，只需要先把交换一方的值存入temp变量，做单向覆盖，循环结束后，再把temp的值存入交换后的最终位置。 堆排序我们每一次删除旧堆顶，调整后的新堆顶都是大小仅次于旧堆顶的节点。那么我们只要反复删除堆顶，反复调节二叉堆，所得到的集合就成为了一个有序集合。 二叉堆和最大堆的特性： 二叉堆本质上是一种完全二叉树 最大堆的堆顶是整个堆中的最大元素 当我们删除一个最大堆的堆顶（并不是完全删除，而是替换到最后面），经过自我调节，第二大的元素就会被交换上来，成为最大堆的新堆顶。 由此，我们可以归纳出堆排序算法的步骤： 把无序数组构建成二叉堆。 循环删除堆顶元素，移到集合尾部，调节堆产生新的堆顶。 堆排序代码实现堆排序实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class HeapSort&#123; public static downAdjust(int[] arr, int parentIndex, int length) &#123; int tmp = arr[parentIndex]; int childIndex = 2 * parentIndex + 1; while (childIndex &lt; length) &#123; // 如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子 if (childIndex + 1 &lt; length &amp;&amp; arr[childIndex + 1] &gt; arr[childIndex]) &#123; childIndex++; &#125; //如果父节点小于任何一个孩子的值，直接跳出 if (tmp &gt;= arr[childIndex]) break; //无需真正交换，单向赋值即可 arr[parentIndex] = arr[childIndex]; parentIndex = childIndex; childIndex = 2 * childIndex + 1; &#125; arr[parentIndex] = tmp; &#125; //堆排序 arr为待调整的堆 public static void heapSort(int[] arr) &#123; // 1. 把无需数组构建成二叉堆 for (int i = (arr.length - 2) / 2; i &gt;= 0; i--) &#123; downAdjust(arr, i, arr.length); &#125; System.out.println(Arrays.toString(arr)); // 2.循环删除栈顶元素，移到集合尾部，调整堆产生新的栈顶 for (int i = arr.length - 1; i &gt; 0; i--) &#123; //最后一个元素和第一个元素进行交换 int tmp = arr[i]; arr[i] = arr[0]; arr[0] = tmp; // 下沉调整最大堆 downAdjust(arr, 0, i); &#125; &#125; public static void main(String[] args) &#123; int[] arr = &#123; 1, 3, 2, 6, 5, 7, 8, 9, 10, 0 &#125;; heapSort(arr); System.out.println(Arrays.toString(arr)); &#125;&#125; 堆排序的时间空间复杂度算法复杂度：时间复杂度（平均）： O(nlogn)时间复杂度（最坏）： O(nlogn)时间复杂度（最好）： O(nlogn) 空间复杂度： O(1)堆排序是不稳定的排序算法。 堆排序的空间复杂度毫无疑问是O(1)，因为没有开辟额外的集合空间。 对于时间复杂度：二叉堆的节点下沉调整（downAdjust 方法）是堆排序算法的基础，这个调节操作本身的时间复杂度是多少呢？假设二叉堆总共有n个元素，那么下沉调整的最坏时间复杂度就等同于二叉堆的高度，也就是O（logn）。 我们再来回顾一下堆排序算法的步骤： 把无序数组构建成二叉堆。 循环删除堆顶元素，移到集合尾部，调节堆产生新的堆顶。 第一步，把无序数组构建成二叉堆，需要进行n/2次循环。每次循环调用一次 downAdjust 方法，所以第一步的计算规模是 n/2 * logn，时间复杂度 O（nlogn）。 第二步，需要进行n-1次循环。每次循环调用一次 downAdjust 方法，所以第二步的计算规模是 （n-1） * logn ，时间复杂度 O（nlogn）。 两个步骤是并列关系，所以整体的时间复杂度同样是 O（nlogn）。]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>HeapSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序(9) 桶排序]]></title>
    <url>%2Fleetcode%2F2019%2F04%2F01%2Fbucket-sort.html</url>
    <content type="text"><![CDATA[假设有一组长度为N的待排关键字序列K[1….n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标i)，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。 然后依次枚举输出B[0]….B[M]中的全部内容即是一个有序序列。 桶排序思想一个长度为20的doule类型数组，取值范围从0到10，要求用最快的速度把这20个double类型元素从小到大进行排序。当数列取值范围过大，或者不是整数时，不能适用计数排序。到那时可以使用桶排序来解决问题。 桶排序同样是一种线性时间的排序算法，类似于计数排序所创建的统计数组，桶排序需要创若干个 桶来协助排序。 计数排序：计数排序需要根据原始数列的取值范围，创建一个统计数组，用来统计原始数列中每一个可能的整数值所出现的次数。原始数列中的整数值，和统计数组的下标是一一对应的，以数列的最小值作为偏移量，比如原始数列的最小值是90，那么整数对应的统计数组下标就是95-90=5。 桶排序当中的桶的概念：每一个桶(bucket)代表一个区间范围，里面可以承载一个或多个元素。 桶排序的第一步，就是创建这些桶，确定每一个桶的区间范围。 4.5 0.84 3.25 2.18 0.5[0.5, 1.5) [1.5, 2.5) [2.5, 3.5) [3.5, 4.5) [4.5, 4.5] 具体建立多少个桶，如何确定桶的区间范围，有很多不同的方式。这里创建的桶数量等于原始数列的元素数量，除了最后一个桶只包含数列最大值，前面各个桶的区间按照比例确定。区间跨度 = （最大值-最小值）/ （桶的数量 - 1） 第二步，遍历原始数列，把元素对号入座放入各个桶中： 0.84 0.5 2.18 3.25 4.5[0.5, 1.5) [1.5, 2.5) [2.5, 3.5) [3.5, 4.5) [4.5, 4.5] 第三步，每个桶内部的元素分别排序（显然，只有第一个桶需要排序）： 第四步，遍历所有的桶，输出所有元素：0.5， 0.84， 2.18， 3.25， 4.5 到此为止，排序结束。 桶排序代码实现桶排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class BucketSort &#123; public static double[] bucketSort(double[] arr) &#123; // 1. 得到数列的最大值和最小值，并计算出差值d double max = arr[0]; double min = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; if (arr[i] &lt; min) &#123; min = arr[i]; &#125; &#125; double d = max - min; // 2. 初始化桶 int bucketNum = arr.length; ArrayList&lt;LinkedList&lt;Double&gt;&gt; bucketList = new ArrayList&lt;&gt;(bucketNum); for (int i = 0; i &lt; bucketNum; i++) &#123; bucketList.add(new LinkedList&lt;Double&gt;()); &#125; // 3. 遍历原始数组，将每个元素放入桶中 for (int i = 0; i &lt; arr.length; i++) &#123; int num = (int) ((arr[i] - min) * (bucketNum - 1) / d); bucketList.get(num).add(arr[i]); &#125; // 4. 对每个桶内部进行排序 for (int i = 0; i &lt; bucketList.size(); i++) &#123; // JDK低层采用了归并排序或归并的优化版本 Collections.sort(bucketList.get(i)); &#125; // 5. 输出全部元素 double[] sortedArray = new double[arr.length]; int index = 0; for (LinkedList&lt;Double&gt; list : bucketList) &#123; for (double element : list) &#123; sortedArray[index] = element; index++; &#125; &#125; return sortedArray; &#125; public static void main(String[] args) &#123; double[] arr = &#123; 4.12, 6.421, 0.0023, 3.0, 2.123, 8.122, 4.12, 10.09 &#125;; double[] sortedArr = bucketSort(arr); System.out.println(Arrays.toString(sortedArr)); &#125;&#125; 代码中，所有的桶保存在ArrayList集合当中，每一个桶被定义成一个链表（LinkedList），这样便于在尾部插入元素。 定位元素属于第几个桶，是按照比例来定位：(array[i] - min) * (bucketNum-1) / d 同时，代码使用了JDK的集合工具类Collections.sort来为桶内部的元素进行排序。Collections.sort底层采用的是归并排序或Timsort，小伙伴们可以简单地把它们当做是一种时间复杂度 O（nlogn）的排序。 基数排序基数排序 基数排序也可以看作一种桶排序，不断的使用不同的标准对数据划分到桶中，最终实现有序。基数排序的思想是对数据选择多种基数，对每一种基数依次使用桶排序。 基数排序的步骤：以整数为例，将整数按十进制位划分，从低位到高位执行以下过程。 从个位开始，根据0~9的值将数据分到10个桶桶，例如12会划分到2号桶中。 将0~9的10个桶中的数据顺序放回到数组中。 重复上述过程，一直到最高位。 上述方法称为LSD（Least significant digital），还可以从高位到低位，称为MSD。 复杂度及稳定性算法复杂度：时间复杂度（平均）： O(n+m+n(logn-logm))时间复杂度（最坏）： O(nlogn)时间复杂度（最好）： O(n) 空间复杂度： O(m+n)桶排序也是稳定的排序算法。 假设原始数列有n个元素，分成m个桶（我们采用分桶方式m=n），平均每个桶的元素个数为 n/m 下面逐步分析算法复杂度 第一步，求数列最大最小值，运算量为n。第二步，创建空桶，运算量为m。第三步，遍历原始数列，运算量为n。第四步在每个桶内部做排序，由于使用了O(nlogn)的排序算法，所以运算量为 n/m · log(n/m ) · m。第五步，输出排序数列，运算量为n。 加起来，总的运算量为3n+m+ n/m · log(n/m ) · m = 3n+m+n(logn-logm)去掉系数，时间复杂度为：O(n+m+n(logn-logm))至于空间复杂度就很明显了：空桶占用的空间 + 数列在桶中占用的空间 = O(m+n) 桶排序在性能上并非绝对稳定。理想情况下，桶中的元素均匀分布，当n=m时，时间复杂度可以达到O(n)；但是，如果桶内元素的分布极不均匀，极端情况下第一个桶中有n-1个元素，，最后一个桶中有1个元素。此时的时间复杂度将退化成为O(nlogn)，还白白创建了许多空桶。]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>BucketSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序(8) 计数排序]]></title>
    <url>%2Fleetcode%2F2019%2F04%2F01%2Fcount-sort.html</url>
    <content type="text"><![CDATA[无论是冒泡排序，还是快速排序等等，都是基于元素之间的比较来进行排序。有一种特殊的算法叫做 计数排序，这种排序算法不是基于元素比较，而是利用数组下标来确定元素的正确位置。 计数排序思想如果通过比较进行排序，那么复杂度的下界是O(nlogn)，但是如果数据本身有可以利用的特征，可以不通过比较进行排序，就能使时间复杂度降低到O(n)。 计数排序要求待排序的数组元素都是整数，有很多地方都要求是 0-K 的正整数，其实负整数也可以通过都加一个偏移量解决的。 计数排序的思想是，考虑待排序数组中的某一个元素a，如果数组中比a小的元素有s个，那么a在最终排好序的数组中的位置将会是s+1，如何知道比a小的元素有多少个，肯定不是通过比较去觉得，而是通过数字本身的属性，即累加数组中最小值到a之间的每个数字出现的次数（未出现则为0），而每个数字出现的次数可以通过扫描一遍数组获得。 计数排序的步骤： 1.找出待排序的数组中最大和最小的元素（计数数组C的长度为max-min+1，其中位置0存放min，依次填充到最后一个位置存放max）2.统计数组中每个值为i的元素出现的次数，存入数组C的第i项3.对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）4.反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1（反向填充是为了保证稳定性） 计数排序适合数据分布集中的排序，如果数据太分散，会造成空间的大量浪费，假设数据为（1,2,3,1000000），这就需要1000000的额外空间，并且有大量的空间浪费和时间浪费。 示例数组里有20个随机数，取值范围从0到10,要求用最快的速度把这20个整数从小到大进行排序。 随机整数的取值范围从0到10，这些整数取值范围为0-10这11个数字。根据这个整数取值范围，建立一个长度为11的数组。数组下标从0到10，元素初始值全为0。 假定20个随机整数的值如下：9，3，5，4，9，1，2，7，8，1，3，6，5，3，4，0，10，9 ，7，9 如何给这些无序的随机整数排序呢？非常简单，让我们遍历这个无序的随机数列，每一个整数按照其值对号入座，对应数组下标的元素进行加1操作。最终，数列遍历完毕时，数组的状态如下： 0 1 2 3 4 5 6 7 8 9 10 1 2 1 3 2 2 1 2 1 4 1 数组每一个下标位置的值，代表了数列中对应整数出现的次数。有了这个“统计结果”，排序就很简单了。直接遍历数组，输出数组元素的下标值，元素的值是几，就输出几次：0，1，1，2，3，3，3，4，4，5，5，6，7，7，8，9，9，9，9，10显然，这个输出的数列已经是有序的了。 这就是计数排序的基本过程，它适用于一定范围的整数排序。在取值范围不是很大的情况下，它的性能甚至超过那些O(nlogn)的排序。 计数排序（初步实现）下面代码在一开头补充了一个步骤，就是求得数列的最大整数值max。后面创建的统计数组countArray，长度就是max + 1，以此保证数组的最后一个下标是max。代码如下：计数排序初步实现1234567891011121314151617181920212223242526272829303132public class CountSort &#123; public static int[] countSort(int[] arr) &#123; // 1. 得到数列的最大值 int max = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt; arr[0]) &#123; max = arr[i]; &#125; &#125; // 2.根据数列最大值确定统计数组的长度 int[] countArray = new int[max + 1]; // 3. 遍历数列，填充统计数组 for (int i = 0; i &lt; arr.length; i++) &#123; countArray[arr[i]]++; &#125; // 4. 遍历统计数组，输出结果 int index = 0; int[] sortedArray = new int[arr.length]; for (int i = 0; i &lt; countArray.length; i++) &#123; for (int j = 0; j &lt; countArray[i]; j++) &#123; sortedArray[index++] = i; &#125; &#125; return sortedArray; &#125; public static void main(String[] args) &#123; int[] array = &#123; 4, 4, 6, 5, 3, 2, 8, 1, 7, 5, 6, 0, 10 &#125;; int[] sortedArray = countSort(array); System.out.println(Arrays.toString(sortedArray)); &#125;&#125; 改进点分析初始值和偏移量上面的初步实现，从功能角度，可以实现整数的排序，但是存在一些问题，只以数列的最大值来决定统计数组的长度，其实并不严谨。比如下面的数列：95，94，91，98，99，90，99，93，91，92 这个数列的最大值是99，但最小值的整数是90.如果创建长度为100的数组，前面从0到89的空间位置都浪费了。 解决这个问题，很简单，不再以（输入数列的最大值 + 1）作为统计数组的长度，而是以（数列最大值和最小值的差 + 1）作为统计数组的长度。同时，数列的最小值作为一个偏移量，用于统计数组的对号入座。 以刚才的数列为例，统计数组的长度为 99-90+1 = 10 偏移量等于数列的最小值90.对于第一个整数95，对应的统计数组下标是 95-90=5 反向填充另外一方面，朴素版的计数排序只是简单地按照统计数组的下标输出了元素值，并没有真正给原始数列进行排序。如果只是单纯的给整数排序，这样没有问题，但是如果放在业务代码里，比如给学生的考试分数排序，遇到相同的分数就会分不清谁是谁。 姓名 成绩 小灰 90 大黄 99 小红 95 小白 94 小绿 95 给定一个学生的成绩表，要求按成绩从低到高排序，如果成绩相同，则 遵循原表固有顺序。那么，当我们填充统计数组以后，我们只知道有两个成绩并列95分的小伙伴，却不知道哪一个是小红，哪一个是小绿： 0 1 2 3 4 5 6 7 8 9 1 0 0 0 1 2 0 0 0 1 变型后： 0 1 2 3 4 5 6 7 8 9 1 1 1 1 2 4 4 4 4 5 这是如何变形的呢？统计数组从第二个元素开始，每一个元素都加上前面所有元素之和。为什么要相加呢？ 这样相加的目的，是让统计数组存储的元素值，等于相应整数的最终排序位置。比如下标是9的元素值为5，代表原始数列的整数9，最终的排序是在第5位。 接下来，我们创建输出数组sortedArray，长度和输入数列一致。然后从后向前遍历输入数列：第一步，我们遍历成绩表最后一行的小绿：小绿是95分，我们找到countArray下标是5的元素，值是4，代表小绿的成绩排名位置在第4位。同时，我们给countArray下标是5的元素值减1，从4变成3,，代表着下次再遇到95分的成绩时，最终排名是第3。 第二步，我们遍历成绩表倒数第二行的小白：小白是94分，我们找到countArray下标是4的元素，值是2，代表小白的成绩排名位置在第2位。同时，我们给countArray下标是4的元素值减1，从2变成1,，代表着下次再遇到94分的成绩时（实际上已经遇不到了），最终排名是第1。 第三步，我们遍历成绩表倒数第三行的小红：小红是95分，我们找到countArray下标是5的元素，值是3（最初是4，减1变成了3），代表小红的成绩排名位置在第3位。同时，我们给countArray下标是5的元素值减1，从3变成2,，代表着下次再遇到95分的成绩时（实际上已经遇不到了），最终排名是第2。 这样一来，同样是95分的小红和小绿就能够清楚地排出顺序了，也正因此，优化版本的计数排序属于稳定排序。 计数排序代码实现（优化后）其中关键的地方有两个：第一，在于理解计算max和min之后，需要使用原数组每一个元素减去min的转换值统计词频，特定情况下能节省存储空间，这样做的另一个好处是可以兼容负数的情况，因为每一个元素减去最小值之后，结果必定是大于等于0； 第二，在于理解为什么采用词频求和的方式 + 倒序遍历原始数组的方式，能保证排序算法的稳定性。 这里必须从后向前遍历，只有这样出现重复的元素，才会保持顺序的把最后面的重复元素，永远放在最右边。从而保证排序的稳定性，如果从前向后排序，重复元素的顺序，刚好相反，所以就不是稳定的算法。 计数排序代码实现（优化后）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class CountSort &#123; public static int[] countSort(int[] arr) &#123; // 1. 得到数列的最大值和最小值，并计算出差值d int max = arr[0]; int min = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; if (arr[i] &lt; min) &#123; min = arr[i]; &#125; &#125; int d = max - min; // 2. 创建统计数组并统计对应元素个数 int[] countArray = new int[d + 1]; for (int i = 0; i &lt; arr.length; i++) &#123; countArray[arr[i] - min]++; &#125; // 3. 统计数组做变型，后面的元素等于前面的元素之和 int sum = 0; for (int i = 0; i &lt; countArray.length; i++) &#123; sum += countArray[i]; countArray[i] = sum; &#125; // 4. 倒序遍历原始数组，从统计数组找到正确位置，输出到结果数组 int[] sortedArray = new int[arr.length]; for (int i = arr.length - 1; i &gt;= 0; i--) &#123; /*sortedArray[countArray[arr[i] - min] - 1] = arr[i]; * countArray[arr[i] - min]--; */ // arr[i]-min找到这个数在countArray中的位置 int sumCount = countArray[arr[i] - min]; //得到实际排序后的位置 int sortedPos = sumCount - 1; // 向最终结果里存放元素 sortedArray[sortedPos] = arr[i]; // 针对重复的元素，先放后面，然后减1，下次循环就会放在前面 countArray[arr[i] - min]--; &#125; return sortedArray; &#125; public static void main(String[] args) &#123; int[] arr = &#123; 95, 94, 91, 98, 99, 90, 99, 93, 91, 92 &#125;; int[] sortedArray = countSort(arr); System.out.println(Arrays.toString(sortedArray)); &#125;&#125; 复杂度分析及稳定性算法复杂度：时间复杂度（平均）： O(n+m)时间复杂度（最坏）： O(n+m)时间复杂度（最好）： O(n+m) 空间复杂度： O(m)计数排序是稳定的排序算法。 如果原始数列的规模是N，最大最小整数的差值是M，计数排序的时间复杂度和空间复杂度。代码第1, 2, 4步都涉及到遍历原数列，运算量都是N，第3步遍历统计数列，运算量是M，所以总体运算量是3N + M，去掉系数，时间复杂度是O(n+m)。 至于空间复杂度，如果不考虑结果数组，只考虑统计数组 countArray 大小的话，空间复杂度是O(m)。 计数排序存在它的局限性： 当数列最大值最小值差距过大时，并不使用计数排序。比如给定20个随机整数，范围在0到1亿之间，这时候如果使用计数排序，需要创建长度1亿的数组。不但严重浪费空间，而且时间复杂度也随之升高。 当数列元素不是整数，并不适用计数排序。如果数列中的元素都是小数，比如25.213，或是0.00000001这样子，则无法创建对应的统计数组。这样显然无法进行计数排序。 基于这些局限性，另一种线性时间排序算法对此做出了弥补，这种排序算法叫做 桶排序。]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>CountSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序(7) 快速排序]]></title>
    <url>%2Fleetcode%2F2019%2F04%2F01%2Fquick-sort.html</url>
    <content type="text"><![CDATA[快速排序的基本思想：通过一趟排序将待排数列分隔成独立的两部分，其中一部分数列的关键字均比另一部分的关键字小，则可分别对这两部分数列继续进行排序，以达到整个序列有序。 其中，最重要的partition主要有两种方法： 1)指针交换法。先把选定为pivot的元素放到最后，然后设定指针low和指针high，low指针右移，high指针左移，当两个指针相撞后停止移动。期间如果符合交换条件，两元素交换。最后把pivot元素放到中间。 2)挖坑法。类似冒泡排序的思路，把比pivot大的元素“往下沉”，把比pivot小的元素“往上浮”。 快速排序思想快速排序是从冒泡排序演变而来的算法，但是使用了 分治法，比冒泡排序要高效得多，所以叫快速排序。 同冒泡排序一样，快速排序也属于交换排序，通过元素之间的比较和交换位置来达到排序的目的。 不同的是，冒泡排序在每一轮只把一个元素冒泡到数列的一端，而快速排序 在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成了两个部分。这种思路就叫做分治法。 在分治法的思想下，原数列在每一轮被拆成两部分，每一部分在下一轮又分别被拆成两部分，直到不可再分为止。 基准元素的选择：最简单的方式是选择数列的第一个元素。但是假如有一个原本逆序的数列，期望排序成顺序数列，这样数列每一轮仅仅确定了基准元素的位置。 第一个元素要么是最小值，要么是最大值，根本无法发挥分治法的优势。 在这种极端情况下，快速排序需要进行n轮，时间复杂度退化成了O(n^2)。 如何避免上述情况的发生，最简单的方法，不选择数列的第一个元素，而是随机选择一个元素作为基准元素。 这样一来，即使在数列完全逆序的情况下，也可以有效地将数列分成两部分。当然，即使是随机选择基准元素，每一次也有极小的几率选到数列的最大值或最小值，同样会影响到分治的效果。 快速排序是目前被认为最好的一种内部排序方法。快速排序算法处理的最好情况指每次都是将待排序数列划分为均匀的两部分，通常认为快速排序的平均时间复杂度是O(nlogn)。 但是，快速排序的最差情况就是基本逆序或者基本有序的情况，那么此时快速排序将蜕化成冒泡排序，其时间复杂度为O(n^2) 元素的移动选定了基准元素，要做的就是把其他元素当中小于基准元素的都移动到基准元素一边，大于基准元素的都移动到基准元素另一边。有两种方法： 挖坑法 指针交换法 快排（挖坑法）快速排序挖坑法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class QuickSort &#123; public static void quickSort(int[] arr, int startIndex, int endIndex) &#123; //递归结束条件 if (startIndex &gt;= endIndex) &#123; return; &#125; // 得到基准元素位置 int pivotIndex = partition(arr, startIndex, endIndex); // 用分治法递归数列两部分 quickSort(arr, startIndex, pivotIndex - 1); quickSort(arr, startIndex + 1, endIndex); &#125; private static int partition(int[] arr, int startIndex, int endIndex) &#123; // 取第一个位置的元素作为基准元素 int pivot = arr[startIndex]; int left = startIndex; int right = endIndex; // 坑的位置，初始等于pivot的位置 int index = startIndex; // 大循环左右指针重合或者指针交换时结束 while (right &gt;= left) &#123; // right指针从右向左进行比较 while (right &gt;= left) &#123; if (arr[right] &lt; pivot) &#123; arr[left] = arr[right]; index = right; left++; break; &#125; right--; &#125; //left指针从左向右进行比较 while (right &gt;= left) &#123; if (arr[left] &gt; pivot) &#123; arr[right] = arr[left]; index = left; right--; break; &#125; left++; &#125; &#125; arr[index] = pivot; return index; &#125; public static void main(String[] args) &#123; int[] arr = &#123; 4, 7, 6, 5, 3, 2, 8, 1 &#125;; quickSort(arr, 0, arr.length - 1); System.out.println(Arrays.toString(arr)); &#125;&#125; 指针交换法代码实现和挖坑法相比，指针交换法在partition方法中进行的元素交换次数更少。 对于数列 {4, 7, 6, 5, 3, 2, 8, 1 } 由于left一开始指向的是基准元素，判断肯定相等，所以left右移一位。 进入第四次循环，right移动到元素3停止，这时候请注意，left和right指针已经重合在了一起。 当left和right指针重合之时，我们让pivot元素和left与right重合点的元素进行交换。此时数列左边的元素都小于4，数列右边的元素都大于4，这一轮交换终告结束。 快速排序指针交换法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class QuickSort &#123; public static quickSort(int[] arr, int startIndex, int endIndex) &#123; if (startIndex &gt;= endIndex) &#123; return; &#125; // 得到基准信息 int pivotIndex = partition(arr, startIndex, endIndex); //根据基准元素，分成两部分进行递归 quickSort(arr, startIndex, pivotIndex - 1); quickSort(arr, pivotIndex + 1, endIndex); &#125; private static int partition(int[] arr, int startIndex, int endIndex) &#123; // 取第一个元素作为基准元素 int pivot = arr[startIndex]; int left = startIndex; int right = endIndex; while (left != right) &#123; // 控制right指针比较并左移 while (left &lt; right &amp;&amp; arr[right] &gt; pivot) &#123; right--; &#125; // 控制left指针比较并左移 while (left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123; left++; &#125; // 交换left和right指向的元素 if (left &lt; right) &#123; int tmp = arr[left]; arr[left] = arr[right]; arr[right] = tmp; &#125; &#125; // pivot和指针重合交换 int tmp = arr[left]; arr[left] = arr[startIndex]; arr[startIndex] = tmp; return left; &#125; public static void main(String[] args) &#123; int[] arr = &#123; 4, 7, 6, 5, 3, 2, 8, 1 &#125;; quickSort(arr, 0, arr.length - 1); System.out.println(Arrays.toString(arr)); &#125;&#125; partition函数的单边循环法无论是挖坑法还是指针交换法，都是一层循环内嵌一层循环，从数组的两边交替遍历元素，代码不够简洁。单边循环法只从数组的一边对元素进行遍历和交换。 单边循环法1234567891011121314151617181920212223242526public static void quickSort(int[] arr, int startIndex, int endIndex) &#123; if (startIndex &gt;= endIndex) &#123; return; &#125; int pivotIndex = partition(arr, startIndex, endIndex); quickSort(arr, startIndex, pivotIndex - 1); quickSort(arr, pivotIndex + 1, endIndex);&#125;private static int partition(int[] arr, int startIndex, int endIndex) &#123; int pivot = arr[startIndex]; int mark = startIndex; for (int i = startIndex + 1; i &lt;= endIndex; i++) &#123; if (arr[i] &lt; pivot) &#123; mark++; int tmp = arr[mark]; arr[mark] = arr[i]; arr[i] = tmp; &#125; &#125; arr[startIndex] = arr[mark]; arr[mark] = pivot; return mark;&#125; 非递归实现上面的代码都是依靠递归来实现的，绝大多数用递归来实现的问题，都可以用栈的方式来代替。因为我们代码中一层一层的方法调用，本身就是一个函数栈。每次进入一个新方法，就相当于入栈；每次有方法返回，就相当于出栈。所以，我们可以把原本的递归实现转化成一个栈的实现，在栈当中存储每一次方法调用的参数： 使用非递归实现快速排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class QuickSort &#123; public static void quickSort(int[] arr, int startIndex, int endIndex) &#123; // 用一个集合栈来代替递归的函数栈 Stack&lt;Map&lt;String, Integer&gt;&gt; quickSortStack = new Stack&lt;&gt;(); // 整个数列的起止下标，以哈希的形式入栈 Map&lt;String, Integer&gt; rootParam = new HashMap&lt;&gt;(); rootParam.put("startIndex", startIndex); rootParam.put("endIndex", endIndex); quickSortStack.push(rootParam); // 循环结束条件，栈为空时结束 while (!quickSortStack.isEmpty()) &#123; // 栈顶元素出栈，得到起止下标 Map&lt;String, Integer&gt; param = quickSortStack.pop(); // 得到基准元素位置 int pivotIndex = partition(arr, param.get("startIndex"), param.get("endIndex")); // 根据基准元素分成两部分，把每一部分的起止下标入栈 if (param.get("startIndex") &lt; pivotIndex - 1) &#123; Map&lt;String, Integer&gt; leftParam = new HashMap&lt;&gt;(); leftParam.put("startIndex", param.get("startIndex")); leftParam.put("endIndex", pivotIndex - 1); quickSortStack.push(leftParam); &#125; if (param.get("endIndex") &gt; pivotIndex + 1) &#123; Map&lt;String, Integer&gt; rightParam = new HashMap&lt;&gt;(); rightParam.put("startIndex", pivotIndex + 1); rightParam.put("endIndex", param.get("endIndex")); quickSortStack.push(rightParam); &#125; &#125; &#125; private static int partition(int[] arr, int startIndex, int endIndex) &#123; // 取第一个元素作为基准元素 int pivot = arr[startIndex]; int left = startIndex; int right = endIndex; while (left != right) &#123; // 控制right指针比较并左移 while (left &lt; right &amp;&amp; arr[right] &gt; pivot) &#123; right--; &#125; // 控制left指针比较并右移 while (left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123; left++; &#125; // 交换left和right指向的元素 if (left &lt; right) &#123; int tmp = arr[left]; arr[left] = arr[right]; arr[right] = tmp; &#125; &#125; // pivot和指针重合点交换 int tmp = arr[left]; arr[left] = arr[startIndex]; arr[startIndex] = tmp; return left; &#125; public static void main(String[] args) &#123; int[] arr = new int[] &#123; 4, 7, 6, 5, 3, 2, 8, 1 &#125;; quickSort(arr, 0, arr.length - 1); System.out.print(Arrays.toString(arr)); &#125;&#125; 和刚才的递归实现相比，代码的变动仅仅在quickSort方法当中。该方法中引入了一个存储Map类型元素的栈，用于存储每一次交换时的起始下标和结束下标。 每一次循环，都会让栈顶元素出栈，进行排序，并且按照基准元素的位置分成左右两部分，左右两部分再分别入栈。当栈为空时，说明排序已经完毕，退出循环。 改进主元选择的快排在线性表中的第一个元素、中间元素和最后一个元素中选择一个 中位数作主元。 中位数选择的函数，如（1, 3, 5）选择31234public static int median(int first, int middle, int last) &#123; return Math.max(Math.min(first, middle), Math.min(Math.max(first, middle), last)); &#125; 复杂度及稳定性算法复杂度：时间复杂度（平均）： O(nlogn)时间复杂度（最坏）： O(n^2)时间复杂度（最好）： O(nlogn) 空间复杂度： O(nlogn)快速排序是不稳定的排序算法。 快速排序有两个方向，左边的left指针一直往右走，当arr[left] &lt;= pivot。而右边的right指针一直往左走，当arr[right] &gt; pivot。如果left和right都走不动了，left &lt;= right，交换arr[left]和arr[right]，重复上面的过程，直到left &gt; right。 交换arr[left]和arr[startIndex]，完成一趟快速排序。在中枢元素和a[left]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为5 3 3 4 3 8 9 10 11，现在中枢元素5和3（第5个元素，下标从1开始计）交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和arr[left] 交换的时刻。 快排和归并归并排序和快速排序都使用了分而治之法。对于归并排序，大量的工作是将两个子线性表进行归并，归并是在两个子线性表都 排好序后进行的。对于快速排序，大量的工作是将线性表划分成两个子线性表，划分是在子线性表 排好序前进行的。最差的情况下，归并排序的效率高于快速排序，但是，在平均情况下，两者效率相同。归并排序在归并两个数组是需要一个临时数组，而快速排序不需要额外的数组空间。因此，快速排序的空间效率高于归并排序。 快排和堆排序相同点：堆排序和快速排序的平均时间复杂度都是O(nlogn)，并且都是 不稳定排序。 不同点：快速排序的最坏时间复杂度是O(n^2)，而堆排序最坏时间复杂度稳定在O(nlogn)。此外，快速排序的递归和非递归的空间复杂度都是O(n)，而堆排序的空间复杂度是O(1)。]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>QuickSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序(6) 归并排序]]></title>
    <url>%2Fleetcode%2F2019%2F04%2F01%2Fmerge-sort.html</url>
    <content type="text"><![CDATA[归并排序是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度，代价是需要额外的内存空间。 归并排序算法将数组每一次都分解为原来的一半大小的两个子数组，当分解到了右边界比左边界还大的时候，不再分解，开始排序。 然后将排序好的子数组逐级合并，最后得到的结果就是排序好的数组。 归并排序思想归并排序是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 在这里我们只不过是利用了递归的思想，将数组每一次都分解为原来的一半大小的两个子数组，当分解到了右边界比左边界还大的时候，不再分解，开始排序。然后将排序好的子数组逐级合并，最后得到的结果就是排序好的数组。 首先考虑下如何将两个有序数列合并。这个非常简单，只要从比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。这需要将待排序序列中的所有记录扫描一遍，因此耗费O(n)时间，而由完全二叉树的深度可知，整个归并排序需要进行 logn次，因此，总的时间复杂度为O(nlogn)。 归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果，因此空间复杂度为O(n)。 归并算法需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法。 递归所谓递归，指的是程序直接或间接调用本身的一种方法，它通常把一个大型的、复杂的问题不直接解决，而是转化成为一个与原问题相似的、规模较小的问题来解决。简单来说， 递归就是把问题层层分解，直到程序出口处。任何递归都必须有递归调用的结束条件，否则，程序将会陷入无限递归而无法结束，而这个结束条件满足时，一定不会调用本身，否则递归调用将无法结束。 算法描述归并排序的算法伪代码：归并排序的算法伪代码12345678public static void mergeSort(int[] arr) &#123; if (arr.length &gt; 1) &#123; mergeSort(arr[0 ... arr.length/2]); mergeSort(arr[arr.length/2 + 1 ... arr.length]); merge arr[0 ... arr.length / 2] with arr[arr.length/2 + 1 ... arr.length]; &#125;&#125; 对数列 {2, 9, 5, 4, 8, 1, 6, 7} 进行归并排序。先进行 拆分数列，直到数列只有一个元素为止，然后，再将其 归并为一个新的有序数列。递归调用持续将数组划分为子数组，直到每个子数组只包含一个元素。然后，该算法将这些小的子数组归并为稍大的有序子数组，直到最后形成一个有序的数组。 归并排序（法一）归并排序利用的是分治的思想，对于给定的一组数据，利用递归与分治技术将数据序列划分成为越来越小的子序列，之后对子序列排序，后再用递归方法将排好序的子序列合并成为有序序列。 合并两个子序列时，需要申请两个子序列加起来长度的内存，临时存储新的生成序列，再将新生成的序列赋值到原数组相应的位置。MergeSort方法在分解过程中创建两个临时数组，将数组前半部分和后半部分复制到临时数组中，对临时数组排序，然后将它们归并到原始数组中，这样产生很多额外的空间开销。 代码如下： 归并排序（）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MergeSort &#123; public static void mergeSort(int[] list) &#123; if (list.length &gt; 1) &#123; // 对前半部分进行归并 int[] firstHalf = new int[list.length / 2]; System.arraycopy(list, 0, firstHalf, 0, list.length / 2); mergeSort(firstHalf); // 对后半部分进行归并 int secondHalfLength = list.length - list.length / 2; int[] secondHalf = new int[secondHalfLength]; System.arraycopy(list, list.length / 2, secondHalf, 0, secondHalfLength); mergeSort(secondHalf); // 把两部分数列合并到一个数列中 merge(firstHalf, secondHalf, list); &#125; &#125; public static void merge(int[] list1, int[] list2, int[] temp) &#123; int current1 = 0; int current2 = 0; int current3 = 0; while (current1 &lt; list1.length &amp;&amp; current2 &lt; list2.length) &#123; if (list1[current1] &lt; list2[current2]) temp[current3++] = list1[current1++]; else temp[current3++] = list2[current2++]; &#125; while (current1 &lt; list1.length) temp[current3++] = list1[current1++]; while (current2 &lt; list2.length) temp[current3++] = list2[current2++]; &#125; public static void main(String[] args) &#123; int[] list = &#123; 2, 3, 2, 5, 6, 1, -2, 3, 14, 12 &#125;; mergeSort(list); for (int i = 0; i &lt; list.length; i++) System.out.print(list[i] + " "); &#125;&#125; 在方法二中，递归地对数组的前半部分和后半部分进行排序，而不创建新的临时数组，然后把两个数组归并到一个临时数组中并将它的内容复制到初始数组中。 归并排序（推荐）归并排序（法二）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MergeSort &#123; public static void mergeSort(int[] arr, int left, int right) &#123; if (left == right) &#123; return; &#125; else &#123; // 取中间的数进行拆分 int mid = (left + right) / 2; // 左边的数不断进行拆分 mergeSort(arr, left, mid); // 右边的数不断进行拆分 mergeSort(arr, mid + 1, right); // 合并 merge(arr, left, mid + 1, right); &#125; &#125; public static void merge(int[] arr, int left, int mid, int right) &#123; int[] leftArray = new int[mid - left]; int[] rightArray = new int[right - mid + 1]; for (int i = left; i &lt; mid; i++) &#123; leftArray[i - left] = arr[i]; &#125; for (int i = mid; i &lt;= right; i++) &#123; rightArray[i - mid] = arr[i]; &#125; int i = 0, j = 0; int k = left; while (i &lt; leftArray.length &amp;&amp; j &lt; rightArray.length) &#123; if (leftArray[i] &lt; rightArray[j]) &#123; arr[k++] = leftArray[i++]; &#125; else &#123; arr[k++] = rigthArray[j++]; &#125; &#125; while (i &lt; leftArray.length) &#123; arr[k++] = leftArray[i++]; &#125; while (j &lt; rightArray.length) &#123; arr[k++] = rigthArray[j++]; &#125; &#125; public static void main(String[] args) &#123; int[] arrays = &#123; 9, 2, 5, 1, 3, 2, 1, 3, 2, 8, 7, 10 &#125;; //设置4个值的断点查看递归调用栈变化 //int[] arrays = &#123; 9, 2, 5, 1 &#125;; mergeSort(arrays, 0, arrays.length - 1); System.out.println(Arrays.toString(arrays)); &#125;&#125; 可以在Eclipse的debug中设置断点，查看递归调用和返回的次序，注意观察变量值的变化。 算法复杂度及稳定性算法复杂度：时间复杂度（平均）： O(nlogn)时间复杂度（最坏）： O(nlogn)时间复杂度（最好）： O(nlogn) 空间复杂度： O(n) 在这里我们只不过是利用了递归的思想，将数组每一次都分解为原来的一半大小的两个子数组，当分解到了右边界比左边界还大的时候，不再分解，开始排序。然后将排序好的子数组逐级合并，最后得到的结果就是排序好的数组。 原数组的长度为n，则细分得最大深度为logn，每一层需要排序的元素为n；则归并排序的时间复杂度为O(nlogn)。 稳定性：因为交换元素时，可以在相等的情况下做出不移动的限制，所以归并排序是可以稳定的。]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>MergeSort</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序(5) 鸡尾酒排序]]></title>
    <url>%2Fleetcode%2F2019%2F04%2F01%2Fcock-tail-sort.html</url>
    <content type="text"><![CDATA[冒泡排序已经对算法进行有优化，但仍然不是最优。鸡尾酒排序又叫快乐小时排序，它基于冒泡排序又做了一点优化。博客中给出了鸡尾酒排序的优化版本。 鸡尾酒排序原理回顾冒泡排序的思想：冒泡排序的每一个元素都可以像一个小气泡一样，根据自身大小，一点一点向着数组的一侧移动。算法的每一轮都是 从左到右比较元素，进行单向的位置交换。 那么鸡尾酒排序做了怎样的优化呢？鸡尾酒排序的元素比较和交换过程是 双向的。 举个例子：有8个数组成一个无序数列 {2, 3, 4, 5, 6, 7, 8, 1}，希望从小到大排序 冒泡排序过程省略，可以看出来，需要将1进行7轮排序。 按照冒泡排序，事实上，2到8已经是有序了，只有元素1的位置不对，却还要进行7轮排序！！这明显不合理，需要改进。而鸡尾酒排序正是要解决这种问题。 鸡尾酒排序过程那么鸡尾酒排序又是什么样的？下面看看详细过程： 数列{2, 3, 4, 5, 6, 7, 8, 1} 第一轮（和冒泡排序一样，8和1交换）：交换后 {2, 3, 4, 5, 6, 7, 1, 8} 第二轮：反过来 从右往左比较和交换： 8已经处于有序区，我们忽略掉8，让1和7比较。元素1小于7，所以1和7交换位置：{2, 3, 4, 5, 6, 1, 7, 8} 接下来1和6比较，元素1小于6，所以1和6交换位置：{2, 3, 4, 5, 1, 6, 7, 8} 接下来1和5比较，元素1小于5，所以1和5交换位置：{2, 3, 4, 1, 5, 6, 7, 8} 接下来1和4交换，1和3交换，1和2交换，最终成为了下面的结果：{1, 2, 3, 4, 5, 6, 7, 8} 第三轮（虽然已经有序，但是流程并没有结束）： 鸡尾酒排序的第三轮，需要重新从左向右比较和交换 1和2比较，位置不变；2和3比较，位置不变；3和4比较，位置不变……6和7比较，位置不变。 没有元素位置交换，证明已经有序，排序结束。 以上就是鸡尾酒排序的思路。排序过程就像钟摆一样，第一轮从左到右，第二轮从右到左，第三轮再从左到右…… 原始实现下面这段代码是鸡尾酒排序的原始实现。代码外层的大循环控制着所有排序回合，大循环内包含两个小循环，第一个循环从左向右比较并交换元素，第二个循环从右向左比较并交换元素。 鸡尾酒排序java原始实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class CockTailSort &#123; public static void cockTailSort(int[] arr) &#123; int tmp = 0; for (int i = 0; i &lt; arr.length / 2; i++) &#123; //有序标记，每一轮的初始是true boolean isSorted = true; //奇数轮，从左向右比较和交换 for (int j = i; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; //有元素交换，所以不是有序，标记变为false isSorted = false; &#125; &#125; if (isSorted) &#123; break; &#125; //偶数轮之前，重新标记为true isSorted = true; //偶数轮，从右向左比较和交换 for (int j = arr.length - i - 1; j &gt; i; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; tmp = arr[j]; arr[j] = arr[j - 1]; arr[j -1] = tmp; //有元素交换，所以不是有序，标记变为false isSorted = false; &#125; &#125; if (isSorted) &#123; break; &#125; &#125; &#125; public static void main (String[] args) &#123; int[] list = &#123;2, 32, 3, 34, 45, 8, 89, 20, 23, -1, -2, -3, -25&#125;; cockTailSort(list); for (int i: list) System.out.print(i + " "); System.out.println(); &#125;&#125; 鸡尾酒排序进一步优化在将冒泡排序的时候，有一种针对有序区的优化，鸡尾酒排序也可以根据这个思路来进行优化。 回顾一下冒泡排序针对有序区的优化思路：原始的冒泡排序，有序区的长度和排序的轮数是相等的。比如第一轮排序过后的有序区长度是1，第二轮排序过后的有序区长度是2…… 要想优化，我们可以在每一轮排序的最后，记录下最后一次元素交换的位置，那个位置也就是无序数列的边界，再往后就是有序区了。 对于单向的冒泡排序，我们需要设置一个边界值，对于 双向的鸡尾酒排序，我们需要设置两个边界值。 优化边界条件的鸡尾酒排序代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class CockTailSort &#123; public static void cockTailSort(int[] arr) &#123; int tmp = 0; int lastRightExchangedIndex = 0; //记录右侧最后一次交换的位置 int lastLeftExchangedIndex = 0; //记录左侧最后一次交换的位置 //无序数列的右边界，每次比较只需要比到这里为止 int rigthSortBorder = arr.length - 1; //无序数列的左边界，每次比较只需要比到这里为止 int leftSortBorder = 0; for (int i = 0; i &lt; arr.length / 2; i++) &#123; boolean isSorted = true; //奇数轮，从左向右比较和交换 for (int j = leftSortBorder; j &lt; rigthSortBorder; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; isSorted = false; lastRightExchangedIndex = j; &#125; &#125; rigthSortBorder = lastRightExchangedIndex; if (isSorted) &#123; break; &#125; isSorted = true; //偶数轮，从右向左比较和交换 for (int j = rigthSortBorder; j &gt; leftSortBorder; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; tmp = arr[j]; arr[j] = arr[j - 1]; arr[j - 1] = tmp; isSorted = false; lastLeftExchangedIndex = j; &#125; &#125; leftSortBorder = lastLeftExchangedIndex; if (isSorted) &#123; break; &#125; &#125; &#125;&#125; 代码中使用了左右两个边界值，rightSortBorder 代表右边界，leftSortBorder代表左边界。 在比较和交换元素时，奇数轮从 leftSortBorder 遍历到 rightSortBorder 位置，偶数轮从 rightSortBorder 遍历到 leftSortBorder 位置。 复杂度及稳定性鸡尾酒排序的优点是能够在特定条件下，减少排序的回合数；缺点是，代码量几乎扩大了一倍。 至于能发挥出优势的场景，就是在 大部分元素已经有序 的情况下，比冒泡完美版还要好。 但是鸡尾酒排序即使优化了，时间复杂度也是O(n^2)，和冒泡排序的是时间复杂度相同。]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>CockTailSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序(4) 冒泡排序]]></title>
    <url>%2Fleetcode%2F2019%2F04%2F01%2Fbubble-sort.html</url>
    <content type="text"><![CDATA[冒泡排序算法多次遍历数组，在每次遍历中连续比较相邻的元素，如果元素没有按照顺序排列，则互换他们的值。 博客中先给出了朴素版本，再给出了优化了每一轮内循环结束点（减少遍历轮次）的needNextPass版本和isSorted版本，还有进一步优化判断边界的sortBorder版本，sortBorder版本为最优化版本。 冒泡排序原理冒泡排序算法需要遍历几次数组。在每次遍历中，比较连续相邻的元素。如果某一堆元素是降序，则互换他们的值；否则，保持不变。由于较小的值像“气泡”一样逐渐浮向顶部，而较大的值沉向底部，由此得名冒泡排序（bubble sort）或下沉排序（sinking sort）。 冒泡排序的名字很形象，实际实现是相邻两节点进行比较，大的向后移一个，经过第一轮两两比较和移动，最大的元素移动到了最后，第二轮次大的位于倒数第二个，依次进行。这是最基本的冒泡排序，还可以进行一些优化。 优化一： 如果某一轮两两比较中没有任何元素交换，这说明已经都排好序了，算法结束，可以使用一个isSorted做标记，默认为true，如果发生交互则置为false，每轮结束时检测isSorted，如果为false则继续，如果为true则返回。 优化二： 某一轮结束位置为j，但是这一轮的最后一次交换发生在lastExchangedIndex的位置，则lastExchangedIndex到j之间是排好序的，下一轮的结束点就不必是j–了，而直接到lastExchangedIndex即可。 算法描述第一次遍历后，最后一个元素称为数组中的最大数。第二次遍历后，倒数第二个元素成为数组中的第二大数。整个过程持续到所有元素都已排好序。第k次遍历时，不需要考虑最后k-1个元素，因为它们已经排好序了。 朴素版本伪代码描述：朴素版本伪代码123456for (int k = 1; k &lt; arr.length; k++) &#123; for (int i = 0; i &lt; arr.length - k; i++) &#123; if (arr[i] &gt; arr[i + 1]) swap arr[i] with arr[i + 1]; &#125;&#125; 注意到如果在某次遍历中没有发生交换，那么就不必进行下一次遍历，因为所有的元素已经排好序了。可以用下面的伪代码描述needNextPass版本：如果某一轮两两比较中没有任何元素交换，这说明已经都排好序了，算法结束，可以使用一个needNextPass做标记，默认为false，如果发生交互则置为true，每轮结束时检测needNextPass，如果为true则继续，如果为false则返回。 needNextPass版本伪代码123456789101112boolean needNextPass = true;for (int k = 1; k &lt; arr.length &amp;&amp; needNextPass; k++) &#123; // 数组可能已经排好序，不需要再进入下次循环 needNextPass = false; // 第k次遍历 for (int i = 0; i &lt; arr.length - k; i++) &#123; if (arr[i] &gt; arr[i + 1]) &#123; swap arr[i] with arr[i + 1]; needNextPass = true; &#125; &#125;&#125; 冒泡排序朴素版本代码非常简单，使用双循环来进行排序。外部循环控制所有的回合，内部循环代表每一轮冒泡处理，先进行元素比较，再进行元素交换。这种写法不会拿到offer的。 java实现朴素版本12345678910111213141516171819202122public class BubbleSort &#123; public static void bubbleSort(int[] arr) &#123; int tmp = 0; for (int i = 0; i &lt; arr.length; i++) &#123; // 内部循环代表每一轮冒泡处理 for (j = 0; j &lt; arr.length - i - 1; j++) &#123; if (arr[j + 1] &lt; arr[j]) &#123; tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] array = new int[] &#123; 5, 8, 6, 3, 9, 2, 1, 7 &#125;; bubbleSort(array); System.out.println(Arrays.toString(array)); &#125;&#125; 很明显可以看出，自从经过第六轮排序，整个数列已然是有序的了。可是我们的排序算法仍然“兢兢业业”地继续执行第七轮、第八轮。这种情况下，如果我们能判断出数列已经有序，并且做出标记，剩下的几轮排序就可以不必执行，提早结束工作。 冒泡排序优化一第一步优化，可以使用needNextPass版本或者isSorted版本。这两个版本的含义，从两个flag的字面就能理解其作用。本质上是一样的。 needNextPass版本代码如果某一轮两两比较中没有任何元素交换，这说明已经都排好序了，那么就不必进行下一次遍历，因为所有的元素都已排好序，算法结束。 可以使用一个needNextPass做标记，默认为false，如果发生交换则置为true，每轮结束时检测needNextPass，如果为true则继续，如果为false则返回。 needNextPass版本123456789101112131415161718192021222324252627public class BubbleSort &#123; public static void bubbleSort(int[] arr) &#123; boolean needNextPass = true; for (int i = 1; i &lt; arr.length &amp;&amp; needNextPass; i++) &#123; needNextPass = false; for (int j = 0; j &lt; arr.length - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; // 改变标志位 needNextPass = true; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] list = &#123; 2, 32, 3, 34, 45, 8, 89, 20, 23, -1, -2 &#125;; bubbleSort(list); for (int i : list) System.out.print(i + " "); System.out.println(); &#125;&#125; isSorted版本代码这一版代码做了小小的改动，利用布尔变量isSorted作为标记。如果在本轮排序中，元素有交换，则说明数列无序；如果没有元素交换，说明数列已然有序，直接跳出大循环。 如果某一轮两两比较中没有任何元素交换，这说明已经都排好序了，算法结束，可以使用一个isSorted做标记，默认为true，如果发生交换则置为false，每轮结束时检测isSorted，如果为false则继续，如果为true则返回。 isSorted版本12345678910111213141516171819202122232425262728293031public class BubbleSort &#123; public static void bubbleSort(int[] arr) &#123; int tmp = 0; for (int i = 0; i &lt; arr.length; i++) &#123; boolean isSorted = true; for (int j = 0; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; isSorted = false; &#125; &#125; if (isSorted) &#123; break; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] list = &#123; 2, 32, 3, 34, 45, 8, 89, 20, 23, -1, -2 &#125;; bubbleSort(list); for (int i : list) System.out.print(i + " "); System.out.println(); &#125;&#125; sortBorder版本(结合优化一和优化二)具体分析为了说明问题，用下面的数列为例（在纸上演示一下）：{3, 4, 2, 1, 5, 6, 7, 8}这个数组的特点是前半部分{3, 4, 2, 1}无序，后半部分{5, 6, 7, 8}有序，并且后半部分的元素已经是数列最大值。 按照冒泡排序的思路来排序： 第一轮： 元素3和4比较，发现3小于4，所以位置不变； 元素4和2比较，发现4大于2，所以4和2交换； 元素4和1比较，发现4大于1，所以4和1交换。 此时数列：{3, 2, 1, 4, 5, 6, 7, 8} 但是接下来： 元素4和5比较，发现4小于5，所以位置不变； 元素5和6比较，发现5小于6，所以位置不变； 元素6和7比较，发现6小于7，所以位置不变； 元素7和8比较，发现7小于8，所以位置不变。 第一轮结束，数列有序区包含一个元素： 8{3, 2, 1, 4, 5, 6, 7, 8} 第二轮： 元素3和2比较，发现3大于2，所以3和2交换； 元素3和1比较，发现3大于1，所以3和1交换。 此时数列：{2, 1, 3, 4, 5, 6, 7, 8} 但是接下来 元素3和4比较，发现3小于4，所以位置不变； 元素4和5比较，发现4小于5，所以位置不变； 元素5和6比较，发现5小于6，所以位置不变； 元素6和7比较，发现6小于7，所以位置不变； 元素7和8比较，发现7小于8，所以位置不变。 第二轮结束，数列有序区包含一个元素： 7, 8{2, 1, 3, 4, 5, 6, 7, 8} 由上面两轮分析，发现问题：右面的许多元素已经是有序了，可是每一轮还是白白比较了许多次。这正是冒泡排序当中另一个需要优化的点。 接下来的讨论，在代码实现部分进行。 完全优化版本代码这个问题的关键点在哪里呢？关键在于对数列有序区的界定。 按照现有的逻辑，有序区的长度和排序的轮数是相等的。比如第一轮排序过后的有序区长度是1，第二轮排序过后的有序区长度是2,…… 实际上，数列真正的有序区可能会大于这个长度，比如例子中仅仅第二轮，后面5个元素实际都已经属于有序区。因此后面的许多次元素比较是没有意义的。 如何避免这种情况呢？我们可以在每一轮排序的最后，记录下最后一次元素交换的位置，那个位置也就是无序数列的边界，再往后就是有序区了。 sortBorder版本（完美版本）1234567891011121314151617181920212223242526272829303132333435363738public class BubbleSort &#123; public static void bubbleSort(int[] arr) &#123; int tmp = 0; //记录最后一次交换的位置 int lastExchangedIndex = 0; //无序数列的边界，每次比较只需要比到这里为止 int sortBorder = arr.length - 1; for (int i = 0; i &lt; arr.length; i++) &#123; //有序标记，每一轮的初始是true boolean isSorted = true; for (int j = 0; j &lt; sortBorder; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; //有元素交换，所以不是有序，标记变为false isSorted = false; //把无序数列的边界更新为最后一次交换元素的位置 lastExchangedIndex = j; &#125; &#125; sortBorder = lastExchangedIndex; if (isSorted) &#123; break; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] array = new int[] &#123; 5, 8, 6, 3, 9, 2, 1, 7 &#125;; bubbleSort(array); System.out.println(Arrays.toString(array)); &#125;&#125; 这一版代码中，sortBorder就是无序数列的边界。每一轮排序过程中，sortBorder之后的元素就完全不需要比较了，肯定是有序的。 算法复杂度和稳定性其实这样的实现，仍然不是最优，有一种排序算法叫做 鸡尾酒排序，是基于冒泡排序的一种升级。具体见博客鸡尾酒排序。 算法复杂度：时间复杂度（平均）： O(n^2)时间复杂度（最坏）： O(n^2)时间复杂度（最好）： O(n) 空间复杂度： O(1) 冒泡排序把小元素往前调或者把大元素往后调，在相邻的两个元素间比较和交换。如果两个元素相等且相邻，它们不会进行交换；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换。 所以相同元素的前后顺序并没有改变，冒泡排序是一种 稳定排序算法。]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>BubbleSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序(3) 希尔排序]]></title>
    <url>%2Fleetcode%2F2019%2F04%2F01%2Fshell-sort.html</url>
    <content type="text"><![CDATA[希尔排序又叫缩小增量排序，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。 希尔排序是对插入排序的优化，基于以下两个认识：1.数据量较小时插入排序速度较快，因为n和n²差距很小；2.数据基本有序时插入排序效率很高，因为比较和移动的数据量少。 希尔排序的时间复杂度和增量的选择策略有关，博客中的选择策略会导致排序的不稳定性。 希尔排序原理因此，希尔排序的基本思想是，将需要排序的序列划分成为若干个较小的子序列，对子序列进行插入排序，通过插入排序能够使得原来序列成为基本有序。这样通过对较小的序列进行插入排序，然后对基本有序的数列进行插入排序，能够提高插入排序算法的效率。 希尔排序的划分子序列不是像归并排序那种的二分，而是采用的叫做增量的技术，例如有十个元素的数组进行希尔排序，首先选择增量为10/2=5，此时第1个元素和第（1+5）个元素配对成子序列使用插入排序进行排序，第2和（2+5）个元素组成子序列，完成后增量继续减半为2，此时第1个元素、第（1+2）、第（1+4）、第（1+6）、第（1+8）个元素组成子序列进行插入排序。这种增量选择方法的好处是可以使数组整体均匀有序，尽可能的减少比较和移动的次数。二分法中即使前一半数据有序，后一半中如果有比较小的数据，还是会造成大量的比较和移动，因此这种增量的方法和插入排序的配合更佳。 在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2, (n/2)/2, …, 1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。 希尔排序的时间复杂度和增量的选择策略有关，上述增量方法造成希尔排序的不稳定性。 因为直接插入排序在元素基本有序的情况下，效率是很高的，因此希尔排序在时间效率上有很大提高。 算法描述无序序列：int a[] = {3, 1, 5, 7, 2, 4, 9, 6}; 第一趟时：n=8; gap = n/2 = 4； 把整个序列共分成了4个子序列{3, 2}、{1, 4}、{5, 9}、{7, 6}第一趟结束时，数列为：{2, 1, 5, 6, 3, 4, 9, 7}; 第二趟时：gap = gap/2 = 2； 把整个序列共分成了2个子序列{2, 5, 3, 9}、{1, 6, 4, 7}第一趟结束时，数列为：{2, 1, 3, 4, 5, 6, 9, 7}; 第三趟时：gap = gap/2 = 1； 对整个序列进行 插入排序 ##代码实现Shell排序1234567891011121314151617181920212223public class ShellSort &#123; public static int[] shellSort(int[] arr) &#123; for (int gap = arr.length / 2; gap &gt;= 1; gap /= 2) &#123; // 对子序列插入排序 for (int i = gap; i &lt; arr.length; i++) &#123; int j = i; int currentElement = arr[i]; while (j - gap &gt;= 0 &amp;&amp; arr[j - gap] &gt; currentElement) &#123; arr[j] = arr[j - gap]; j -= gap; &#125; arr[j] = currentElement; &#125; &#125; return arr; &#125; public static void main(String[] args) &#123; int[] testList = new int[] &#123; -6, -3, -2, 7, -15, 1, 2, 2 &#125;; int[] test = shellSort(testList); System.out.println(Arrays.toString(test)); &#125;&#125; 复杂度及稳定性复杂度时间复杂度（平均）： O(n^1.3)时间复杂度（最坏）： O(n^2)时间复杂度（最好）： O(n) 空间复杂度： O(1) 稳定性Shell排序通过将数据分成不同的组，先对每一组进行排序，然后再对所有的元素进行一次插入排序，以减少数据交换和移动的次数。 希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，插入排序对于有序的序列效率很高。 由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以，Shell排序是 不稳定的。 例如，有100个整数需要排序：第一趟排序，先把它分成50组，每组2个整数，分别排序。第二趟排序，再把经过第一趟排序后的100个整数分成25组，每组4个整数，分别排序。第三趟排序，再把前一次排序后的数分成12组，第组8个整数，分别排序。 照这样子分下去，最后一趟分成100组，每组一个整数，这就相当于一次插入排序。由于开始时每组只有很少整数，所以排序很快。之后每组含有的整数越来越多，但是由于这些数也越来越有序，所以排序速度也很快。 希尔排序平均效率是O(nlogn)，其中分组的合理性会对算法产生重要的影响。 Shell排序比冒泡排序快5倍，比插入排序大致快2倍。Shell排序比起QuickSort，MergeSort，HeapSort慢很多。但是它相对比较简单，它适合于数据量在5000以下并且速度并不是特别重要的场合。它对于数据量较小的数列重复排序是非常好的。 由于开始时每组只有很少整数，所以排序很快。之后每组含有的整数越来越多，但是由于这些数也越来越有序，所以排序速度也很快。然而，情况并不总是这么理想的，在一些特定（但并不算罕见）的情况下，虽然经过了很多趟排序但是数据却没有变得更有序。例如，如果用上面的算法对下面这些数进行排序：1, 9, 2, 10, 3, 11, 4, 12, 5, 13, 6, 14, 7, 15, 8, 16 在gap = 1之前的每一趟排序都在浪费时间！ 这种坏情形是可以避免的，就是把上面的增量数列（1, 2, 4, 8）改成Hibbard增量（1, 3, 5, 7）由此可见，增量数列的选择对希尔排序的性能有着极大的影响。 Mark Allen Weiss指出，最好的增量序列是Sedgewick提出的 (1, 5, 19, 41, 109, …)，该序列的项来自 9 4^i - 9 2^i + 1 和 4^i - 3 * 2^i + 1 这两个算式。]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>ShellSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序(2) 插入排序]]></title>
    <url>%2Fleetcode%2F2019%2F04%2F01%2Finsertion-sort.html</url>
    <content type="text"><![CDATA[插入排序重复地将新的元素插入到一个排好序的子线性表中，直到整个线性表排好序。 遍历数组，遍历到i时，a0,a1,…,ai-1是已经排好序的，取出ai，从ai-1开始向前和每个比较大小，如果小于，则将此位置元素向后移动，继续先前比较，如果不小于，则放到正在比较的元素之后。可见相等元素比较是，原来靠后的还是排在后边，所以插入排序是稳定的。 当待排序的数据基本有序时，插入排序的效率比较高，只需要进行很少的数据移动。 插入排序原理遍历数组，遍历到i时，a0,a1,…,ai-1是已经排好序的，取出ai，从ai-1开始向前和每个比较大小，如果小于，则将此位置元素向后移动，继续先前比较，如果不小于，则放到正在比较的元素之后。可见相等元素比较是，原来靠后的还是排在后边，所以插入排序是稳定的。当待排序的数据基本有序时，插入排序的效率比较高，只需要进行很少的数据移动。 插入排序的一个重要的特点是，如果原始数据的大部分元素已经排序，那么插入排序的速度很快（因为需要移动的元素很少）。从这个事实我们可以想到，如果原始数据只有很少元素，那么排序的速度也很快。－－希尔排序就是基于这两点对插入排序作出了改进。 算法描述对数列{2, 9, 5, 4, 8, 1, 6}进行排序，可以自己模拟对未排序的数列{9, 5, 4, 8, 1, 6}插入排序，直到数列排好序。 这个算法可以描述为：插入排序伪代码123for (int i = 1; i &lt; arr.length; i++) &#123; 将arr[i]插入到已排好序的只线性表中，这样arr[0 ... i]也是排好序的&#125; 插入arr[i]到arr[0, …, i-1]中有下面的过程：1.将arr[i]存储在一个名为currentElement的临时变量中；2.如果arr[i - 1] &gt; currentElement，就将arr[i - 1]移到arr[i]中；3.如果arr[i - 2] &gt; currentElement，就将arr[i - 2]移到arr[i - 1]中；4.依此类推，直到arr[i - k] &lt;= currentElement 或者 k &gt; i(传递的是排好序的数列的第一个元素)， 将currentElement赋值给arr[i - k + 1]。 插入排序代码插入排序的过程很好理解，代码如下： 插入排序123456789101112131415161718192021222324public class InsertionSort &#123; public static void insertionSort(int[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; // 插入arr[i]到已经排好序的子线性表arr[0 ... i-1]中 int currentElement = arr[i]; int k; for (k = i - 1; k &gt; 0 &amp;&amp; arr[k] &gt; currentElement; k--) &#123; arr[k+1] = arr[k]; &#125; // 插入当前元素到arr[k+1]中 arr[k + 1] = currentElement; &#125; &#125; public static void main(String[] args) &#123; int[] list = &#123;2, 32, 3, 34, 45, 8, 89, 20, 23, -1&#125;; insertionSort(list); for (int i: list) System.out.print(i + " "); &#125;&#125; 内外层循环的作用：外层循环（循环控制变量i）的迭代是为了获取已排好序的子线性表，其范围是arr[0] 到arr[i]。 内层循环（循环控制变量k）将arr[i]插入到arr[0]到arr[i-1]的子线性表。 复杂度和稳定性时间复杂度（平均）： O(n^2)时间复杂度（最坏）： O(n^2)时间复杂度（最好）： O(n) 空间复杂度： O(1) 因为在有序部分元素和待插入元素相等的时候，可以将待插入的元素放在前面，所以插入排序是 稳定的。]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>InsertionSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序(1) 选择排序]]></title>
    <url>%2Fleetcode%2F2019%2F04%2F01%2Fselection-sort.html</url>
    <content type="text"><![CDATA[选择排序是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 遍历数组，遍历到i时，a0,a1,…,ai-1是已经排好序的，然后从i到n选择出最小的，记录下位置，如果不是第i个，则和第i个元素交换。此时第i个元素可能会排到相等元素之后，造成排序的不稳定。 选择排序（最小元素）分析假设要按照升序排列一个数列 {2, 9, 5, 4, 8, 1, 6}。选择排序法首先找到数列中最小的数，然后将它和第一个元素交换。接下来，在剩下的数中找到最小数，将它和第二个元素交换，以此类推，直到数列中仅剩一个数为止。 可以在纸上模拟一下具体选择排序过程。 开始编写第一次迭代的代码，找出数列中的最大数，将其与最后一个元素互换，然后观察第二次迭代与第一次的不同之处，接着是第三次，以此类推。通过这样的观察可以写出推广到所有迭代的循环。 解决方案伪代码1234567for (int i = 0; i &lt; arr.length - 1; i++) &#123; select the smallest element in arr[i ... arr.length-1]; swap the smallest with arr[i], if necessary; // arr[i] is in its correct position // the next iteration applies on arr[i+1 ... arr.length-1]&#125; java实现选择排序（最小元素）代码实现过程比较简单，如下： 选取最小值的选择排序12345678910111213141516171819202122232425262728293031323334353637public class SelectionSort &#123; // 选择排序 public static void selectionSort(int[] arr) &#123; if (arr == null || arr.length &lt; = 1) &#123; return; &#125; int currentMin; int currentMinIndex; for (int i = 0; i &lt; arr.length - 1; i++) &#123; // 找到最小值和最小值下标位置，在范围arr[i ... arr.length-1] currentMin = arr[i]; currentMinIndex = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (currentMin &gt; arr[j]) &#123; currentMin = arr[j]; currentMindIndex = j; &#125; &#125; if (currentMinIndex != i) &#123; arr[currentMinIndex] = arr[i]; arr[i] = currentMin; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] list = &#123;2, 32, 3, 34, 45, 8, 89, 20, 23&#125;; selectionSort(list); for (int i: list) System.out.print(i + " "); &#125;&#125; 选择排序（最大值）上面的选择排序法重复地在当前数组中找到最小值，然后将这个最小值与该数组中的第一个数进行交换。修改成：重复地选取当前数组中最大值，然后将这个最大值与该数组中的最后一个数进行交换，直到数组中的第一个元素。 选择最大值的选择排序123456789101112131415161718192021222324252627public class SelectionSort&#123; // 选择排序 public static void selectionSort(int[] arr) &#123; int currentMax; int currentMaxIndex; for (int i = list.length - 1; i &gt;= 0; i--) &#123; currentMax = list[i]; currentMaxIndex = i; for (int j = i - 1; j &gt;= 0; j--) &#123; if (currentMax &lt; arr[j]) &#123; currentMax = arr[j]; currentMaxIndex = j; &#125; &#125; if (currentMaxIndex != i) &#123; arr[currentMaxIndex] = arr[i]; arr[i] = currentMax; &#125; &#125; &#125; // ========测试用例略=========&#125; 算法复杂度选择排序复杂度：时间复杂度（平均）： O(n^2)时间复杂度（最坏）： O(n^2)时间复杂度（最好）： O(n^2) 空间复杂度： O(1) 选择排序稳定性选择排序是不稳定的算法。 算法稳定性定义在待排序的数据中，存在多个相同的数据，经过排序之后，他们的对相对顺序依旧保持不变，实际上就是说 array[i] = array[j], i &lt; j就是array[i]在array[j]之前，那么经过排序之后array[i]依旧在array[j]之前，那么这个排序算法稳定，否则，这个排序算法不稳定 也就是说，只要能举出一个反例来说明这个算法不稳定，那么这个算法就是不稳定的 针对选择排序算法，如下反例：数列 {5, 8, 5, 2, 9} 这个在执行选择排序的时候，第一遍，肯定会将array[0]=5，交换到2所在的位置:也就是 {2, 8, 5, 5, 9} 那么很显然，之后的排序我们就会发现，array[2]中的5会出现在原先的array[0]之前，所以选择排序不是一个稳定的排序。]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>SelectionSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(9) 用两个栈实现队列]]></title>
    <url>%2Fleetcode%2F2019%2F03%2F29%2Fqueue-with-two-stacks.html</url>
    <content type="text"><![CDATA[用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail和deleteHead，分别完成在队列尾部插入结点和在队列头部删除结点的功能。 实现法一思路：插入删除的过程（在草稿纸上动手画一下）：插入肯定是往一个栈stack1中一直插入；删除时，直接出栈无法实现队列的先进先出规则，这时需要将元素从stack1出栈，压到另一个栈stack2中，然后再从stack2中出栈就OK了。 需要稍微注意的是：当stack2中还有元素，stack1中的元素不能压进来；当stack2中没元素时，stack1中的所有元素都必须压入stack2中。否则顺序就会被打乱。 测试用例： 往空队列添加、删除元素 往非空队列里添加、删除元素 连续删除元素至队列为空 完整代码用两个栈实现队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.Stack;public class QueueWithStacks &#123; class Queue &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;&gt;(); /** * 插入节点 */ public void push(int node) &#123; stack1.push(node); &#125; /** * 删除节点 */ public int pop() &#123; if (stack2.empty()) &#123; if (stack1.empty()) &#123; throw new RuntimeException("队列为空"); &#125; else &#123; while (!stack1.empty()) stack2.push(stack1.pop()); &#125; &#125; return stack2.pop(); &#125; &#125; // =======测试代码========== public void test1() &#123; Queue queue = new Queue(); queue.push(1); queue.push(2); System.out.println(queue.pop()); queue.push(3); System.out.println(queue.pop()); System.out.println(queue.pop()); &#125; /** * 往空队列删除元素 */ public void test2() &#123; Queue queue = new Queue(); System.out.println(queue.pop()); &#125; public static void main(String[] args) &#123; QueueWithStacks demo = new QueueWithStacks(); demo.test1(); // demo.test2(); &#125;&#125; 实现法二思路：队列和栈的主要区别在于元素进出顺序，因此，需要修改peek()和pop()，以相反的顺序执行。利用第二个栈反转元素的次序（弹出s1的元素，压入s2）。在这种实现中，每当执行peek()和pop()操作时，就要将s1的所有元素弹出，压入s2中，然后执行peek()和pop()操作，再将元素压入s1. 但是若连续执行两次peek()和pop()操作，那么，所有元素移来移去，重复移动。 可以延迟元素的移动，即让元素一直留在s2中，只有必须反转元素次序是才移动元素。 stackNewest顶端为最新元素，stackOldest顶端为最旧元素。在将一个元素出列是，我们希望先移除最旧元素，因此先将元素从stackOldest将元素出列。若stackOldest为空，在将stackNewest中所有元素以相反的顺序移到stackOldest中。如果要插入元素，就将其压入stackNewest，因为最新元素位于它的顶端。 用两个栈实现一个队列1234567891011121314151617181920212223242526272829303132333435import java.util.Stack;public class MyQueue&lt;T&gt; &#123; Stack&lt;T&gt; stackNewest, stackOldest; public MyQueue() &#123; stackNewest = new Stack&lt;&gt;(); stackOldest = new Stack&lt;&gt;(); &#125; public int size() &#123; return stackNewest.size() + stackOldest.size(); &#125; public void add(T val) &#123; stackNewest.push(val); &#125; private void shiftStacks() &#123; if (stackOldest.isEmpty()) &#123; while (!stackNewest.isEmpty()) &#123; stackOldest.push(stackNewest.pop()); &#125; &#125; &#125; public T peek() &#123; shiftStacks(); return stackOldest.peek(); &#125; public T remove() &#123; shiftStacks(); return stackOldest.pop(); &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(8) 二叉树的下一个节点]]></title>
    <url>%2Fleetcode%2F2019%2F03%2F28%2Fnext-node-in-binary-tree.html</url>
    <content type="text"><![CDATA[给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？ 树中的结点除了有两个分别指向左右子结点的指针以外，还有一个指向父结点的指针。 二叉树的下一个节点思路：首先自己在草稿纸上画图，进行分析（不再展开）。可以发现下一个结点的规律为： 若当前节点有右子树，旗下一个节点为右子树中最左子节点； 若当前节点无右子树时， 若当前节点为其父节点的左子结点时，其子啊一个节点为其父节点； 若当前节点为其父节点的右子节点时，继续向上遍历父节点的父节点，直到找到一个节点是其父节点的左子结点（与(1)中判断相同），该节点的父节点即为下一节点。 测试用例： 正常二叉树 左斜树、右斜树 单个节点 null 不同位置节点的下一节点(包含下一个节点为当前节点的右子树节点，右子树的最左子节点，父节点，跨层的父节点等；当前节点没有下一个节点) 完整Java代码二叉树的下一个节点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package chapter2.tree;public class NextNodeInBinaryTrees &#123; private class TreeLinkNode &#123; int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode parent = null; TreeLinkNode(int val) &#123; this.val = val; &#125; &#125; public TreeLinkNode getNext(TreeLinkNode pNode) &#123; if (pNode == null) &#123; System.out.print("节点为null"); return null; &#125; if (pNode.right != null) &#123; pNode = pNode.right; while (pNode.left != null) &#123; pNode = pNode.left; &#125; return pNode; &#125; while (pNode.parent != null) &#123; if (pNode == pNode.parent.left) &#123; return pNode.parent; &#125; pNode = pNode.parent; &#125; return null; &#125; // ==================================测试代码================================== // 创建树较为繁琐，未包括所有测试代码。 public void test1() &#123; TreeLinkNode node = null; TreeLinkNode nextNode = getNext(node); if (nextNode != null) System.out.println(nextNode.val); else System.out.println("无下一结点"); &#125; public void test2() &#123; TreeLinkNode node1 = new TreeLinkNode(1); TreeLinkNode node2 = new TreeLinkNode(2); TreeLinkNode node3 = new TreeLinkNode(3); TreeLinkNode node4 = new TreeLinkNode(4); node1.left = node2; node1.right = node3; node2.parent = node1; node3.parent = node1; node4.left = node1; node1.parent = node4; TreeLinkNode nextNodeOf1 = getNext(node1); TreeLinkNode nextNodeOf2 = getNext(node2); TreeLinkNode nextNodeOf3 = getNext(node3); TreeLinkNode nextNodeOf4 = getNext(node4); if (nextNodeOf1 != null) System.out.println("1结点的下一个结点值为：" + nextNodeOf1.val); else System.out.println("1结点无下一结点"); if (nextNodeOf2 != null) System.out.println("2结点的下一个结点值为：" + nextNodeOf2.val); else System.out.println("2结点无下一结点"); if (nextNodeOf3 != null) System.out.println("3结点的下一个结点值为：" + nextNodeOf3.val); else System.out.println("3结点无下一结点"); if (nextNodeOf4 != null) System.out.println("4结点的下一个结点值为：" + nextNodeOf4.val); else System.out.println("4结点无下一结点"); &#125; public static void main(String[] args) &#123; NextNodeInBinaryTrees demo = new NextNodeInBinaryTrees(); System.out.print("test1:"); demo.test1(); System.out.print("test2:"); demo.test2(); &#125;&#125; 得到 在面对复杂问题时要学会画图和举例分析。 在分情况讨论时，一定要考虑到所有情况，这些都是在写代码前需要考虑到的。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>BinaryTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(7) 重建二叉树]]></title>
    <url>%2Fleetcode%2F2019%2F03%2F27%2Fconstruct-binary-tree.html</url>
    <content type="text"><![CDATA[输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 例如输入前序遍历序列{1, 2, 4, 7, 3, 5, 6, 8}和中序遍历序列{4, 7, 2, 1, 5, 3, 8, 6}，则重建出其二叉树并输出它的头结点。 根据前序和中序遍历重建二叉树热身题目题目：已知二叉树先序遍历序列是A-B-C-D-E-F-G，中序遍历序列是C-B-D-A-E-G-F。由这两个序列可唯一确定一颗二叉树。 分析：：从先序遍历序列第一个节点可知二叉树根节点是A。由节点A在中序遍历序列里位置可知该根点左子树包含节点 B-C-D，右子树包含节点 E-G-F。由先序序列片段 B-C-D可知，B是A左子树根节点，再结合中序序列片段 C-B-D可知，C和D分别是B的左右子节点。由先序序列片段E-F-G可知，E是A的右子节点，结合中序序列片段E-F-G可知，G和F均是E的右子树节点。再由先序序列片段F-G和中序序列片段G-F可知，F是E的右子节点，并且G是F的左子结点。 正题思路：前序遍历第一个值就是根结点的值，根据该值在中序遍历的位置，可以轻松找出该根结点左右子树的前序遍历和中序遍历，之后又可以用同样方法构建左右子树，所以该题可以采用递归的方法完成。 刚开始思考的时候，想的是构建一个遍历函数，输入为前序和中序遍历的数组，输出为根结点。但是这样的话每次都需要构建子树的数组，非常麻烦。 之后想到，该函数的输入不一定要用数组，因为最初的前序和中序遍历数组已经有了，就直接用该数组的下标来表示子树的数组即可。 即构建函数construct(int[] pre, int[] in, int pStart, int pEnd, int iStart, int iEnd)，pre和in始终用最初前序遍历和中序遍历的数组代入，pStart、pEnd代表当前树的前序数组开始和结束位置，iStart、iEnd代表中序数组开始和结束位置。 测试用例： 正常二叉树 左斜树 右斜树 单个结点 数组为空 前序与中序不匹配 完整代码重建二叉树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147package chapter2.tree;public class ConstructBinaryTree &#123; class TreeNode &#123; int val; TreeNode left; TreeNode right; public TreeNode(int val) &#123; this.val = val; &#125; &#125; public TreeNode reConstructBinaryTree(int[] pre, int[] in) &#123; if (pre == null || in == null || pre.length &lt;= 0 || in.length &lt;= 0 || pre.length != in.length) &#123; throw new RuntimeException("数组不符合规范"); &#125; return construct(pre, in, 0, pre.length - 1, 0, in.length - 1); &#125; /** * @Description 由前序遍历序列和中序遍历序列得到根结点 pre、in：始终用最初的前序遍历和中序遍历数组代入 * pStart、pEnd：当前树的前序数组开始和结束位置 iStart、iEnd：中序数组开始和结束位置 */ public TreeNode construct(int[] pre, int[] in, int pStart, int pEnd, int iStart, int iEnd) &#123; TreeNode root = new TreeNode(pre[pStart]); if (pStart == pEnd &amp;&amp; iStart == iEnd) &#123; if (pre[pStart] != in[iStart]) throw new RuntimeException("数组不符合规范"); return root; &#125; int index = iStart; while (root.val != in[index] &amp;&amp; index &lt;= iEnd) &#123; index++; &#125; if (index &gt; iEnd) &#123; throw new RuntimeException("数组不符合规范"); &#125; int leftLength = index - iStart; if (leftLength &gt; 0) &#123; root.left = construct(pre, in, pStart + 1, pStart + leftLength, iStart, index - 1); &#125; if (leftLength &lt; iEnd - iStart) &#123; root.right = construct(pre, in, pStart + leftLength + 1, pEnd, index + 1, iEnd); &#125; return root; &#125; private void preOrderTraverse(TreeNode node) &#123; if (node == null) return; System.out.print(node.val); preOrderTraverse(node.left); preOrderTraverse(node.right); &#125; private void inOrderTraverse(TreeNode node) &#123; if (node == null) return; inOrderTraverse(node.left); System.out.print(node.val); inOrderTraverse(node.right); &#125; /** * 正常二叉树 */ public void test1() &#123; int[] pre = &#123; 1, 2, 4, 7, 3, 5, 6, 8 &#125;; int[] in = &#123; 4, 7, 2, 1, 5, 3, 8, 6 &#125;; TreeNode root = reConstructBinaryTree(pre, in); System.out.print("test1:"); preOrderTraverse(root); System.out.print("//"); inOrderTraverse(root); System.out.println(); &#125; /** * 左斜树 */ public void test2() &#123; int[] pre = &#123; 1, 2, 3, 4, 5 &#125;; int[] in = &#123; 5, 4, 3, 2, 1 &#125;; TreeNode root = reConstructBinaryTree(pre, in); System.out.print("test2:"); preOrderTraverse(root); System.out.print("//"); inOrderTraverse(root); System.out.println(); &#125; /** * 右斜树 */ public void test3() &#123; int[] pre = &#123; 1, 2, 3, 4, 5 &#125;; int[] in = &#123; 1, 2, 3, 4, 5 &#125;; TreeNode root = reConstructBinaryTree(pre, in); System.out.print("test3:"); preOrderTraverse(root); System.out.print("//"); inOrderTraverse(root); System.out.println(); &#125; /** * 单个节点 */ public void test4() &#123; int[] pre = &#123; 1 &#125;; int[] in = &#123; 1 &#125;; TreeNode root = reConstructBinaryTree(pre, in); System.out.print("test4:"); preOrderTraverse(root); System.out.print("//"); inOrderTraverse(root); System.out.println(); &#125; /** * 数组为空 */ public void test5() &#123; int[] pre = &#123;&#125;; int[] in = &#123;&#125;; TreeNode root = reConstructBinaryTree(pre, in); System.out.print("test5:"); preOrderTraverse(root); System.out.print("//"); inOrderTraverse(root); System.out.println(); &#125; public static void main(String[] args) &#123; ConstructBinaryTree demo = new ConstructBinaryTree(); demo.test1(); demo.test2(); demo.test3(); demo.test4(); // demo.test5(); &#125;&#125; 收获 在递归问题中，代码可以用下标表示的就用下标表示，不用重新构建新的数组。 数组为空与数组为null不是一回事。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>BinaryTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(6) 从尾到头打印链表]]></title>
    <url>%2Fleetcode%2F2019%2F03%2F26%2Fprint-list-from-head-to-tail.html</url>
    <content type="text"><![CDATA[输入一个链表的头结点，从尾到头反过来打印出每个结点的值。对于“后进先出”问题，要快速想到”栈“，也同时想到递归。 从头到尾打印链表收获 对于“后进先出”问题，要快速想到”栈“，也同时想到递归。 采用递归时，返回的函数值不一定要有赋值操作，只要实现了遍历的作用就可以了，牛客网的代码可以多多学习。 题目输入一个链表的头结点，从尾到头反过来打印出每个结点的值。节点定义如下： 节点定义如下：1234567class ListNode &#123; int val; ListNode next; ListNode(int val) &#123; this.val = val; &#125;&#125; 思路:结点遍历顺序只能从头到尾，但是输出的顺序却为从尾到头，是典型的“后进先出”问题，这就要联想到使用栈，从而也可以联想到使用递归。 测试用例： 功能测试（单个节点链表，多个节点链表） 特殊输入测试（链表为空） 完整代码 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.util.Stack;public class PrintListInReversedOrder &#123; class Node &#123; int element; Node next; public Node(int element) &#123; this.element = element; &#125; &#125; // 采用栈 public void printListReversingly_Iteratively(Node node) &#123; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); while (node != null) &#123; stack.push(node); node = node.next; &#125; while (!stack.empty()) &#123; System.out.println(stack.pop().element); &#125; &#125; // 采用递归 public void printListReversingly_Recursively(Node node) &#123; if (node != null) &#123; printListReversingly_Recursively(node.next); System.out.println(node.element); &#125; else &#123; return; &#125; &#125; /** * 链表为空 */ public void test1() &#123; Node aNode = null; System.out.println("采用栈："); printListReversingly_Iteratively(aNode); System.out.println("采用递归："); printListReversingly_Recursively(aNode); &#125; /** * 多个结点链表 */ public void test2() &#123; Node Node1 = new Node(1); Node Node2 = new Node(2); Node Node3 = new Node(3); Node Node4 = new Node(4); Node Node5 = new Node(5); Node1.next = Node2; Node2.next = Node3; Node3.next = Node4; Node4.next = Node5; System.out.println("采用栈："); printListReversingly_Iteratively(Node1); System.out.println("采用递归："); printListReversingly_Recursively(Node1); &#125; /** * 单个结点链表 */ public void test3() &#123; Node Node1 = new Node(1); System.out.println("采用栈："); printListReversingly_Iteratively(Node1); System.out.println("采用递归："); printListReversingly_Recursively(Node1); &#125; public static void main(String[] args) &#123; PrintListInReversedOrder demo = new PrintListInReversedOrder(); System.out.println("test1:"); demo.test1(); System.out.println("test2:"); demo.test2(); System.out.println("test3:"); demo.test3(); &#125;&#125; 递归的其他写法递归部分代码也可以像下面这样写，注意体会不同的递归写法：递归的其他写法12345678public void printListReversingly_Recursively(Node node) &#123; if (node != null) &#123; if (node.next != null) &#123; printListReversingly_Recursively(node.next); &#125; System.out.println(node.element); &#125;&#125; 牛客网提交代码采用的递归，非常简洁，很值得学习。 牛客网提交代码1234567891011121314151617181920212223/*** public class ListNode &#123;* int val;* ListNode next = null;** ListNode(int val) &#123;* this.val = val;* &#125;* &#125;*/import java.util.ArrayList;public class Solution &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode node) &#123; if (node != null) &#123; this.printListFromTailToHead(listNode.next); list.add(node.val); &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>LikedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(5) 替换空格]]></title>
    <url>%2Fleetcode%2F2019%2F03%2F24%2Freplace-spaces.html</url>
    <content type="text"><![CDATA[本文有两道题。第一道题，请实现一个函数，把字符串中的每个空格替换成”%20”。例如输入“We are happy.”，则输出“We%20are%20happy.”。 第二道题，实现对一组无序的字母进行从小到大排序（区分大小写），当两个字母相同时，小写字母放在大写字母前。要求时间复杂度为O(n)。 替换空格题目请实现一个函数，把字符串中的每个空格替换成”%20”。例如输入“We are happy.”，则输出“We%20are%20happy.”。 思路: 首先要询问面试官是新建一个字符串还是在原有的字符串上修改，本题要求在原字符串上进行修改。 若从前往后依次替换，在每次遇到空格字符时，都需要移动后面O(n)个字符，对于含有O(n)个空格字符的字符串而言，总的时间效率为O(n^2)。 转变思路：先计算需要的总长度，然后从后往前进行复制和替换，则每个字符只需要复制一次即可。时间效率为O(n)。 测试用例： 字符串中无空格 字符串中含有空格（连续空格，空格在首尾等） 字符串为空字符串或者为null 完整代码根据牛客网的编程练习参考，方法的输入为StringBuffer（String无法改变长度，所以采用StringBuffer），输出为String。 剑指Offer5 替换空格1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class ReplaceSpaces &#123; public String replaceSpaces(StringBuffer) &#123; if (str == null) &#123; System.out.println("输入错误")； return null; &#125; int length = str.length(); int indexOfOriginal = length - 1; for (int i = 0; i &lt; str.length(); i++) &#123; if (str.charAt(i) == ' ') &#123; length += 2; &#125; &#125; str.setLength(length); int indexOfNew = length - 1; while (indexOfNew &gt; indexOfOriginal) &#123; if (str.charAt(indexOfOriginal) != ' ') &#123; str.setCharAt(indexOfNew--, str.charAt(indexOfOriginal)); &#125; else &#123; str.setCharAt(indexOfNew--, '0'); str.setCharAt(indexOfNew--, '2'); str.setCharAt(indexOfNew--, '%'); &#125; indexOfOriginal--; &#125; return str.toString(); &#125; // ==================================测试代码================================== /** * 输入为null */ public void test1() &#123; System.out.print("Test1："); StringBuffer sBuffer = null; String s = replaceSpace(sBuffer); System.out.println(s); &#125; /** * 输入为空字符串 */ public void test2() &#123; System.out.print("Test2："); StringBuffer sBuffer = new StringBuffer(""); String s = replaceSpace(sBuffer); System.out.println(s); &#125; /** * 输入字符串无空格 */ public void test3() &#123; System.out.print("Test3："); StringBuffer sBuffer = new StringBuffer("abc"); String s = replaceSpace(sBuffer); System.out.println(s); &#125; /** * 输入字符串为首尾空格，中间连续空格 */ public void test4() &#123; System.out.print("Test4："); StringBuffer sBuffer = new StringBuffer(" a b c "); String s = replaceSpace(sBuffer); System.out.println(s); &#125; public static void main(String[] args) &#123; ReplaceSpaces rs = new ReplaceSpaces(); rs.test1(); rs.test2(); rs.test3(); rs.test4(); &#125;&#125; 替换空格-采用数组的方法因为java字符串是不可变的，所以也可以使用字符数组来解决这个问题。 处理字符串的时候，常见做法是从尾部开始编辑，从后往前反向操作。这种做法很有用，因为字符串尾部有额外的缓冲，可以直接修改，不必担心会覆写原有数据。采用上面的做法，进行两次扫描，第一次扫描先数出字符串中有多少空格，从而计算出最终的字符串有多长。第二次扫描才真正开始反向编辑字符串。检测到空格则将%20复制到下一个位置，若不是空白，就复制原先的字符。 替换空格-采用数组的方法12345678910111213141516171819202122public void replaceSpace(char[] str, int length) &#123; int spaceCount = 0; int newLength; for (int i = 0; i &lt; length; i++) &#123; if (str[i] == ' ') &#123; spaceCount++; &#125; &#125; newLength = length + spaceCount * 2; str[newLength] = '\0'; for (int i = length - 1; i &gt;= 0; i--) &#123; if (str[i] == ' ') &#123; str[newLength - 1] = '0'; str[newLength - 2] = '2'; str[newLength - 3] = '%'; newLength -= 3; &#125; else &#123; str[newLength - 1] = str[i]; newLength -= 1; &#125; &#125;&#125; 无序字母排序题目实现对一组无序的字母进行从小到大排序（区分大小写），当两个字母相同时，小写字母放在大写字母前。要求时间复杂度为O(n)。 思路：使用排序算法在最好的情况下的时间复杂度都在O(nlogn)，不满足题目要求。通常字母为26个，当区分大小写后，变成26*2=52个，所以申请长度为52的int型数组，按照aAbB…zZ(小写字母保存在下标为偶数的位置，大写字母保存在下标为奇数的位置)的顺序一次记录各个字母出现的次数，当记录完成后，就可以遍历这个数组按照各个字母出现的次数来重组排序后的数组。 实现无序字母排序123456789101112131415161718192021222324252627282930313233343536373839404142434445public class SortCharacters &#123; public static void main(String[] args) &#123; String s = "HappyBirthdayzLinkeRuIlikeyouazz"; char[] src = s.toCharArray(); sort(src); for (char ch : src) &#123; System.out.print(ch + " "); &#125; &#125; private static void sort(char[] src) &#123; if (src == null) &#123; System.out.println("参数不合法"); return; &#125; // 用于保存52个字符出现的次数，小写字母保存在下标为偶数的位置，大写字母保存在奇数位置 int[] charCount = new int[52]; for (int i = 0; i &lt; src.length; i++) &#123; // if (src[i] &gt;= 'a' &amp;&amp; src[i] &lt;= 'z') &#123; charCount[(src[i] - 'a') * 2]++; &#125; else if (src[i] &gt;= 'A' &amp;&amp; src[i] &lt;= 'Z') &#123; charCount[(src[i] - 'A') * 2 + 1]++; &#125; &#125; int index = 0; for (int i = 0; i &lt; charCount.length; i++) &#123; if (charCount[i] != 0) &#123; if (i % 2 == 0) &#123; // 小写字母 for (int j = 0; j &lt; charCount[i]; j++) src[index++] = (char) (i / 2 + 'a'); &#125; else &#123; // 大写字母 for (int j = 0; j &lt; charCount[i]; j++) src[index++] = (char) ((i - 1) / 2 + 'A'); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(4) 二维数组中的查找]]></title>
    <url>%2Fleetcode%2F2019%2F03%2F24%2Ffind-in-partially-sorted-matrix.html</url>
    <content type="text"><![CDATA[本文参考《剑指Offer》一书，代码采用Java实现。在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 二维数组中的查找题目在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路查找整数时，如果从左上角开始查找，情况较为复杂，可以转换思路，从右上角开始查找：左边数字比较小，右边数字比较大，容易进行判断。 当我们需要解决一个复杂的问题是，一个很有效的办法就是bong一个具体的问题入手，通过分析简单具体的例子，寻找普遍规律。 测试用例： 要查找的数字在数组中 要查找的数字不在数组中 数组为空 数组不满足大小规则 数组每行长度不一致 完整java代码及复杂度剑指Offer4 二维数组中的查找 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115public class FindInPartiallySortedMatrix &#123; /* * 判断二维数组matrix中是否含有整数a * 返回值为a的下标，&#123;-1，-1&#125;代表不存在 */ public int[] find(int[][] martrix, int a) &#123; int[] index = &#123;-1, -1&#125;; if (matrix == null || matrix.length &lt;= 0) &#123; System.out.println("数组无效"); return index; &#125; int columns = matrix[0].length; for (int i = 0; i &lt; matrix.length; i) &#123; if (matrix[i].length != columns) &#123; System.out.println("数组列数不一致"); return index; &#125; for (int j = 0; j &lt; matrix[i].length; j++) &#123; if (i == 0 &amp;&amp; j == 0) break; //matrix[0][0]不比较 if (i == 0) &#123; //第一行的数,仅和前一列比较 if (matrix[i][j] &lt; matrix[i][j - 1])&#123; System.out.print("数组中数字大小不符合要求")； return index; &#125; &#125; else if (j == 0) &#123; //第一列的，仅和前一行比较 if (matrix[i][j] &lt; matrix[i - 1][j]) &#123; System.out.print("数组中数字大小不符合要求")； return index; &#125; &#125; else if (matrix[i][j] &lt; matrix[i - 1][j] || matrix[i][j] &lt; matrix[i][j - 1])&#123; System.out.print("数组中数字大小不符合要求")； return index; &#125; &#125; &#125; //查找过程 int row = 0; //行数 int col = matrix[0].length - 1; //列数 while (row &lt;= matrix.length - 1 &amp;&amp; col &gt;= 0) &#123; if (a == matrix[row][col]) &#123; index[0] = row; index[1] = col; System.out.println("数字" + a + "在二维数组中的下标为： " + index[0] + ", " + index[1]); return index; &#125; else if (a &lt; matrix[row][col]) &#123; col--; &#125; else &#123; row++; &#125; &#125; System.out.println("数组中不含数字" + a); return index; &#125; // 1 2 8 9 // 2 4 9 12 // 4 7 10 13 // 6 8 11 15 // 要查找的数在数组中 public void test1() &#123; System.out.print("test1："); int[][] matrix = &#123; &#123; 1, 2, 8, 9 &#125;, &#123; 2, 4, 9, 12 &#125;, &#123; 4, 7, 10, 13 &#125;, &#123; 6, 8, 11, 15 &#125; &#125;; int[] index = find(matrix, 7); &#125; // 1 2 8 9 // 2 4 9 12 // 4 7 10 13 // 6 8 11 15 // 要查找的数不在数组中 public void test2() &#123; System.out.print("test2："); int[][] matrix = &#123; &#123; 1, 2, 8, 9 &#125;, &#123; 2, 4, 9, 12 &#125;, &#123; 4, 7, 10, 13 &#125;, &#123; 6, 8, 11, 15 &#125; &#125;; int[] index = find(matrix, 5); &#125; // 数组为空 public void test3() &#123; System.out.print("test3："); int[][] matrix = null; int[] index = find(matrix, 7); &#125; // 1 2 8 9 // 4 3 9 12 // 4 7 10 13 // 6 8 11 15 // 数组不满足大小规则 public void test4() &#123; System.out.print("test4："); int[][] matrix = &#123; &#123; 1, 2, 8, 9 &#125;, &#123; 4, 3, 9, 12 &#125;, &#123; 4, 7, 10, 13 &#125;, &#123; 6, 8, 11, 15 &#125; &#125;; int[] index = find(matrix, 7); &#125; // 数组每行长度不一致 public void test5() &#123; System.out.print("test5："); int[][] matrix = &#123; &#123; 1, 2, 8 &#125;, &#123; 4, 3, 9, 12 &#125;, &#123; 4, 7, 10 &#125;, &#123; 6, 8, 11, 15 &#125; &#125;; int[] index = find(matrix, 7); &#125; public static void main(String[] args) &#123; FindInPartiallySortedMatrix f = new FindInPartiallySortedMatrix(); f.test1(); // 注意下标是从0开始的 f.test2(); f.test3(); f.test4(); f.test5(); &#125;&#125; 不含测试代码(简化版)上面代码考虑了数组数字大小不符合规则的情况，较为繁琐。 剑指Offer4 二维数组中的查找(简化版)12345678910111213141516171819public class Solution &#123; public boolean Find(int target, int[][] array) &#123; if (array == null || array.length &lt;= 0) return false; int row = 0; int col = array[0].length - 1; while (row &lt;= array.length - 1 &amp;&amp; col &gt;= 0) &#123; if (target == array[row][col]) &#123; return false; &#125; else if (target &lt; array[row][col]) &#123; col--; &#125; else &#123; row++; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>matrix search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(3) 数组中重复的数字]]></title>
    <url>%2Fleetcode%2F2019%2F03%2F21%2Fduplication-in-array.html</url>
    <content type="text"><![CDATA[本文参考《剑指Offer》一书，代码采用Java实现。题目一：在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 题目二：在一个长度为n+1的数组里的所有数字都在1到n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。 本文的两道题解题思路是不一样的，具体事项见正文。 找出数组中重复数字题目在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是重复的数字2或者3。 思路：从哈希表的思路拓展，重排数组：把扫描的每个数字（如数字m）放到其对应下标（m下标）的位置上，若同一位置有重复，则说明该数字重复。 （在动手写代码前应该先想好测试用例）测试用例： 数组中带有一个或多个重复数字 数组中不包含重复数字 无效输入测试用例（空数组、数组数字越界等） 完整Java代码及复杂度复杂度：时间复杂度： O(n)空间复杂度： O(1) 尽管有两重循环，但是每个数字最多只要交换两次就能找到属于它的位置，因此钟的时间按复杂度是O(n)。另外所有操作时在输入数组上进行的，不需要分配内存，空间复杂度是O(1)。 含测试代码剑指Offer3 找出数组中重复数字1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class FindDuplicateNumber1 &#123; public int getDuplicate(int[] arr) &#123; if (arr == null || arr.length &lt;= 0) &#123; System.out.println("数组输入无效"); return -1; &#125; for (int a : arr) &#123; if (a &lt; 0 || a &gt; arr.length - 1) &#123; System.out.println("数字大小超出范围"); return -1; &#125; &#125; int tmp = 0; for (int i = 0; i &lt; arr.length; i++) &#123; while (arr[i] != i) &#123; if (arr[arr[i]] = arr[i]) &#123; return arr[i]; &#125; tmp = arr[i]; arr[i] = arr[tmp]; arr[tmp] = tmp; &#125; &#125; System.out.println("数组中无重复数字"); return -1; &#125; /** *数组为null */ public void test1() &#123; System.out.print("test1："); int[] a = null; int dup = getDuplicate(a); if (dup &gt;= 0) System.out.println("重复数字为：" + dup); &#125; /** * 数组无重复数字 */ public void test2() &#123; System.out.print("test2："); int[] a = &#123; 0, 1, 2, 3 &#125;; int dup = getDuplicate(a); if (dup &gt;= 0) System.out.println("重复数字为：" + dup); &#125; /** * 数组数字越界 */ public void test3() &#123; System.out.print("test3："); int[] a = &#123; 1, 2, 3, 4 &#125;; int dup = getDuplicate(a); if (dup &gt;= 0) System.out.println("重复数字为：" + dup); &#125; /** * 数组带重复数字 */ public void test4() &#123; System.out.print("test4："); int[] a = &#123; 1, 2, 3, 2, 4 &#125;; int dup = getDuplicate(a); if (dup &gt;= 0) System.out.println("重复数字为：" + dup); &#125; public static void main(String[] args) &#123; FindDuplicateNumber1 f = new FindDuplicateNumber1(); f.test1(); f.test2(); f.test3(); f.test4(); &#125;&#125; 不含测试代码（牛客网提交）牛客网提交12345678910111213141516171819202122232425public class Solution &#123; public boolean duplication(int[] numbers, int length, int[] duplication) &#123; if (numbers == null || numbers.length &lt;= 0) return false; for (int a : numbers) &#123; if (a &lt; 0 || ａ &gt;= length) return false; &#125; int tmp; for (int i = 0 ; i &lt; length; i++) &#123; while (numbers[i] != i) &#123; if (numbers[numbers[i]] == numbers[i]) &#123; duplication[0] = numbers[i]; return true; &#125; tmp = numbers[i]; numbers[i] = numbers[tmp]; numbers[tmp] = tmp; &#125; &#125; return false; &#125;&#125; 不修改数组找出数组中重复数字题目在一个长度为n+1的数组里的所有数字都在1到n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2, 3, 5, 4, 3, 2, 6, 7}，那么对应的输出是重复的数字2或者3。 思路：数组长度为n+1，而数字只从1到n， —说明必定有重复数字—。可以由二分查找法拓展：把1~n的数字从中间数字m分成两部分，若前一半1~m的数字数目超过m个，说明重复数字在前一半区间，否则，在后半区间m+1~n。每次在区间中都一分为二，知道找到重复数字。 更简单的思路：把该数组看作一个链表，下标代表当前结点，值代表next指针。 测试用例： 数组中带有一个或多个重复数字 数组中不包含重复的数字(题目设置必有重复) 无效输入测试用例（空数组、数组数字越界等） 代码时间复杂度说明：函数countRange()将被调用O(logn)次，每次需要O(n)的时间。 时间复杂度：O(nlogn) （while循环为O(logn)，coutRange()函数为O(n)） 空间复杂度：O(1) 剑指Offer4 不修改数组找到重复数字12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public class FindDuplicateNumber2 &#123; /** * 找到数组中一个重复的数字 * 返回-1代表无重复数字或者输入无效 */ public int getDuplicate(int[] arr) &#123; if (arr == null || arr.lenght &lt;= 0) &#123; System.out.println("数组输入无效！"); return -1; &#125; for (int a : arr) &#123; if (a &lt; 1 || a &gt; arr.length - 1) &#123; System.out.println("数字大小超出范围！"); return -1; &#125; &#125; int low = 0; int high = arr.length - 1; //为题目中的n int mid, count; while (low &lt;= high) &#123; mid = low + ((high - low) &gt;&gt; 1); count = countRange(arr, low, mid); if (low == high) &#123; if (count &gt; 1) return low; else break; &#125; if (count &gt; mid - low + 1) &#123; high = mid; &#125; else &#123; low = mid + 1; &#125; &#125; return -1; &#125; /** * 返回在[low,high]范围中数字的个数 */ public int countRange(int[] arr, int low, int high) &#123; if (arr == null) return 0; int count = 0; for (int a : arr) &#123; if (a &gt;= low &amp;&amp; a &lt;= high) &#123; count++; &#125; &#125; return count; &#125;/** *数组为null */ public void test1() &#123; System.out.print("test1："); int[] a = null; int dup = getDuplicate(a); if (dup &gt;= 0) System.out.println("重复数字为：" + dup); &#125; /** *数组数字越界 */ public void test2() &#123; System.out.print("test2："); int[] a = &#123; 1, 2, 3, 4 &#125;; int dup = getDuplicate(a); if (dup &gt;= 0) System.out.println("重复数字为：" + dup); &#125; /** *数组带重复数字 */ public void test3() &#123; System.out.print("test3："); int[] a = &#123; 1, 2, 3, 2, 4 &#125;; int dup = getDuplicate(a); if (dup &gt;= 0) System.out.println("重复数字为：" + dup); &#125; public static void main(String[] args) &#123; FindDuplicateNumber2 f2 = new FindDuplicateNumber2(); f2.test1(); f2.test2(); f2.test3(); &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(2) 实现Singleton模式]]></title>
    <url>%2Fleetcode%2F2019%2F03%2F21%2Fsingleton.html</url>
    <content type="text"><![CDATA[饿汉模式不会出现产生多个实例的情况，见单例模式的通用代码。懒汉模式在volatile关键字修饰后，使用双重锁机制，可以解决多个实例被构建的情况，以及由于指令重排而导致的返回一个没有初始化完成的singleton对象。 实现单例模式的手段非常多，还有通过静态内部类实现的方法。 但是上述方法存在共同的问题： 无法防止利用反射来重复构建对象。 阻止反射的构建方式是使用枚举类型，有了enum语法糖，JVM会阻止反射获取枚举类的私有构造方法。 最后还有使用工厂方法模式替代单例模式，当然，其他类也可以通过反射的方式构建一个单例模式。 本文还简单的总结了volatile的两种语义的使用。 DPModel中单例模式单例模式的通用代码(线程安全)如果单例初始值是null，还未构建，则构建单例对象并返回。这个写法属于单例模式当中的懒汉模式。如果单例对象一开始就被new Singleton()主动构建，则不再需要判空操作，这种写法属于饿汉模式。 单例模式的通用代码(饿汉模式)123456789101112131415public class Singleton &#123; private static Singleton singleton = new Singleton(); private Singleton()&#123; &#125; public static Singleton getInstance() &#123; return singleton; &#125; public static void doSomething() &#123; &#125;&#125; 线程不安全的单例模式 假设Singleton类刚刚被初始化，singleton对象还是空，这时候两个线程同时访问getInstance方法 因为singleton对象为空，所以两个线程同时通过了条件判断，开始执行new操作 这样一来，显然instance被构建了两次。 线程不安全的单例(懒汉模式)123456789101112public class Singleton &#123; private static Singleton singleton = null; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; return singleton; &#125;&#125; 单例模式第二版(双重检测机制)单例模式第二版两次判空的机制叫做双重检测机制。 但是不是绝对的安全！！！双重检测123456789101112131415161718public class Singleton &#123; private static Singleton singleton = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; //双重检测 synchronized (Singleton.class) &#123; //同步锁 if (singleton == null) &#123; //双重检测 singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 为了防止new Singleton被执行多次，因此在new操作之前加上Synchronized 同步锁，锁住整个类（注意，这里不能使用对象锁）； 进入Synchronized 临界区以后，还要再做一次判空。因为当两个线程同时访问的时候，线程A构建完对象，线程B也已经通过了最初的判空验证，不做第二次判空的话，线程B还是会再次构建instance对象。 隐藏的漏洞(指令重排)！！！！隐藏的漏洞假设这样的场景，当两个线程一先一后访问getInstance方法的时候，当A线程正在构建对象，B线程刚刚进入方法。这种情况表面看似没什么问题，要么singleton还没被线程A构建，线程B执行 if（singleton == null）的时候得到true；要么singleton已经被线程A构建完成，线程B执行 if（singleton == null）的时候得到false。 真的如此吗？答案是否定的。这里涉及到了JVM编译器的 指令重排。 指令重排是什么意思呢？比如java中简单的一句 singleton = new Singleton，会被编译器编译成如下JVM指令： memory =allocate(); //1：分配对象的内存空间ctorInstance(memory); //2：初始化对象singleton =memory; //3：设置instance指向刚分配的内存地址 但是这些指令顺序并非一成不变，有可能会经过JVM和CPU的优化，指令重排成下面的顺序： memory =allocate(); //1：分配对象的内存空间singleton =memory; //3：设置instance指向刚分配的内存地址ctorInstance(memory); //2：初始化对象 当线程A执行完1,3,时，singleton对象还未完成初始化，但已经不再指向null。此时如果线程B抢占到CPU资源，执行 if（singleton == null）的结果会是false，从而返回一个 没有初始化完成的singleton对象。 如何避免这一情况呢？我们需要在instance对象前面增加一个 修饰符volatile。 单例模式第三版(volatile关键字加双重检测)volatile实现123456789101112131415161718public class Singleton &#123; private volatile static Singleton singleton = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; //双重检测机制 synchronized (Singleton.class) &#123; //同步锁 if (singleton == null) &#123; //双重检测机制 singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 经过volatile的修饰，当线程A执行singleton = new Singleton的时候，JVM执行顺序是什么样？始终保证是下面的顺序： memory =allocate(); //1：分配对象的内存空间ctorInstance(memory); //2：初始化对象singleton =memory; //3：设置instance指向刚分配的内存地址 如此在线程B看来，singleton对象的引用要么指向null，要么指向一个初始化完毕的Singleton，而不会出现某个中间态，保证了安全。 静态内部类实现方式1234567891011121314public class Singleton &#123; private static class LazyHolder &#123; private static final Singleton SINGLETON = new Singleton(); &#125; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return LazyHolder.SINGLETON; &#125;&#125; 这里有几个需要注意的点： 从外部无法访问静态内部类LazyHolder，只有当调用Singleton.getInstance方法的时候，才能得到单例对象SINGLETON。 SINGLETON对象初始化的时机并不是在单例类Singleton被加载的时候，而是在调用getInstance方法，使得静态内部类LazyHolder被加载的时候。因此这种实现方式是利用 classloader的加载机制来实现懒加载，并保证构建单例的线程安全。 !!!!缺点：无法防止利用反射来重复构建对象。 这也是单例模式共同的问题。 使用工厂方法模式(利用反射打破单例)单例类1234567public static Singleton &#123; private Singleton() &#123; &#125; public void doSomething&#123; &#125;&#125; 通过反射方式创建单例的工厂类12345678910111213141516171819public class SingeltonFactory &#123; private static Singleton singleton; static &#123; try &#123; Class c1 = Class.forName(singleton.class.getName()); Constructor constructor = c1.getDeclaredConstructor(); constructor.setAccessible(true); singleton = (Singleton) constructor.newInstance(); &#125; catch (Exception e) &#123; // 异常处理 &#125; &#125; public static Singleton getInstance() &#123; return singleton; &#125;&#125; 123456789//获得构造器Constructor con = Singleton.class.getDeclaredConstructor();//设置为可访问con.setAccessible(true);//构造两个不同的对象Singleton singleton1 = (Singleton)con.newInstance();Singleton singleton2 = (Singleton)con.newInstance();//验证是否是不同对象System.out.println(singleton1.equals(singleton2)); 代码可以简单归纳为三个步骤： 第一步，获得单例类的构造器。第二步，把构造器设置为可访问。第三步，使用newInstance方法构造对象。 最后为了确认这两个对象是否真的是不同的对象，我们使用equals方法进行比较。毫无疑问，比较结果是false。 无懈可击的单例模式(枚举类实现)123public enum SingletonEnum &#123; SINGLETON;&#125; 让我们来做一个实验，仍然执行刚才的反射代码： 123456789//获得构造器Constructor con = SingletonEnum.class.getDeclaredConstructor();//设置为可访问con.setAccessible(true);//构造两个不同的对象SingletonEnum singleton1 = (SingletonEnum)con.newInstance();SingletonEnum singleton2 = (SingletonEnum)con.newInstance();//验证是否是不同对象System.out.println(singleton1.equals(singleton2)); 执行获得构造器这一步的时候，抛出了异常。 唯一的缺点是，并非适用懒加载，其单例对象是在枚举类被加载的时候进行初始化的。 单例模式实现简单总结 单例模式实现 是否线程安全 是否懒加载 是否防止反射构建 双重锁检测(第三版) 是 是 否 静态内部类 是 是 否 枚举 是 否 是 几点补充： volatile关键字不但可以防止指令重排，也可以保证线程访问的变量值是主内存中的最新值。 使用枚举实现的单例模式，不但可以防止利用反射强行构建单例对象，而且可以在枚举类对象被反序列化的时候，保证反序列的返回结果是同一对象。 对于其他方式实现的单例模式，如果既想要做到可序列化，又想要反序列化为同一对象，则必须实现readResolve方法。 枚举C/C++ 的枚举类型是int类型常量值，不安全。 java在1.5 加入枚举。 枚举是类，枚举常量是类的对象，在枚举类外无法创建枚举对象，可以保证枚举的类型安全性 所有的枚举类都继承自java.lang.Enum，并且所有的枚举类都声明为final，每个枚举常量都声明为public static final，我们不能显示地继承Enum类 枚举类实例初始化中不能访问静态变量（枚举类特殊初始化方式：构造器先于静态初始化） volatile关键字Java内存模型Java内存模型简称JMM（Java Memory Model），是Java虚拟机所定义的一种抽象规范，用来屏蔽不同硬件和操作系统的内存访问差异，让java程序在各种平台下都能达到一致的内存访问效果。 主内存（Main Memory）主内存可以简单理解为计算机当中的内存，但又不完全等同。主内存被所有的线程所共享，对于一个共享变量（比如静态变量，或是堆内存中的实例）来说，主内存当中存储了它的“本尊”。 工作内存（Working Memory）工作内存可以简单理解为计算机当中的CPU高速缓存，但又不完全等同。每一个线程拥有自己的工作内存，对于一个共享变量来说，工作内存当中存储了它的“副本”。 线程对共享变量的所有操作都必须在工作内存进行，不能直接读写主内存中的变量。不同线程之间也无法访问彼此的工作内存，变量值的传递只能通过主内存来进行。 volatile关键字具有许多特性，其中最重要的特性就是保证了 用volatile修饰的变量对所有线程的可见性。 为什么volatile关键字可以有这样的特性？这得益于java语言的先行发生原则（happens-before）。在计算机科学中，先行发生原则是两个事件的结果之间的关系，如果一个事件发生在另一个事件之前，结果必须反映，即使这些事件实际上是乱序执行的（通常是优化程序流程）。这里所谓的事件，实际上就是各种指令操作，比如读操作、写操作、初始化操作、锁操作等等。先行发生原则作用于很多场景下，包括同步锁、线程启动、线程终止、volatile。 volatile关键字只能保证变量的可见性，并不能保证变量的原子性。 不能保证线程安全！因此，什么时候适合用volatile呢？ 运行结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。 变量不需要与其他的状态变量共同参与不变约束。 指令重排指令重排是指JVM在编译Java代码的时候，或者CPU在执行JVM字节码的时候，对现有的指令顺序进行重新排序。指令重排的目的是为了在不改变程序执行结果的前提下，优化程序的运行效率。需要注意的是，这里所说的不改变执行结果，指的是不改变单线程下的程序执行结果。然而，指令重排是一把双刃剑，虽然优化了程序的执行效率，但是在某些情况下，会影响到多线程的执行结果。 内存屏障内存屏障（Memory Barrier）是一种CPU指令。内存屏障也称为内存栅栏或栅栏指令，是一种屏障指令，它使CPU或编译器对屏障指令之前和之后发出的内存操作执行一个排序约束。 这通常意味着在屏障之前发布的操作被保证在屏障之后发布的操作之前执行。内存屏障共分为四种类型： LoadLoad屏障 StoreStore屏障 LoadStore屏障 StoreLoad屏障 volatile做了什么？在一个变量被volatile修饰后，JVM会为我们做两件事： 在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障。 在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障。 两种语义volatile特性之一： 保证变量在线程之间的可见性。可见性的保证是基于CPU的内存屏障指令，被JSR-133抽象为happens-before原则。 volatile特性之二：阻止编译时和运行时的指令重排。编译时JVM编译器遵循内存屏障的约束，运行时依靠CPU屏障指令来阻止重排。 几点补充： 关于volatile的介绍，本文很多内容来自《深入理解Java虚拟机》这本书。 在使用volatile引入内存屏障的时候，普通读、普通写、volatile读、volatile写会排列组合出许多不同的场景。 volatile除了保证可见性和阻止指令重排，还解决了long类型和double类型数据的8字节赋值问题。这个特性相对简单，本文就不详细描述了。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>DPModel</tag>
        <tag>Singleton</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划前瞻]]></title>
    <url>%2Fleetcode%2F2019%2F03%2F20%2Foutpost-of-DP.html</url>
    <content type="text"><![CDATA[Those who cannot remember the past are condemned to repeat it.-Dynamic Programming. 动态规划定义动态规划（dynamic programming）是通过组合子问题而解决整个问题的解。 分治法是将问题划分成一些独立的子问题，递归地求解各子问题，然后合并子问题的解。 动态规划适用于子问题不是独立的情况，也就是各子问题包含公共的子子问题。此时，分治法会做许多不必要的工作，即重复地求解公共的子问题。动态规划算法对每个子问题只求解一次，将其结果保存起来，从而避免每次遇到各个子问题时重新计算答案。 适用范围最优性原理体现为问题的最优子结构特性。当一个问题的最优解中包含了子问题的最优解时，则称该问题具有最优子结构特性。最优性原理是动态规划的基础。任何一个问题，如果失去了这个最优性原理的支持，就不可能用动态规划设计求解。 问题中的状态满足最优性原理。 问题中的状态必须满足无后效性。 所谓无后效性是指：“下一时刻的状态只与当前状态有关，而和当前状态之前的状态无关，当前状态是对以往决策的总结”。 首先，动态规划方法适合的题型4个基本特点是： 最优子结构，当前一个状态得到最佳解时，当前状态在前一个状态下一定有最佳解； 子问题重叠，每个状态下要解决的问题除参数不同外，其本质是一样的； 有边界，当解决了最后一个子问题时，整个问题得解； 子问题独立，解决一个子问题时不依赖于另一个同级的子问题，只与它的母问题有关。 动态规划的设计两种方法： 自顶向下（又称记忆化搜索、备忘录）：基本上对应着递归函数实现，从大范围开始计算，要注意不断保存中间结果，避免重复计算 自底向上（递推）：从小范围递推计算到大范围 一般分为两个步骤： 问题建模 求解问题 核心元素有三个核心元素： 最优子结构 边界 状态转移方程 总结DP算法的思路核心: 最优子结构、边界条件、状态转移方程 解题步骤: 1.建立数学模型 2.写代码求解问题 如何建模?先写出所求问题的最优子结构,进而分析出边界和状态转移方程，数学模型即这2者的组合，对于2输入维度动态规划，画表格帮助分析，行列分别代表1个输入维度 如何求解? 建好模后，根据方程组写出自底向上的动态规划代码，一维输入就是1个for循环，二维输入就是2个for循环，如果方程组比较抽象，可以画表格帮助分析 棋盘问题问题寻找一条从左上角（arr[0][0]）到右下角（arr[m - 1][n - 1]）的路线，使得沿途经过的数组中的整数和最小。 递归算法从右下角倒着分析，最后一步到达arr[m - 1][n - 1]只有两条路径，即通过arr[m - 2][n - 1]或arr[m - 1][n - 2]到达。推广到一半的情况，假设到达arr[i - 1][j]与arr[i][j - 1]的最短路径的和为f(i - 1, j)和f(i, j - 1)，那么到达arr[i][j]的路径上所有数字和的最小值为 f(i, j) = min{f(i - 1, j), f(i, j - 1)} + arr[i][j] 递归方法实现效率太低，有大量重复计算过程。 动态规划算法动态规划其实是一种空间换时间的算法，通过缓存计算的中间值，减少重复计算的次数，从而提高算法的效率。递归从arr[m - 1][n - 1]开始逆向通过递归来求解，采用动态规划可以自底向上求解，以便使用前面计算出来的结果。对于本题而言，显然有边界条件，f(i, 0) = arr[0][0] + arr[i][0]， f(0, j) = arr[0][0] + arr[0][j]。状态转移方程： f(i, j) = min{f(i - 1, j), f(i, j - 1)} + arr[i][j] 可以把遍历过程中求出所有的f(i, j)的值，保存到另一个二维数组中供后续使用。 数组和最小的路线1234567891011121314151617181920212223242526272829303132333435public class Test &#123; public static int getMinPath() &#123; if (arr == null || arr.lenth == 0) return 0; int row = arr.length; int col = arr[0].length; int[][] cache = new int[row][col]; for (int i = 1; i &lt; row; i++) cache[i][0] = cache[i-1][0] + arr[i][0]; for (int j = 1; j &lt; col; j++) cache[0][j] = cache[0][j-1] + arr[0][j]; for (int i = 1; i &lt; row; i++) &#123; for (int j = 1; j &lt; col; j++) &#123; //可以确定选择的路线为arr[i-1][j] if (arr[i-1][j] &lt; arr[i][j-1]) &#123; cache[i][j] = cache[i-1][j] + arr[i][j]; System.out.print("[" + (i - 1) + ", " + j + "] "); &#125; else &#123; cache[i][j] = cache[i][j-1] + arr[i][j]; System.out.print("[" + i + ", " + (j - 1) + "] "); &#125; &#125; &#125; System.out.println("[" + (row - 1) + ", " + (col - 1) + "]"); return cache[row - 1][col - 1]; &#125; public static void main(String[] args) &#123; int[][] arr = &#123;&#123;1,4,3&#125;, &#123;8,7,5&#125;, &#123;2,1,5&#125;&#125;; System.out.print("路径： ")； System.out.println("最小值为： " + getMinPath(arr)); &#125;&#125; 对二维数组遍历一次，时间复杂度为O(mn)，申请了一个二维数组来保存中间结果，空间复杂度为O(mn)。 国王与金矿知道 i-1 座金矿的最大产量就一定能知道 i 座金矿的最大产量，这是 最优子结构，每个人要知道i座金矿的最大产量就必须知道知道 i-1 座金矿的最大产量，这是 子问题重叠，最终当考虑第 1 座金矿的最大产量时，只要看是否有足够人手开采第 1 座金矿，有的话，答案是已探明的储量，没有的话就是0，然后答案汇报到上级，上级再得出第 2 座金矿开采与不开采得出的较大产量，再往上汇报…，这就是 边界，而每个人从上级得到的前提都是不同的，上级决定开不开采，再将这个前提之一告诉下属，而下属不需要考虑上级给另一个下属什么前提，这是 子问题独立。 把金矿数量设为n，工人数量设为w，金矿的黄金量设为g[]，金矿的用工量设为p[]。F(n, w) = 0 (n &lt;= 1, w &lt; p[0]);F(n, w) = g[0] (n == 1, w &gt;= p[0]);F(n, w) = F(n - 1, w) (n &gt; 1, w &lt; p[n - 1]);F(n, w) = max(F(n - 1, w)， F(n - 1, w - p[n - 1]) + g[n - 1]) (n &gt; 1, w &gt;= p[n-1]); 递归算法把状态转移方程翻译成递归程序，递归结束条件是方程中的边界。 因为每个状态有两个最优子结构，所以递归的执行流程类似于一棵高度为N的二叉树。 时间复杂度为O(2^n)。 递归解法123456789101112131415161718public static int getMostGold(int n, int w, int[] g, int[] p) &#123; if (n &gt; g.length) throw new RuntimeException("输入的n值大于给定的金矿数"); if (n &lt;= 1 &amp;&amp; w &lt; p[0]) return 0; if (n == 1 &amp;&amp; w &gt;= p[0]) return g[0]; if (n &gt; 1 &amp;&amp; w &lt; p[n-1]) return getMostGold(n-1, w, g, p); int a = getMostGold(n-1, w, g, p); int b = getMostGold(n-1, w - p[n-1], g, p) + g[n-1]; return Math.max(a, b); &#125; DP解法画表格分析，表格第一列代表给定前1-5做金矿的情况，也就是N的取值。表格第一行代表给定的工人数，也就是w的取值。其余空白格表示，给定n和w值对应的黄金获得数，也就是F(n,w)。 1工人 2工人 3工人 4工人 5工人 6工人 7工人 8工人 9工人 10工人 1金矿 2金矿 3金矿 4金矿 5金矿 第一个金矿的信息：400金，5工人 1工人 2工人 3工人 4工人 5工人 6工人 7工人 8工人 9工人 10工人 1金矿 0 0 0 0 400 400 400 400 400 400 2金矿 3金矿 4金矿 5金矿 第二个金矿的信息：500金，5工人根据F(n,w) = Max(F(n-1, w), F(n-1, w-5) + 500)， 5-9格子为500，第2行第10个格子，n=2，w=10 F(n-1, w-5) = 400 Max(400, 400+500) = 900 1工人 2工人 3工人 4工人 5工人 6工人 7工人 8工人 9工人 10工人 1金矿 0 0 0 0 400 400 400 400 400 400 2金矿 0 0 0 0 500 500 500 500 500 900 3金矿 4金矿 5金矿 第三个金矿的信息：200金，3工人 根据F(n,w) = Max(F(n-1, w), F(n-1, w-5) + 200) 1工人 2工人 3工人 4工人 5工人 6工人 7工人 8工人 9工人 10工人 1金矿 0 0 0 0 400 400 400 400 400 400 2金矿 0 0 0 0 500 500 500 500 500 900 3金矿 0 0 200 200 500 500 500 700 700 900 4金矿 5金矿 第四个金矿的信息：300金，4工人 根据F(n,w) = Max(F(n-1, w), F(n-1, w-5) + 300) 1工人 2工人 3工人 4工人 5工人 6工人 7工人 8工人 9工人 10工人 1金矿 0 0 0 0 400 400 400 400 400 400 2金矿 0 0 0 0 500 500 500 500 500 900 3金矿 0 0 200 200 500 500 500 700 700 900 4金矿 0 0 200 300 500 500 500 700 800 900 5金矿 第五个金矿的信息：350金，3工人 根据F(n,w) = Max(F(n-1, w), F(n-1, w-5) + 350) 1工人 2工人 3工人 4工人 5工人 6工人 7工人 8工人 9工人 10工人 1金矿 0 0 0 0 400 400 400 400 400 400 2金矿 0 0 0 0 500 500 500 500 500 900 3金矿 0 0 200 200 500 500 500 700 700 900 4金矿 0 0 200 300 500 500 500 700 800 900 5金矿 0 0 350 350 500 550 650 850 850 900 上述表格，比如5金矿10工人的结果，来自于4金矿7工人和4金矿10工人， Max(900, 500+350)=900 不需要存储整个表格，只需要存储前一行的结果，就可以推导出新的一行。使用动态规划如下： DP解法123456789101112131415161718192021222324252627282930313233343536373839404142434445int getMostGold(int n, int w, int[] g, int[] p) &#123; if (n &gt; g.length) throw new RuntimeException("输入的n值大于给定的金矿数")； if (w &lt; 0) throw new RuntimeException("输入的工人数w不能为负数")； if (n &lt; 1 || w == 0) reurn 0; int col = w + 1; int[] preResults = new in[col]; int[] results = new int[col]; //填充边界格子的值 (边界) for (int i = 0; i &lt; col; i++) &#123; if (i &lt; p[0]) &#123; preResults[i] = 0; &#125; else &#123; preResults[i] = g[0]; &#125; &#125; if (n == 1) &#123; return preResults = g[0]; &#125; //填充其余格子的值，外层循环是金矿的数量(递推的轮次)，内层循环是工人数 for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; if (j &lt; p[1]) &#123; results[j] = preResults[j]; &#125; else &#123; results[j] = Math.max(preResults[j], reResults[j-p[i]] + g[i]); &#125; &#125; for (int j = 0; j &lt; col; j++) &#123; //更新上一行的值，为下一轮递推做准备 preResults[j] = results[j]; &#125; /* preResults = results; * 这样赋值会导致preResults和results指向同一个数组， *在下一轮循环中改变results中的值也改变了preResults中的值 */ &#125; return results[w];&#125; 上述方法利用两层迭代，外层迭代对表格每一行的迭代过程中，会保留上一行的结果数组preResults，并循环计算当前的结果数组results。方法的时间复杂度为O(n*w)，空间复杂度是O(w)。当金矿更多的时候，动态规划的优势就能体现出来。 然而，当工人为1000时，动态规划的时间复杂度为5 * 1000 = 5000，开辟1000单位的空间。 递归的时间复杂度是O(2^n)，需要计算32次，开辟5单位（递归深度）的空间。 动态规划方法的时间和空间都和w成正比，而简单递归和w无关，所以工人很多的时候，动规反而不如递归。 所以说，每一种算法都没有绝对的好与坏，关键看应用场景。 备忘录解法备忘录解法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// 该内部类对象用于备忘录算法中作为HashMap存储的键private static class Input &#123; private int n; private int w; public Input(int n, int w) &#123; super(); this.n = n; this.w = w; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + n; result = prime * result + w; return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Input other = (Input) obj; if (n != other.n) return false; if (w != other.w) return false; return true; &#125;&#125; // 备忘录算法解法public static int getMostGold2(int n, int w, HashMap&lt;Input, Integer&gt; map, int[] g, int[] p) &#123; if (n &gt; g.length) throw new RuntimeException("输入的n值大于给定的金矿数"); if (n &lt;= 1 &amp;&amp; w &lt; p[0]) return 0; if (n == 1 &amp;&amp; w &gt;= p[0]) return g[0]; if (n &gt; 1 &amp;&amp; w &lt; p[n-1]) &#123; Input input = new Input(n-1, w); if (map.containsKey(input)) return map.get(input); int value = getMostGold2(n-1, w, map, g, p); map.put(input, value); return value; &#125; Input input1 = new Input(n-1, w); Input input2 = new Input(n-1, w-p[n-1]); int a = 0; //用于记录F(n-1,w)的值 int b = 0; //用于记录F(n-1,w-p[n-1])+g[n-1])的值 if (map.containsKey(input1)) a = map.get(input1); a = getMostGold2(n-1, w, map, g, p); map.put(input1, a); if (map.containsKey(input2)) b = map.get(input2) + g[n-1]; b = getMostGold2(n-1, w-p[n-1], map, g, p); map.put(input2, b); b += g[n-1]; return a &gt; b ? a : b;&#125;]]></content>
      <categories>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树]]></title>
    <url>%2Fleetcode%2F2019%2F03%2F16%2Fbinary-search-tree.html</url>
    <content type="text"><![CDATA[二叉搜索树（没有重复元素）的特征是：对于树中的每一个节点，它的左子树中的节点的值都小于该节点的值，而它的右子树中节点的值都大于该节点的值。 表示二叉搜索树二叉搜索树（Binary Search Tree, BST）可以用一个链式节点的集合来表示二叉树。 每个节点都包含一个数值和两个称为left和right的链接，分别指向左孩子和右孩子。树的节点类12345678910111213/** This inner class is static, because it does not access *any instance members defined in its outer class */public static class TreeNode&lt;E extends Comparable&lt;E&gt;&gt; &#123; protected E element; protected TreeNode&lt;E&gt; left; protected TreeNode&lt;E&gt; right; public TreeNode(E e) &#123; element = e; &#125;&#125; TreeNode&lt;Integer&gt; root = new TreeNode&lt;&gt;(60); 变量root指向根节点。如果树为空，root的值为null。 树的遍历二叉树分为根节点、左子树和右子树，分别表示为 +、1、2。二叉树本身是递归定义的，相应的遍历很自然就成为一种递归问题。 递归遍历操作的关键点是递归体和递归出口： 递归出口是二叉树的空子树或叶节点，此时为空操作，递归不继续进行，只能回退； 递归体是对二叉树根节点或左、右子树进行相应处理。 基于递归的遍历算法易于编写，操作简单，但可读性差，系统需要维护相应的工作栈，效率不是很高。递归转化为非递归的基本思想是如何实现原本是系统完成的递归工作栈，为此，可以仿照递归执行过程中工作栈状态变化而得到。 对二叉树进行前序、中序和后序遍历时都开始于根节点或结束于根节点，经由路线也相同。彼此差别在于对节点访问时机的选择不同。三种遍历方式都是沿着左子树不断深入下去，当到达二叉树左下节点而无法往下深入时，就向上逐一返回，行进到最近深入时曾遇到节点的右子树，然后进行同样的深入和返回，直到最终从根节点的右子树返回到根节点。这样，遍历时返回顺序与深入节点顺序恰好相反，因此可以在实现二叉树遍历过程中，使用一个工作栈来保存当前深入到的节点信息，以供后面返回需要时使用。 中序遍历(inorder traversal)遍历顺序为： 1+2 可以递增顺序显示BST中所有节点。中序遍历的黄金口诀：当前节点为空，从栈中弹出一个元素，当前节点向右移动；当前节点不为空，压栈，当前节点向左移动 中序遍历访问左子二叉树 访问根节点 中序遍历访问右子二叉树 inorder递归遍历1234567891011public void inorder() &#123; inorder(root); &#125;protected void inorder(TreeNode&lt;E&gt; root) &#123; if (root == null) return; inorder(root.left); // 递归遍历左子树 System.out.print(root.element + " "); // 递归遍历根节点 inorder(root.right); // 递归遍历右子树 1+2&#125; 中序非递归遍历1234567891011121314151617181920public void inorder() &#123; inorder(root);&#125;protected void inorder(TreeNode&lt;E&gt; root) &#123; if (root == null) return; java.util.Stack&lt;TreeNode&lt;E&gt;&gt; stack = new java.util.Stack&lt;&gt;(); TreeNode&lt;E&gt; current = root; while (!stack.empty() || current != null) &#123; if (current != null) &#123; stack.push(current); current = current.left; &#125; else &#123; TreeNode&lt;E&gt; node = stack.pop(); System.out.print(node.element + " "); current = node.right; &#125; &#125;&#125; 前序遍历(preorder traversal)+12 深度优先遍历法(depth-first traversal)与前序遍历法相同。 访问根节点 前序遍历访问左子二叉树 前序遍历访问右子二叉树 preorder递归遍历12345678910public void preorder() &#123; preorder(root);&#125;protected void preorder(TreeNode&lt;E&gt; root) &#123; if (root == null) return; System.out.println(root.element + " "); // 递归遍历根节点 preorder(root.left); // 递归遍历左子树 preorder(root.right); // 递归遍历右子树 +12&#125; 前序非递归遍历1234567891011121314151617181920212223public void preorder() &#123; preorder(root);&#125; protected void preorder(TreeNode&lt;E&gt; root) &#123; if (root == null) return; Stack&lt;TreeNode&lt;E&gt;&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.empty()) &#123; TreeNode&lt;E&gt; node = stack.pop(); System.out.print(node.element + " "); // Push the right child onto the stack // first so the left is processed first if (node.right != null) &#123; stack.push(node.right); &#125; if (node.left != null) &#123; stack.push(node.left); &#125; &#125;&#125; 后序遍历(postorder traversal)12+ 后序遍历访问左子二叉树 后序遍历访问右子二叉树 访问根节点 postorder递归遍历12345678910public void postorder() &#123; postorder(root);&#125;protected void postorder(TreeNode&lt;E&gt; root) &#123; if (root == null) return; postorder(root.left); // 递归遍历左子树 postorder(root.right); // 递归遍历右子树 System.out.println(root.element + " "); // 递归遍历根节点 12+&#125; 后序非递归遍历1234567891011121314151617181920212223242526272829public void postorder() &#123; postorder(root);&#125;protected void postorder(TreeNode&lt;E&gt; root) &#123; if (root == null) return; // Create two stacks Stack&lt;TreeNode&lt;E&gt;&gt; stack1 = new Stack&lt;&gt;(); Stack&lt;TreeNode&lt;E&gt;&gt; stack2 = new Stack&lt;&gt;(); // push root to stack1 stack1.push(root); while (!stack1.empty()) &#123; // Pop node from stack1 and push onto stack2 TreeNode&lt;E&gt; node = stack1.pop(); stack2.push(node); if (node.left != null) stack1.push(node.left); if (node.right != null) stack1.push(node.right); &#125; // Display elements in stack2 while (!stack2.empty()) &#123; System.out.print(stack2.pop().element + " "); &#125;&#125; 广度优先遍历(breadth-first traversal)广度优先遍历12345678910111213141516171819public void breadthFirstTraversal() &#123; if (root == null) return; // Queue Deque Linkedlist java.util.Queue&lt;TreeNode&lt;E&gt;&gt; queue = new java.util.LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) &#123; TreeNode&lt;E&gt; current = queue.element(); if (current.left != null) &#123; queue.add(current.left); &#125; if (current.right != null) &#123; queue.add(current.right); &#125; System.out.println(queue.remove().element + " "); &#125;&#125; 搜索一个元素二叉搜索树中搜索一个元素，可以从根节点向下扫描，知道找到匹配元素，或者达到一棵空子树为止。在BST中搜索一个元素12345678910111213public boolean search(E e) &#123; TreeNode&lt;E&gt; current = root; // 当前指针指向根节点 while (current != null) &#123; if (e.compareTo(current.element) &lt; 0) &#123; current = current.left; // 比当前指针的元素小，则往左 &#125; else if (e.compareTo(current.element) &gt; 0) &#123; current = current.right; // 比当前指针的元素大，则往右 &#125; else &#123; // 元素匹配 return true; // 找到元素 return true &#125; &#125; return false;&#125; 插入一个元素BST中插入一个元素，需要确定在书中插入的位置，关键思路是确定新节点的父节点所在的位置。 如果树是空的，使用新元素创建一个根节点； 否则，寻找新节点的父节点的位置 为该元素创建一个新节点，如果新元素的值小于父元素的值，左子节点；如果新元素的值大于父元素的值，右子节点；BST没有重复元素，重复则不插入 在BST中插入一个元素12345678910111213141516171819202122232425262728293031public boolean insert(E e) &#123; if (root == null) &#123; root = createNewNode(e); // 创建一个节点，树为空该节点成为根节点 &#125; else &#123; TreeNode&lt;E&gt; parent = null; // 定位父节点 TreeNode&lt;E&gt; current = root; // 当前指针指向根节点 while (current != null) &#123; if (e.compareTo(current.element) &lt; 0) &#123; parent = current; current = current.left; &#125; else if (e.compareTo(current.element) &gt; 0) &#123; parent = current; current = current.right; &#125; else &#123; return false; // 元素已经在树中，return false &#125; &#125; // 为元素e创建一个节点 if (e.compareTo(parent.element) &lt; 0) &#123; parent.left = createNewNode(e); &#125; else &#123; parent.right = createNewNode(e); &#125; &#125; size++; return true;&#125;public TreeNode&lt;E&gt; createNewNode(E e) &#123; return new TreeNode&lt;&gt;(e);&#125; 删除BST中的一个元素为了从一棵二叉搜索树中删除一个元素，首先需要定位该元素位置，然后再删除该元素以及重新连接树前，考虑两种情况–该节点有或者没有左子节点。情况1：当前节点没有左子结点。只需将该节点的父节点和该节点的右子节点相连。如果当前节点是叶子节点，属于情况1； 情况2：当前节点有左子结点。假设rightMost指向包含current节点的左子树中的最大元素的节点，而parentOfRightMost指向rightMost节点的父节点。使用rightMost节点中的元素替代current节点中的元素值，将parentOfRightMost节点和rightMost节点的左子节点相连，然后删除rightMost节点。 rightMost作为最大值不能有右节点，但是可能会有左子节点！从BST中删除一个元素1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public boolean delete(E e) &#123; // 如果current为root,那么parent为null TreeNode&lt;E&gt; parent = null; // 指向current节点的父节点 TreeNode&lt;E&gt; current = root; // 指向二叉搜索树中包含该元素的节点 while (current != null) &#123; // 递归寻找current节点 if (e.compareTo(current.element) &lt; 0) &#123; parent = current; current = current.left; &#125; else if (e.compareTo(current.element) &gt; 0) &#123; parent = current; current = current.right; &#125; else &#123; break; // 找到包含e的current节点 &#125; &#125; if (current == null) &#123; return false; // 元素不在树内 &#125; // 情况1：当前节点没有左子节点 if (current.left == null) &#123; //只需将该节点的父节点和该节点的右子节点相连 if (parent == null) &#123; root = current.right; &#125; else &#123; if (e.compareTo(parent.element) &lt; 0) &#123; parent.left = current.right; // e是父节点的左子结点 &#125; else &#123; parent.right = current.right; // e是父节点的右子结点 &#125; &#125; &#125; else &#123; // 情况2：当前节点有左子节点 TreeNode&lt;E&gt; parentOfRightMost = current; // rightMost节点的父节点 TreeNode&lt;E&gt; rightMost = current.left; // 当前节点的左子树最右端的节点 while (rightMost.right != null) &#123; parentOfRightMost = rightMost; rightMost = rightMost.right; // 向右不断递归 &#125; // 用rightMost节点的内容替换current中的内容 current.element = rightMost.element; // rightMost的父节点和rightMost的左子节点相连 if (parentOfRightMost.right == rightMost) &#123; // rightMost是右子节点 parentOfRightMost.right = rightMost.left; &#125; else &#123; // rightMost是左子节点 parentOfRightMost.left = rightMost.left; &#125; &#125; size--; return true;&#125; 找出叶子节点和非叶子结点找出叶子节点的个数123456789101112public int getNumberOfLeaves() &#123; return getNumberOfLeaves(root);&#125;protected int getNumberOfLeaves(TreeNode&lt;E&gt; root) &#123; if (root ==null) return 0; // If node has no children return 1 // else return the sum of all the leaves return root.left == null &amp;&amp; root.right == null ? 1 : getNumberOfLeaves(root.left) + getNumberOfLeaves(root.right);&#125; 找出非叶子节点的个数12345678910111213public int getNumberOfNonLeaves() &#123; return getNumberOfNonLeaves(root);&#125; protected int getNumberOfNonLeaves(TreeNode&lt;E&gt; root) &#123; if (root == null) return 0; // If node has children return 0 // else return 1 plus the sum of the nonleaves return (root.left == null &amp;&amp; root.right == null) ? 0 : 1 + getNumberOfNonLeaves(root.left) + getNumberOfNonLeaves(root.right) ;&#125; 实现equals和clone方法树的equals方法12345678910111213public boolean equals(BST&lt;E&gt; tree) &#123; if (tree.size != size) return false; return equals(root, tree.root);&#125;/** Equals helper */protected boolean equals(TreeNode&lt;E&gt; root1, TreeNode&lt;E&gt; root2) &#123; if (root1 == root2) return true; if (root1 == null || root2 == null) return false; return root1.element.equals(root2.element) &amp;&amp; equals(root1.left, root2.left) &amp;&amp; equals(root1.right, root2.right);&#125; 树的clone方法12345678910111213public BST&lt;E&gt; clone() throws CloneNotSupportedException &#123; BST&lt;E&gt; cloneBST = new BST&lt;&gt;(); clone(cloneBST, root); return cloneBST;&#125;/** Clone helper */protected void clone(BST&lt;E&gt; clone, TreeNode&lt;E&gt; root) &#123; if (root == null) return; clone.insert(root.element); clone(clone, root.left); clone(clone, root.right);&#125; BST类使用一个Tree的接口来定义树的所有常用操作，提供AbstractTree的抽象类部分实现了Tree，最后实现了BST类。 Tree接口Tree.java 接口定义树的常用操作12345678910111213141516171819202122232425262728public interface Tree&lt;E&gt; extends Iterable&lt;E&gt;&#123; /** Return true 如果搜索成功 */ boolean search(E e); /** 向二叉搜索树插入元素 Return true 如果成功添加 */ boolean insert(E e); /** Return true 如果成功从树中删除元素 */ boolean delete(E e); /** 中序遍历打印节点 1+2 */ void inorder(); /** 后序遍历打印节点 12+ */ void postorder(); /** 前序遍历打印节点 +12 */ void preorder(); /** 广度优先遍历打印节点 */ void breadthFirstTraversal(); /** 返回树中节点数 */ int getSize(); /** Return true 如果树为空 */ boolean isEmpty(); &#125; AbstractTree抽象类AbstractTree.java 抽象类部分地实现了Tree123456789101112131415161718public abstract class AbstractTree&lt;E&gt; implements Tree&lt;E&gt; &#123; @Override /** 中序遍历打印节点 1+2 */ public void inorder() &#123; &#125; @Override /** 后序遍历打印节点 12+ */ public void postorder() &#123; &#125; @Override /** 前序遍历打印节点 +12 */ public void preorder() &#123; &#125; @Override /** Return true 如果树为空 */ public boolean isEmpty() &#123; return getSize() == 0; &#125;&#125; 具体的BSTBST.java 具体定义了BST123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410import java.util.ArrayList;import java.util.Iterator;import java.util.LinkedList;import java.util.Queue;/* 因为每个节点只遍历一次，遍历的时间复杂度都是O(n) * 搜索、插入和删除的时间复杂度是树的高度。 * 最差的情况下，树的高度为O(n) * 如果树是平衡的，高度将是O（logn) */public class BST&lt;E extends Comparable&lt;E&gt;&gt; extends AbstractTree&lt;E&gt; &#123; protected TreeNode&lt;E&gt; root; //根节点 protected int size = 0; //节点数目 /** 默认构造方法 */ public BST() &#123; &#125; /** 泛型数组构造二叉搜索树 */ public BST(E[] objects) &#123; for (int i = 0; i &lt; objects.length; i++) insert(objects[i]); &#125; @Override public boolean search(E e) &#123; TreeNode&lt;E&gt; current = root; // 当前指针指向根节点 while (current != null) &#123; if (e.compareTo(current.element) &lt; 0) &#123; current = current.left; // 比当前指针的元素小，则往左 &#125; else if (e.compareTo(current.element) &gt; 0) &#123; current = current.right; // 比当前指针的元素大，则往右 &#125; else &#123; // 元素匹配 return true; // 找到元素 return true &#125; &#125; return false; &#125; @Override public boolean insert(E e) &#123; if (root == null) &#123; root = createNewNode(e); // 创建一个节点，树为空该节点成为根节点 &#125; else &#123; TreeNode&lt;E&gt; parent = null; // 定位父节点 TreeNode&lt;E&gt; current = root; // 当前指针指向根节点 while (current != null) &#123; if (e.compareTo(current.element) &lt; 0) &#123; parent = current; current = current.left; &#125; else if (e.compareTo(current.element) &gt; 0) &#123; parent = current; current = current.right; &#125; else &#123; return false; // 元素已经在树中，return false &#125; &#125; // 为元素e创建一个节点 if (e.compareTo(parent.element) &lt; 0) &#123; parent.left = createNewNode(e); &#125; else &#123; parent.right = createNewNode(e); &#125; &#125; size++; return true; &#125; public TreeNode&lt;E&gt; createNewNode(E e) &#123; return new TreeNode&lt;&gt;(e); &#125; /** 为了从一棵二叉搜索树中删除一个元素，首先需要定位该元素位置， * 然后在删除该元素以及重新连接树之前，考虑两种情况： * 1）该节点有左子节点 * 2）该节点没有左子节点 */ @Override public boolean delete(E e) &#123; // 如果current为root,那么parent为null TreeNode&lt;E&gt; parent = null; // 指向current节点的父节点 TreeNode&lt;E&gt; current = root; // 指向二叉搜索树中包含该元素的节点 while (current != null) &#123; // 递归寻找current节点 if (e.compareTo(current.element) &lt; 0) &#123; parent = current; current = current.left; &#125; else if (e.compareTo(current.element) &gt; 0) &#123; parent = current; current = current.right; &#125; else &#123; break; // 找到包含e的current节点 &#125; &#125; if (current == null) &#123; return false; // 元素不在树内 &#125; // 情况1：当前节点没有左子节点 if (current.left == null) &#123; //只需将该节点的父节点和该节点的右子节点相连 if (parent == null) &#123; root = current.right; &#125; else &#123; if (e.compareTo(parent.element) &lt; 0) &#123; parent.left = current.right; // e是父节点的左子结点 &#125; else &#123; parent.right = current.right; // e是父节点的右子结点 &#125; &#125; &#125; else &#123; // 情况2：当前节点有左子节点 TreeNode&lt;E&gt; parentOfRightMost = current; // rightMost节点的父节点 TreeNode&lt;E&gt; rightMost = current.left; // 当前节点的左子树最右端的节点 while (rightMost.right != null) &#123; parentOfRightMost = rightMost; rightMost = rightMost.right; // 向右不断递归 &#125; // 用rightMost节点的内容替换current中的内容 current.element = rightMost.element; // rightMost的父节点和rightMost的左子节点相连 if (parentOfRightMost.right == rightMost) &#123; // rightMost是右子节点 parentOfRightMost.right = rightMost.left; &#125; else &#123; // rightMost是左子节点 parentOfRightMost.left = rightMost.left; &#125; &#125; size--; return true; &#125; @Override public void inorder() &#123; inorder(root); &#125; protected void inorder(TreeNode&lt;E&gt; root) &#123; if (root == null) return; inorder(root.left); // 递归遍历左子树 System.out.print(root.element + " "); // 递归遍历根节点 inorder(root.right); // 递归遍历右子树 1+2 &#125; @Override public void postorder() &#123; postorder(root); &#125; protected void postorder(TreeNode&lt;E&gt; root) &#123; if (root == null) return; postorder(root.left); // 递归遍历左子树 postorder(root.right); // 递归遍历右子树 System.out.println(root.element + " "); // 递归遍历根节点 12+ &#125; @Override public void preorder() &#123; preorder(root); &#125; protected void preorder(TreeNode&lt;E&gt; root) &#123; if (root == null) return; System.out.println(root.element + " "); // 递归遍历根节点 preorder(root.left); // 递归遍历左子树 preorder(root.right); // 递归遍历右子树 +12 &#125; @Override public void breadthFirstTraversal() &#123; if (root == null) return; Queue&lt;TreeNode&lt;E&gt;&gt; queue = new LinkedList&lt;&gt;(); // Queue Deque Linkedlist queue.add(root); while (!queue.isEmpty()) &#123; TreeNode&lt;E&gt; current = queue.element(); if (current.left != null) &#123; queue.add(current.left); &#125; if (current.right != null) &#123; queue.add(current.right); &#125; System.out.println(queue.remove().element + " "); &#125; &#125; /**以数组线性表返回节点的路径： * 从根节点开始到该元素所在的节点 * 元素可能不在树中 */ public ArrayList&lt;TreeNode&lt;E&gt;&gt; path(E e) &#123; ArrayList&lt;TreeNode&lt;E&gt;&gt; list = new ArrayList&lt;&gt;(); TreeNode&lt;E&gt; current = root; while (current != null) &#123; list.add(current); if (e.compareTo(current.element) &lt; 0) &#123; current = current.left; &#125; else if (e.compareTo(current.element) &gt; 0) &#123; current = current.right; &#125; else &#123; break; &#125; &#125; return list; &#125; public int height() &#123; return height(root); &#125; public int height(TreeNode&lt;E&gt; root) &#123; if (root == null) return 0; return 1 + Math.max(height(root.left), height(root.right)); &#125; @Override public int getSize() &#123; return size; &#125; public TreeNode&lt;E&gt; getRoot() &#123; return root; &#125; public void clear() &#123; root = null; size = 0; &#125; /** 测试完全二叉树，完全二叉树的节点格式为 2^depth - 1 */ public boolean isFullBST() &#123; return size == Math.pow(2, height()) - 1 ? true : false; &#125; /** 找出叶子节点的个数 */ public int getNumberOfLeaves() &#123; return getNumberOfLeaves(root); &#125; protected int getNumberOfLeaves(TreeNode&lt;E&gt; root) &#123; if (root ==null) return 0; // If node has no children return 1 // else return the sum of all the leaves return root.left == null &amp;&amp; root.right == null ? 1 : getNumberOfLeaves(root.left) + getNumberOfLeaves(root.right); &#125; public int getNumberOfNonLeaves() &#123; return getNumberOfNonLeaves(root); &#125; protected int getNumberOfNonLeaves(TreeNode&lt;E&gt; root) &#123; if (root == null) return 0; // If node has children return 0 // else return 1 plus the sum of the nonleaves return (root.left == null &amp;&amp; root.right == null) ? 0 : 1 + getNumberOfNonLeaves(root.left) + getNumberOfNonLeaves(root.right) ; &#125; /** Returns true if two trees are equal. Otherwise returns false (recursive) */ public boolean equals(BST&lt;E&gt; tree) &#123; if (tree.size != size) return false; return equals(root, tree.root); &#125; /** Equals helper */ protected boolean equals(TreeNode&lt;E&gt; root1, TreeNode&lt;E&gt; root2) &#123; if (root1 == root2) return true; if (root1 == null || root2 == null) return false; return root1.element.equals(root2.element) &amp;&amp; equals(root1.left, root2.left) &amp;&amp; equals(root1.right, root2.right); &#125; @Override /** Override the protected clone method defined in the Object class, and deep copy BST */ public BST&lt;E&gt; clone() throws CloneNotSupportedException &#123; BST&lt;E&gt; cloneBST = new BST&lt;&gt;(); clone(cloneBST, root); return cloneBST; &#125; /** Clone helper */ protected void clone(BST&lt;E&gt; clone, TreeNode&lt;E&gt; root) &#123; if (root == null) return; clone.insert(root.element); clone(clone, root.left); clone(clone, root.right); &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return new InorderIterator(); &#125; private class InorderIterator implements Iterator&lt;E&gt; &#123; private ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;(); private int current = 0; // 指向线性表中的第一个元素 public InorderIterator() &#123; inorder(); &#125; private void inorder() &#123; inorder(root); &#125; private void inorder(TreeNode&lt;E&gt; root) &#123; if (root == null) return; inorder(root.left); list.add(root.element); inorder(root.right); &#125; @Override public boolean hasNext() &#123; if (current &lt; list.size()) // 检查current是否在list范围内 return true; return false; &#125; @Override public E next() &#123; return list.get(current++); // 返回当前元素 然后current+1 &#125; @Override public void remove() &#123; delete(list.get(current)); // 删除当前元素 list.clear(); // 清空线性表 inorder(); // 创建一个新的线性表，每次通过迭代器删除一个元素都要重新构造整个线性表 &#125; /* 在使得remove方法不被迭代器支持后， * 无须为树中的元素维护一个线性表使得迭代器更加高效。 * 可以使用栈来存储节点 * public void remove() &#123; throw new UnsupportedOparetionException("removing an element from the iterator is not supported"); &#125; */ &#125; /** Returns an iterator for traversing the elements in preorder */ public java.util.Iterator&lt;E&gt; preorderIterator() &#123; return new PreorderIterator(); &#125; // Inner class preorderIterator private class PreorderIterator implements java.util.Iterator&lt;E&gt; &#123; // Store the elements in a list private java.util.ArrayList&lt;E&gt; list = new java.util.ArrayList&lt;&gt;(); private int current = 0; // Point to the current element in list public PreorderIterator() &#123; preorder(); // Traverse binary tree and store elements in list &#125; /** Preorder traversal from the root */ private void preorder() &#123; preorder(root); &#125; /** preorder traversal from a subtree */ private void preorder(TreeNode&lt;E&gt; root) &#123; if (root == null) return; list.add(root.element); preorder(root.left); preorder(root.right); &#125; @Override /** More elements for traversing? */ public boolean hasNext() &#123; if (current &lt; list.size()) return true; return false; &#125; @Override /** Get the current element and move to the next */ public E next() &#123; return list.get(current++); &#125; @Override /** Remove the current element */ public void remove() &#123; delete(list.get(current)); // Delete the current element list.clear(); // Clear the list preorder(); // Rebuild the list &#125; &#125; /** This inner class is static, because it does not access any instance members defined in its outer class */ public static class TreeNode&lt;E extends Comparable&lt;E&gt;&gt; &#123; protected E element; protected TreeNode&lt;E&gt; left; protected TreeNode&lt;E&gt; right; public TreeNode(E e) &#123; element = e; &#125; &#125; &#125; BST的测试用例BST测试用例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.util.Iterator;public class TestBST &#123; public static void main(String[] args) throws Exception &#123; // 广度优先遍历和树的高度 BST&lt;String&gt; strTree = new BST&lt;&gt;(); strTree.insert("George"); strTree.insert("Micheal"); strTree.insert("Tom"); strTree.insert("Adam"); strTree.insert("Jones"); strTree.insert("Peter"); strTree.insert("Daniel"); System.out.print("\nBreadth-first: "); strTree.breadthFirstTraversal(); System.out.print("\nHeight of tree: "); System.out.println(strTree.height()); // 测试完全二叉树 Integer[] numbers1 = &#123;2, 4, 3, 1, 8, 5, 6, 7&#125;; Integer[] numbers2 = &#123;4, 2, 1, 3, 8, 5, 9&#125;; Integer[] numbers3 = &#123;10, 4, 2, 1, 3, 8, 5, 9, 15, 12, 11, 13, 21, 19, 25&#125;; BST&lt;Integer&gt; intTree1 = new BST&lt;&gt;(numbers1); BST&lt;Integer&gt; intTree2 = new BST&lt;&gt;(numbers2); BST&lt;Integer&gt; intTree3 = new BST&lt;&gt;(numbers3); System.out.print("\nIs tree #1 a full binary tree? "); System.out.println(intTree1.isFullBST()); System.out.print("\nIs tree #2 a full binary tree? "); System.out.println(intTree2.isFullBST()); System.out.print("\nIs tree #3 a full binary tree? "); System.out.println(intTree3.isFullBST()); // 找出叶子节点和非叶子节点 Integer[] numbers = &#123;60, 55, 45, 47, 59, 100, 76, 107, 101&#125;; BST&lt;Integer&gt; intTree = new BST&lt;&gt;(numbers); System.out.println("Number of leaf nodes: " + intTree.getNumberOfLeaves()); System.out.println("Number of nonleaf nodes: " + intTree.getNumberOfNonLeaves()); // 前序遍历 Integer[] numbers4 = &#123;60, 55, 45, 48, 59, 100, 76, 107, 101&#125;; BST&lt;Integer&gt; intTree4 = new BST&lt;&gt;(numbers4); System.out.print("intTree: "); intTree4.preorder(); // 测试clone方法 BST&lt;Integer&gt; intTreeCopy = intTree.clone(); // 测试equals方法 System.out.println("\nIs intTree equal to intTree2? " + intTree.equals(intTree2)); System.out.println("Is intTree equal to intTreeCopy? " + intTree.equals(intTreeCopy)); // 前序遍历 System.out.print("intTreeCopy: "); intTreeCopy.preorder(); System.out.println(); // 测试前序迭代器 BST&lt;String&gt; tree0 = new BST&lt;&gt;(); tree0.insert("George"); tree0.insert("Michael"); tree0.insert("Tom"); tree0.insert("Adam"); tree0.insert("Jones"); tree0.insert("Peter"); tree0.insert("Daniel"); Iterator&lt;String&gt; iterator = tree0.preorderIterator(); while (iterator.hasNext()) System.out.print(iterator.next().toUpperCase() + " "); System.out.println(); &#125;&#125;]]></content>
      <categories>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>search</tag>
        <tag>tree</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2Fleetcode%2F2019%2F03%2F14%2Fheap-sort.html</url>
    <content type="text"><![CDATA[堆排序使用的是二叉堆。首先将所有的元素添加到一个堆上，然后不断移除最大的元素以获得一个排好序的线性表。 堆的存储堆排序(heap sort)使用二叉堆(binary heap)，它是一棵 完全二叉树，每个节点大于或等于它的任意一个孩子。如果一颗二叉树的每一层都是满的，或者最后一层可以不填满并且最后一层的叶子都是靠左放置的，那么这棵二叉树就是完全的(complete)。如果堆的大小是事先知道的，那么可将堆存储在一个ArrayList或一个数组中。树根在位置0处，它的两个子节点在位置1和位置2处。 对于位置i处的节点，它的： 左子结点在位置 2i+1 处 右子结点在位置 2i+2 处 父节点在位置 (i-1)/2 处 添加一个新结点给堆添加一个新结点，首先将它添加到堆的末尾，然后按如下方式重建这棵树：Adding a New Node Psuedo Code123456789101112Let the last node be the current node;while (the current node is greater than its parent) &#123; Swap the current node with its parent; Now the current node is one level up;&#125;令最后一个节点的那个做当前节点;while (当前节点大于他的父节点) &#123; 将当前节点和它的父节点交换; 现在当前节点往上面进了一个层级;&#125; 删除一个结点经常需要从堆中删除最大的元素，也就是这个堆中的根节点。在删除根节点之后，就必须重建这棵树以保持堆的属性。重建该树的算法如下所示： Removing the Root Psuedo code123456789101112131415Move the last node to replace the root;Let the root be the current node;while (the current node has childen &amp;&amp; the current node is smaller than one of its children) &#123; Swap the current node with the larger of its children; Now the current node is one level down; &#125;用最后一个节点替换根节点;让根节点成为当前节点;while (当前节点具有子节点&amp;&amp;当前节点小于它的子节点) &#123; 将当前节点和它的较大子节点交换; 现在当前节点往下面退了一个层次;&#125; Heap类Comparable可以认为是一个内比较器，实现了Comparable接口的类有一个特点，就是这些类是可以和自己比较的，至于具体和另一个实现了Comparable接口的类如何比较，则依赖compareTo方法的实现，compareTo方法也被称为自然比较方法。如果开发者进入一个Collection的对象想要Collections的sort方法帮你自动进行排序的话，那么这个对象必须实现Comparable接口。compareTo方法的返回值是int，有三种情况： 比较者大于被比较者（也就是compareTo方法里面的对象），那么返回正整数 比较者等于被比较者，那么返回0 比较者小于被比较者，那么返回负整数 Comparator可以认为是是一个外比较器，个人认为有两种情况可以使用实现Comparator接口的方式：1)一个对象不支持自己和自己比较（没有实现Comparable接口），但是又想对两个对象进行比较;2)一个对象实现了Comparable接口，但是开发者认为compareTo方法中的比较方式并不是自己想要的那种比较方式Comparator接口里面有一个compare方法，方法有两个参数T o1和T o2，是泛型的表示方式，分别表示待比较的两个对象，方法返回值和Comparable接口一样是int，有三种情况： o1大于o2，返回正整数 o1等于o2，返回0 o1小于o3，返回负整数 使用Comparable接口对元素排序使用Comparable接口对元素排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.util.Comparator;import java.util.ArrayList;public class Heap&lt;E extends Comparabel&lt;E&gt;&gt; &#123; private ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;(); public Heap() &#123;&#125; public Heap(E[] objects) &#123; for (int i = 0; i &lt; objects.length; i++) &#123; this.add(objects[i]); &#125; &#125; public void add(E newObject) &#123; list.add(newObject); int currentIndex = list.size() - 1; while (currentIndex &gt; 0) &#123; int parentIndex = (currentIndex - 1) / 2; if (list.get(currentIndex).compareTo(list.get(parentIndex)) &gt; 0) &#123; E tmp = list.get(currentIndex); list.set(currentIndex, list.get(parentIndex)); list.set(parentIndex, tmp); &#125; else &#123; break; &#125; currentIndex = parentIndex; &#125; &#125; public E remove() &#123; if (list.size() == 0) return null; E removeObject = list.get(0); list.set(0, list.get(list.size() - 1)); list.remove(list.size() - 1); int currentIndex = 0; while (currentIndex &lt; list.size()) &#123; int leftChildIndex = 2 * currentIndex + 1; int rightChildIndex = 2 * currentIndex + 2; if (leftChildIndex &gt;= list.size()) break; int maxIndex = leftChildIndex; if (rightChildIndex &lt; list.size()) &#123; if (list.get(maxIndex).comparetTo(list.get(rightChildIndex)) &lt; 0) &#123; maxIndex = rightChildIndex; &#125; &#125; if (list.get(currentIndex).compareTo(list.get(maxIndex)) &lt; 0) &#123; E tmp = list.get(maxIndex); list.set(maxIndex, list.get(currentIndex)); list.set(currentIndex, tmp) &#125; else &#123; break; &#125; currentIndex = maxIndex; &#125; return removeObject; &#125; public int getSize() &#123; return list.size(); &#125;&#125; 使用Comparator接口对元素排序使用Comparator接口对元素排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.ArrayList;import java.util.Comparator;public class HeapA&lt;E&gt; &#123; private Comparator&lt;? super E&gt; comparator; private ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;(); public HeapA(Comparator&lt;? super E&gt; comparator) &#123; this.comparator = comparator; &#125; public void add(E newObject) &#123; list.add(newObject); int currentIndex = list.size() - 1; while (currentIndex &gt; 0) &#123; int parentIndex = (currentIndex - 1) / 2; if (comaprator.compare(list.get(currentIndex), list.getIparentIndex)) &gt; 0) &#123; E tmp = list.get(currentIndex); list.set(currentIndex, list.get(parentIndex)); list.set(parentIndex, tmp); &#125; else &#123; break; &#125; currentIndex = parentIndex; &#125; &#125; pubic E remove() &#123; if (list.size() == 0) return null; E removeObject = list.get(0); list.set(0, list.get(list.size() - 1)); list.remove(list.size() - 1); int currentIndex = 0; while (currentIndex &lt; list.size()) &#123; int leftChildIndex = 2 * currentIndex + 1; int rightChildIndex = 2 * currentIndex + 2; //这里是大于等于 if (leftChildIndex &gt;= list.size()) break; int maxIndex = leftChildIndex; if(rigthChildIndex &lt; list.size()) &#123; if (comparator.compare(list.get(maxIndex), list.get(rightChildIndex)) &lt; 0) &#123; maxIndex = rightChildIndex; &#125; &#125; if (comparator.compare(list.get(currentIndex), list.get(maxIndex)) &lt; 0) &#123; E tmp = list.get(maxIndex); list.set(maxIndex, list.get(currentIndex)); list.set(currentIndex, tmp); &#125; else &#123; break; &#125; currentIndex = maxIndex; &#125; return removeObject; &#125; pubic int getSize() &#123; return list.size(); &#125;&#125; 使用Heap类进行排序使用Comparator需要编写测试用例，实现Comparator接口的的GeomatricObjectComparator，以及抽象父类GeometricObject,抽象方法getArea，在子类Circle和Rectangle类中实现。排序算法为HeapSort。 HeapSort排序算法HeapSort排序算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.util.Comparator;public class HeapSort &#123; public static &lt;E extends Comparable&lt;E&gt;&gt; void heapSort(E[] list) &#123; Heap&lt;E&gt; heap = new Heap&lt;&gt;(); for (int i = 0; i &lt; list.length; i++) &#123; heap.add(list[i]); &#125; for (int i = list.length - 1; i &gt;= 0; i--) &#123; list[i] = heap.remove(); &#125; &#125; public static &lt;E&gt; void heapSort(E[] list, Comparator&lt;? super E&gt; comparator) &#123; HeapA&lt;E&gt; heap = new HeapA&lt;&gt;(comparator); for (int i = 0; i &lt; list.length; i++) &#123; heap.add(list[i]); &#125; for (int i = list.length - 1; i &gt;= 0; i--) &#123; list[i] = heap.remove(); &#125; &#125; public static void main(String[] args) &#123; /** Create an Array of Integers */ Integer[] intArray = &#123;-44, -5, -3, 3, 3, 1, -4, 0, 1, 2, 4, 5, 53&#125;; /** Create an Array of Doubles */ Double[] doubleArray = &#123;3.4, 1.3, -22.1, 14.8, 6.0, 2.3, 12.2&#125;; /** Create an Array of Characters */ Character[] charArray = &#123;'a', 'J', 'r'&#125;; /** Create an Array of String */ String[] stringArray = &#123;"Tom", "Susan", "Kim"&#125;; /** Heapsort the arrays */ heapSort(intArray); heapSort(doubleArray); heapSort(charArray); heapSort(stringArray); /** Display the array */ System.out.print("Sorted Integers: "); printList(intArray); System.out.print("Sorted Doubles: "); printList(doubleArray); System.out.print("Sorted Characters: "); printList(charArray); System.out.print("Sorted Strings: "); printList(stringArray); GeometricObject[] list = &#123;new Circle(5), new Rectangle(4, 5), new Circle(5.5), new Rectangle(2.4, 5), new Circle(0.5), new Rectangle(4, 65), new Circle(4.5), new Rectangle(4.4, 1), new Circle(6.5), new Rectangle(4, 5)&#125;; heapSort(list, new GeometricObjectComparator()); System.out.print("Sorted elements: "); for (GeometricObject e: list) &#123; System.out.printf("%.2f ", e.getArea()); &#125; System.out.println(); &#125; public static void printList(Object[] list) &#123; for (int i = 0; i &lt; list.length; i++) System.out.print(list[i] + " "); System.out.println(); &#125;&#125; GeometricObjectComparator类实现java.util.Comparator接口GeometricObjectComparator类实现java.util.Comparator接口12345678910111213141516171819import java.io.Serializable;import java.util.Comparator;public class GeometricObjectComparator implements Comparator&lt;GeometricObject&gt;, Serializable &#123; @Override public int compare(GeometricObject o1, GeometricObject o2) &#123; // TODO Auto-generated method stub double area1 = o1.getArea(); double area2 = o2.getArea(); if (area1 &lt; area2) &#123; return -1; &#125; else if (area1 == area2) &#123; return 0; &#125; else &#123; return 1; &#125; &#125;&#125; GeometricObject抽象父类GeometricObject抽象父类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.Date;public abstract class GeometricObject &#123; private String color = "white"; private boolean filled; private Date dateCreated; protected GeometricObject() &#123; dateCreated = new Date(); &#125; protected GeometricObject(String color, boolean filled) &#123; dateCreated = new Date(); this.color = color; this.filled = filled; &#125; /** Return color */ public String getColor() &#123; return color; &#125; /** Set a new color */ public void setColor(String color) &#123; this.color = color; &#125; /** Return filled. Since filled is boolean, * the get method is named isFilled */ public boolean isFilled() &#123; return filled; &#125; /** Set a new filled */ public void setFilled(boolean filled) &#123; this.filled = filled; &#125; /** Get dateCreated */ public java.util.Date getDateCreated() &#123; return dateCreated; &#125; @Override public String toString() &#123; return "created on " + dateCreated + "\ncolor: " + color + " and filled: " + filled; &#125; /** Abstract method getArea */ public abstract double getArea(); /** Abstract method getPerimeter */ public abstract double getPerimeter(); &#125; Circle类继承自GeometricObjectCircle类继承自GeometricObject12345678910111213141516171819202122232425262728293031323334353637383940public class Circle extends GeometricObject &#123; private double radius; public Circle() &#123; &#125; public Circle(double radius) &#123; this.radius = radius; &#125; public Circle(double radius, String color, boolean filled) &#123; this.radius = radius; setColor(color); setFilled(filled); &#125; public double getRadius() &#123; return radius; &#125; public void setRadius(double radius) &#123; this.radius = radius; &#125; @Override public double getArea() &#123; return radius * radius * Math.PI; &#125; public double getDiameter() &#123; return 2 * radius; &#125; @Override public double getPerimeter() &#123; return 2 * radius * Math.PI; &#125; @Override public String toString() &#123; return super.toString() + ", Circle, Created: " + getDateCreated() + ", Radius: " + radius; &#125;&#125; Rectangle类继承自GeometricObjectRectangle类继承自GeometricObject123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Rectangle extends GeometricObject &#123; private double width; private double height; public Rectangle() &#123; &#125; public Rectangle( double width, double height) &#123; this.width = width; this.height = height; &#125; public Rectangle( double width, double height, String color, boolean filled) &#123; this.width = width; this.height = height; setColor(color); setFilled(filled); &#125; public double getWidth() &#123; return width; &#125; public void setWidth(double width) &#123; this. width = width; &#125; public double getheight() &#123; return height; &#125; public void setheight(double height) &#123; this.height = height; &#125; @Override public double getArea() &#123; return width * height; &#125; @Override public double getPerimeter() &#123; return 2 * (width * height); &#125; @Override public String toString() &#123; return super.toString() + " Rectangle, Created: " + getDateCreated() + ", Width: " + width + ", Height: " + height; &#125;&#125; 堆排序的时间复杂度设h表示包含n个元素的堆的高度。 堆的高度为O(logn)。由于add方法会追踪从叶子节点到根节点的路径，因此向堆中添加一个新元素最多需要h步。所以建立一个包含n个元素的数组的初始堆需要O(nlogn)时间。由于remove方法要跟踪从根节点到叶子节点的路径，因此从堆中删除根节点后，重建堆最多需要h步。由于要调用n次remove方法，所以产生一个有序数组需要的总时间为O(nlogn)。堆排序不需要额外的数组空间，空间效率高于归并排序。 实现clone和equals的堆方法实现clone和equals方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import java.util.Comparator;import java.util.ArrayList;public class Heap &lt;E extends Comparable&lt;E&gt;&gt; implements Cloneable&#123; private ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;();; /** Create a default heap */ public Heap() &#123; &#125; /** Create a heap from an array of objects */ public Heap(E[] objects) &#123; for (int i = 0; i &lt; objects.length; i++) add(objects[i]); &#125; /** Add a new object into the heap */ public void add(E newObject) &#123; list.add(newObject); // Append to the heap int currentIndex = list.size() - 1; // The index of the last node while (currentIndex &gt; 0) &#123; int parentIndex = (currentIndex - 1) / 2; // Swap if the current object is greater than its parent if (list.get(currentIndex).compareTo( list.get(parentIndex)) &gt; 0) &#123; E temp = list.get(currentIndex); list.set(currentIndex, list.get(parentIndex)); list.set(parentIndex, temp); &#125; else break; // The tree is a heap now currentIndex = parentIndex; &#125; &#125; /** Remove the root from the heap */ public E remove() &#123; if (list.size() == 0) return null; E removedObject = list.get(0); list.set(0, list.get(list.size() - 1)); list.remove(list.size() - 1); int currentIndex = 0; while (currentIndex &lt; list.size()) &#123; int leftChildIndex = 2 * currentIndex + 1; int rightChildIndex = 2 * currentIndex + 2; // Find the maximum between two children if (leftChildIndex &gt;= list.size()) break; // The tree is a heap int maxIndex = leftChildIndex; if (rightChildIndex &lt; list.size()) &#123; if (list.get(maxIndex).compareTo( list.get(rightChildIndex)) &lt; 0) &#123; maxIndex = rightChildIndex; &#125; &#125; // Swap if the current node is less than the maximum if (list.get(currentIndex).compareTo( list.get(maxIndex)) &lt; 0) &#123; E temp = list.get(maxIndex); list.set(maxIndex, list.get(currentIndex)); list.set(currentIndex, temp); currentIndex = maxIndex; &#125; else break; // The tree is a heap &#125; return removedObject; &#125; /** Get the number of nodes in the tree */ public int getSize() &#123; return list.size(); &#125; @Override /** Override teh proctected clone method defined in the Object class, and stregthen its accessibility */ public Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125; @Override /** Override the equals method in the Object class */ public boolean equals(Object other) &#123; if (list.size() != ((Heap)(other)).getSize()) return false; for (int i = 0; i &lt; list.size(); i++) &#123; if (list.get(i) != ((Heap)(other)).list.get(i)) return false; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>heap</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[355. Design Twitter]]></title>
    <url>%2Fleetcode%2F2019%2F03%2F11%2F355.html</url>
    <content type="text"><![CDATA[设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近十条推文。 你的设计需要支持以下的几个功能： postTweet(userId, tweetId): 创建一条新的推文 getNewsFeed(userId): 检索最近的十条推文。每个推文都必须是由此用户关注的人或者是用户自己发出的。推文必须按照时间顺序由最近的开始排序。 follow(followerId, followeeId): 关注一个用户 unfollow(followerId, followeeId): 取消关注一个用户 355. 设计推特123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120public class Twitter &#123; private static int timeStamp=0; // easy to find if user exist private Map&lt;Integer, User&gt; userMap; // Tweet link to next Tweet so that we can save a lot of time // when we execute getNewsFeed(userId) private class Tweet&#123; public int id; public int time; public Tweet next; public Tweet(int id)&#123; this.id = id; time = timeStamp++; next=null; &#125; &#125; // OO design so User can follow, unfollow and post itself public class User&#123; public int id; public Set&lt;Integer&gt; followed; public Tweet tweet_head; public User(int id)&#123; this.id=id; followed = new HashSet&lt;&gt;(); follow(id); // first follow itself tweet_head = null; &#125; public void follow(int id)&#123; followed.add(id); &#125; public void unfollow(int id)&#123; followed.remove(id); &#125; // everytime user post a new tweet, add it to the head of tweet list. public void post(int id)&#123; Tweet t = new Tweet(id); t.next=tweet_head; tweet_head=t; &#125; &#125; /** Initialize your data structure here. */ public Twitter() &#123; userMap = new HashMap&lt;Integer, User&gt;(); &#125; /** Compose a new tweet. */ public void postTweet(int userId, int tweetId) &#123; if(!userMap.containsKey(userId))&#123; User u = new User(userId); userMap.put(userId, u); &#125; userMap.get(userId).post(tweetId); &#125; // Best part of this. // first get all tweets lists from one user including itself and all people it followed. // Second add all heads into a max heap. Every time we poll a tweet with // largest time stamp from the heap, then we add its next tweet into the heap. // So after adding all heads we only need to add 9 tweets at most into this // heap before we get the 10 most recent tweet. public List&lt;Integer&gt; getNewsFeed(int userId) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); if(!userMap.containsKey(userId)) return res; Set&lt;Integer&gt; users = userMap.get(userId).followed; PriorityQueue&lt;Tweet&gt; q = new PriorityQueue&lt;Tweet&gt;(users.size(), (a,b)-&gt;(b.time-a.time)); for(int user: users)&#123; Tweet t = userMap.get(user).tweet_head; // very imporant! If we add null to the head we are screwed. if(t!=null)&#123; q.add(t); &#125; &#125; int n=0; while(!q.isEmpty() &amp;&amp; n&lt;10)&#123; Tweet t = q.poll(); res.add(t.id); n++; if(t.next!=null) q.add(t.next); &#125; return res; &#125; /** Follower follows a followee. If the operation is invalid, it should be a no-op. */ public void follow(int followerId, int followeeId) &#123; if(!userMap.containsKey(followerId))&#123; User u = new User(followerId); userMap.put(followerId, u); &#125; if(!userMap.containsKey(followeeId))&#123; User u = new User(followeeId); userMap.put(followeeId, u); &#125; userMap.get(followerId).follow(followeeId); &#125; /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */ public void unfollow(int followerId, int followeeId) &#123; if(!userMap.containsKey(followerId) || followerId==followeeId) return; userMap.get(followerId).unfollow(followeeId); &#125;&#125;/** * Your Twitter object will be instantiated and called as such: * Twitter obj = new Twitter(); * obj.postTweet(userId,tweetId); * List&lt;Integer&gt; param_2 = obj.getNewsFeed(userId); * obj.follow(followerId,followeeId); * obj.unfollow(followerId,followeeId); */]]></content>
      <categories>
        <category>Medium</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Heap</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[594. Longest Harmonious Subsequence]]></title>
    <url>%2Fleetcode%2F2019%2F03%2F11%2F594.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散列集合]]></title>
    <url>%2Fleetcode%2F2019%2F03%2F10%2FHashSet.html</url>
    <content type="text"><![CDATA[Set注重独一无二的性质，该体系集合用于存储无序元素（存入和取出的顺序不一定相同），值不能重复。对象相等性本质是对象hashCode值（java十一局对象的内存地址计算出来的此序号）判断的，如果想要两个不同的对象视为相等的，就必须覆盖Object的hashCode方法和equals方法。 使用散列实现集合Java集合框架定义了java.util.Set接口来对集合建模。三种具体的实现是HashSet、LinkedHashSet和TreeSet，HashSet采用散列实现，LinkedHashSet采用LinkedList实现，TreeSet采用红黑树实现。 MyMap接口MySet接口1234567891011121314public interface MySet&lt;E&gt; extends Iterable&lt;E&gt; &#123; void clear(); boolean contains(E e); boolean add(E e); boolean remove(E e); boolean isEmpty(); int size();&#125; MyHashSet实现类链地址实现MyHashSet123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217import java.util.LinkedList;public class MyHashSet&lt;E&gt; implements MySet&lt;E&gt; &#123; private static int DEFAULT_INITIAL_CAPACITY = 4; private static int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; private int capacity; private static float DEFAULT_MAX_LOAD_FACTOR = 0.75f; private float loadFactorThreshold; private int size = 0; private LinkedList&lt;E&gt;[] table; public MyHashSet() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_MAX_LOAD_FACTOR); &#125; public MyHashSet(int initialCapacity) &#123; this(initialCapacity, DEFAULT_MAX_LOAD_FACTOR); &#125; public MyHashSet(int initialCapacity, float loadFactorThreshold) &#123; if (initialCapacity &gt; MAXIMUM_CAPACITY) this.capacity = MAXIMUM_CAPACITY; else this.capacity = trimToPowerOf2(initialCapacity); this.loadFactorThreshold = loadFactorThreshold; table = new LinkedList[capacity]; &#125; @Override /** Remove all elements from this set */ public void clear() &#123; size = 0; removeElements(); &#125; @Override /** Return true if the element is in the set */ public boolean contains(E e) &#123; int bucketIndex = hash(e.hashCode()); if (table[bucketIndex] != null) &#123; LinkedList&lt;E&gt; bucket = table[bucketIndex]; for (E element : bucket) if (element.equals(e)) return true; &#125; return false; &#125; @Override /** Add an element to the set */ public boolean add(E e) &#123; if (contains(e)) // Duplicate element not stored return false; if (size + 1 &gt; capacity * loadFactorThreshold) &#123; if (capacity == MAXIMUM_CAPACITY) throw new RuntimeException("Exceeding maximum capacity"); rehash(); &#125; int bucketIndex = hash(e.hashCode()); // Create a linked list for the bucket if it is not created if (table[bucketIndex] == null) &#123; table[bucketIndex] = new LinkedList&lt;E&gt;(); &#125; table[bucketIndex].add(e); size++; // Increase size return true; &#125; @Override /** Remove the element from the set */ public boolean remove(E e) &#123; if (!contains(e)) return false; int bucketIndex = hash(e.hashCode()); // Create a linked list for the bucket if it is not created if (table[bucketIndex] != null) &#123; LinkedList&lt;E&gt; bucket = table[bucketIndex]; for (E element : bucket) if (e.equals(element)) &#123; bucket.remove(element); break; &#125; &#125; size--; // Decrease size return true; &#125; @Override /** Return true if the set contains no elements */ public boolean isEmpty() &#123; return size == 0; &#125; @Override /** Return the number of elements in the set */ public int size() &#123; return size; &#125; @Override /** Return an iterator for the elements in this set */ public java.util.Iterator&lt;E&gt; iterator() &#123; return new MyHashSetIterator(this); &#125; /** Inner class for iterator */ private class MyHashSetIterator implements java.util.Iterator&lt;E&gt; &#123; // Store the elements in a list private java.util.ArrayList&lt;E&gt; list; private int current = 0; // Point to the current element in list private MyHashSet&lt;E&gt; set; /** Create a list from the set */ public MyHashSetIterator(MyHashSet&lt;E&gt; set) &#123; this.set = set; list = setToList(); &#125; @Override /** Next element for traversing? */ public boolean hasNext() &#123; if (current &lt; list.size()) return true; return false; &#125; @Override /** Get current element and move cursor to the next */ public E next() &#123; return list.get(current++); &#125; @Override /** Remove the current element and refresh the list */ public void remove() &#123; // Delete the current element from the hash set set.remove(list.get(current)); list.remove(current); // Remove current element from the list &#125; &#125; /** Hash function */ private int hash(int hashCode) &#123; return supplementalHash(hashCode) &amp; (capacity - 1); &#125; /** Ensure the hashing is evenly distributed */ private static int supplementalHash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; /** Return a power of 2 for initialCapacity */ private int trimToPowerOf2(int initialCapacity) &#123; int capacity = 1; while (capacity &lt; initialCapacity) &#123; capacity &lt;&lt;= 1; &#125; return capacity; &#125; /** Remove all e from each bucket */ private void removeElements() &#123; for (int i = 0; i &lt; capacity; i++) &#123; if (table[i] != null) &#123; table[i].clear(); &#125; &#125; &#125; /** Rehash the set */ private void rehash() &#123; java.util.ArrayList&lt;E&gt; list = setToList(); // Copy to a list capacity &lt;&lt;= 1; // Double capacity table = new LinkedList[capacity]; // Create a new hash table size = 0; // Reset size for (E element : list) &#123; add(element); // Add from the old table to the new table &#125; &#125; /** Copy elements in the hash set to an array list */ private java.util.ArrayList&lt;E&gt; setToList() &#123; java.util.ArrayList&lt;E&gt; list = new java.util.ArrayList&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) &#123; if (table[i] != null) &#123; for (E e : table[i]) &#123; list.add(e); &#125; &#125; &#125; return list; &#125; @Override public String toString() &#123; java.util.ArrayList&lt;E&gt; list = setToList(); StringBuilder builder = new StringBuilder("["); // Add the elements except the last one to the string builder for (int i = 0; i &lt; list.size() - 1; i++) &#123; builder.append(list.get(i) + ", "); &#125; // Add the last element in the list to the string builder if (list.size() == 0) builder.append("]"); else builder.append(list.get(list.size() - 1) + "]"); return builder.toString(); &#125;&#125; 测试程序TestMyHashSet.java1234567891011121314151617181920212223public class TestMyHashSet &#123; public static void main(String[] args) &#123; // Create a MyHashSet MySet&lt;String&gt; set = new MyHashSet&lt;&gt;(); set.add("Smith"); set.add("Anderson"); set.add("Lewis"); set.add("Cook"); set.add("Smith"); System.out.println("Elements in set: " + set); System.out.println("Number of elements in set: " + set.size()); System.out.println("Is Smith in set? " + set.contains("Smith")); set.remove("Smith"); System.out.print("Names in set in uppercase are "); for (String s : set) System.out.print(s.toUpperCase() + " "); set.clear(); System.out.println("\nElements in set: " + set); &#125;&#125;]]></content>
      <categories>
        <category>HashSet</category>
      </categories>
      <tags>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散列表]]></title>
    <url>%2Fleetcode%2F2019%2F03%2F09%2FHashMap.html</url>
    <content type="text"><![CDATA[在一个良好平衡的查找树中，可以在O(logn)时间内找到一个元素。 使用散列来实现一个映射表或集合，从而在O(1)时间内查找、插入和删除一个元素。 HashMapjava.util.HashMap public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable HashMap和Hashtable有什么区别？ HashMap是Hashtable的轻量级实现（非线程安全的实现），都实现了Map接口，主要区别是HashMap允许key为null(但只允许一条null)，而后者不行。 HashMap把contains方法去掉，改为containsKey()和containsValue()。 Hashtable继承自Dictionary，而HashMap实现了Map接口，继承自AbstractMap。 Hashtable使用Enumeration遍历，而HashMap使用Iterator遍历。 使用的hash/rehash算法几乎一致，性能差别不大 Hashtable的hash数组默认大小是11,增加方式是2*old + 1。 HashMap中，hash数组默认大小是16，一定是2的指数。 一般在不需要并发的时候使用HashMap，并发的时候使用锁粒度更细的ConcurrentHashMap。迭代HashMap使用了快速失败机制，fail-fast，是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变操作时，就有可能产生fail-fast事件。假如线程1和线程2，当线程1通过iterator遍历集合A中的元素时，如果线程2修改了集合A的结构（删除、增加新元素），程序就会抛出ConcurrentModificationException异常，从而产生fail-fast事件。 遍历HashMap的四种方法：keySet需要首先把key转换成itaretor，然后根据key在map中取出value，需要两个操作，而entrySet只一次操作就把key和value都取到entry中来，效率更高。foreach和itaretor是等价的。 foreach map.entrySet() foreach map.entrySet()12345public static void traversal(Map&lt;String, String&gt; map) &#123; for (Entry&lt;String, String&gt; entry : map.entrySet()) &#123; System.out.print(entry.getKey() + ", " + entry.getValue()); &#125;&#125; 显示调用map.entrySet集合迭代器 显示调用map.entrySet集合迭代器 12345678public static void traversal(Map&lt;String, Integer&gt; map) &#123; Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry&lt;String, Integer&gt; entry = iterator.next(); System.out.println(entry.getKey() + ", " + entry.getValue()); &#125;&#125; foreach map.keySet(), 再调用get方法本方法多调用一次get，效率会降低，只适合只遍历key的情况。 foreach map.keySet(), 再调用get方法12345public static void traversal(Map&lt;String, String&gt; map) &#123; for (String key : map.keySet()) &#123; System.out.println(key + ", " + map.get(key)); &#125;&#125; foreach map.entrySet(), 再临时变量保存map.entrySet() foreach map.entrySet(), 再临时变量保存map.entrySet()123456public static void traversal(Map&lt;String, String&gt; map) &#123; Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet(); for (Entry&lt;String, String&gt; enty : entrySet) &#123; System.out.println(entry.getKey() + ", " + entry.getValue()); &#125;&#125; 散列函数和散列码折叠法byte、short、int、char类型的搜索键，简单地转换为int。long类型的散列码： hashCode = (int)(key ^ (key &gt;&gt; 32));double类型： long bits = Double.doubleToLongBits(key); int hashCode = (int)(bits ^ (bits &gt;&gt; 32)); 除余法(压缩)假设散列表的索引处于0~N-1 之间。设N为2的幂值。 h(hashCode) = hashCode % N;h(hashCode) = hashCode &amp; (N - 1);为了保证散列码是均匀分布的，java.util.HashMap采用了补充的散列函数与主散列函数一起使用。 字符串类型的散列码(…((s0 * b) + s1)b + s2)b + … + sn-2)b + sn-1在String中，b取值31，来计算上述多项式，以达到最小化冲突，其中si = s.charAt(i)。 除此之外，还有平方取中法，数字分析法等等。 使用链地址法处理冲突当两个键映射到散列表中的同一个索引上时，冲突发生。链地址法将具有同样的散列索引的条目都放在同一个位置，而不是寻找一个新位置。链地址法的每个位置使用一个桶来放置多个条目。可以使用数组，ArrayList或LinkedList来实现一个桶。使用LinkedListl来实现一个映射表。 此处实现与jdk中的实现不同，只是为了演示理解。 MyMap接口MyMap接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Set;public interface MyMap&lt;K, V&gt; &#123;// 删除映射表中所有条目 void clear();// 映射表是否包含键的条目 boolean containsKey(K key);// 如果映射表将一个或多个键映射到指定的值 返回true boolean containsValue(V value);// 返回包含该映射表中所有条目的集合 Set&lt;Entry&lt;K, V&gt;&gt; entrySet();// 指定键对应的值 V get(K key);// 是否包含映射条目 boolean isEmpty();// 映射表所有键的集合 Set&lt;K&gt; keySet();// 将一个映射置于映射表中 V put(K key, V value);// 移除指定键的条目 void remove(K key);// 映射条目数 int size();// 映射表值的集合 Set&lt;V&gt; values();// 映射条目的内部静态类 public static class Entry&lt;K, V&gt; &#123; K key; V value; public Entry(K key, V value) &#123; this.key = key; this.value = value; &#125; public K getKey() &#123; return key; &#125; public V getValue() &#123; return value; &#125; public String toString() &#123; return "[" + key + ", " + value + "]"; &#125; &#125;&#125; MyHashMap类的实现MyHashMap类链地址法处理冲突的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213import java.util.*;public class MyHashMap&lt;K ,V&gt; implements MyMap&lt;K, V&gt; &#123; private static int DEFAULT_INITIAL_CAPACITY = 4; private static int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; private int capacity; private static float DEFAULT_MAX_LOAD_FACTOR = 0.75f; private float loadFactorThreshold; //映射表条目数，只有执行一次方法put(key, value)后，size才会增加一次 private int size = 0; LinkedList&lt;MyMap.Entry&lt;K, V&gt;&gt;[] table; //散列表是一个数组，数组中的每个单元是一个链表 public MyHashMap() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_MAX_LOAD_FACTOR); &#125; public MyHashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_MAX_LOAD_FACTOR); &#125; public MyHashMap(int initialCapacity, float loadFactorThreshold) &#123; if (initialCapacity &gt; MAXIMUM_CAPACITY) &#123; this.capacity = MAXIMUM_CAPACITY; &#125; else &#123; this.capacity = trimToPowerOf2(initialCapacity); &#125; this.loadFactorThreshold = loadFactorThreshold; table = new LinkedList[capacity]; &#125; @Override public void clear() &#123; size = 0; removeEntries(); &#125; private void removeEntries() &#123; //耗费时间为O(capacity) for (int i = 0; i &lt; capacity; i++) &#123; if (table[i] != null) &#123; table[i].clear(); &#125; &#125; &#125; @Override public boolean containsKey(K key) &#123; //耗费时间也为O(1) if (get(key) != null) &#123; return true; &#125; else &#123; return false; &#125; &#125; @Override public boolean containsValue(V value) &#123; LinkedList&lt;Entry&lt;K, V&gt;&gt; bucket; for (int i = 0; i &lt; capacity; i++）&#123; if (table[i] != null) &#123; bucket = table[i]; for (Entry&lt;K, V&gt; entry : bucket) &#123; if (entry.getValue().equals(value)) return true; &#125; &#125; &#125; &#125; @Override public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() &#123; Set&lt;MyMap.Entry&lt;K, V&gt;&gt; set = new HashSet&lt;&gt;(); LinkedList&lt;Entry&lt;K, V&gt;&gt; bucket; for (int i = 0; i &lt; capacity; i++) &#123; if (table[i] != null) &#123; bucket = table[i]; for (Entry&lt;K ,V&gt; entry : bucket) set.add(entry); &#125; &#125; return set; &#125; @Override public V get(K key) &#123; //耗费O(1)的时间 int bucketIndex = hash(key.hashCode()); LinkedList&lt;Entry&lt;K, V&gt;&gt; bucket; if (table[bucketIndex] != null) &#123; bucket = table[bucketIndex]; for (Entry&lt;K, V&gt; entry : bucket) &#123; if (entry.getKey().equals(key)) return entry.getValue(); &#125; &#125; return null; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; @Override public Set&lt;K&gt; keySet() &#123; Set&lt;K&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) &#123; if (table[i] != null) &#123; LinkedList&lt;Entry&lt;K, V&gt;&gt; bucket = table[i]; for (Entry&lt;K, V&gt; entry: bucket) &#123; set.add(entry.getKey()); &#125; &#125; &#125; return set; &#125; @Override public V put(K key, V value) &#123; if (get(key) != null) &#123; int bucketIndex = hash(key.hashCode()); LinkedList&lt;Entry&lt;K, V&gt;&gt; entry = table[bucketIndex]; for (Entry&lt;K, V&gt; entry : bucket) &#123; if (entry.getKey().equals(key)) &#123; V oldValue = entry.getValue(); entry.value = value; return oldValue; &#125; &#125; &#125; if (size &gt;= capacity * loadFactorThreshold) &#123; if (capacity == MAXIMUM_CAPACITY) throw new RuntimeException("Exceeding maximum capacity"); rehash(); &#125; int bucketIndex = hash(key.hashCode()); if (table[bucketIndex] == null) &#123; table[bucketIndex] = new LinkedList&lt;Entry&lt;K, V&gt;&gt;(); &#125; table[bucketIndex].add(new MyMap.Enty&lt;K, V&gt;(key, value)); size++; return value; &#125; @Override public void remove(K key) &#123; int bucketIndex = hash(key.hashCode()); if (table[bucketIndex] != null) &#123; LinkedList&lt;Entry&lt;K, V&gt;&gt; bucket = table[bucketIndex]; for (Entry&lt;K, V&gt; entry : bucket) &#123; if (entry.getKey().equals(key)) &#123; bucket.remove(entry); size--; break; &#125; &#125; &#125; &#125; @Override public int size() &#123; return size; &#125; @Override public Set&lt;V&gt; values() &#123; Set&lt;V&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) &#123; if (table[i] != null) &#123; LinkedList&lt;Entry&lt;K, V&gt;&gt; bucket = table[i]; for (Entry&lt;K, V&gt; entry : bucket) &#123; set.add(entry.getValue()); &#125; &#125; &#125; return set; &#125; private int hash(int hashCode) &#123; return supplementalHash(hashCode) &amp; (capacity - 1); &#125; private static int supplementalHash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; private int trimToPowerOf2(int initialCapacity) &#123; int capacity = 1; while (capacity &lt; initialCapacity) &#123; capacity &lt;&lt;= 1; &#125; return capacity; &#125; private void rehash() &#123; Set&lt;Entry&lt;K, V&gt;&gt; set = entrySet(); capacity &lt;&lt;= 1; table = new LinkedList[capacity]; size = 0; for (Entry&lt;K, V&gt; entry : set) &#123; put(entry.getKey(), entry.getValue()); &#125; &#125; @Override public String toString() &#123; StringBuilder builder = new StringBuilder(); for (int i = 0; i &lt; capacity; i++) &#123; if (table[i] != null &amp;&amp; table[i].size() &gt; 0) &#123; for (Entry&lt;K, V&gt; entry: table[i]) &#123; builder.append(entry); &#125; &#125; &#125; builder.append("]"); return builder.toString(); &#125;&#125; 使用开放地址法处理冲突开放地址法（open addressing）是在冲突发生时，在散列表中找到一个开放位置的过程。 线性探测法按照顺序找到下一个可用的位置，如果冲突发生在hashTable[k % N]，则检查hashTable[(k+1) % N]，依次类推。查找时，依次检查k，k+1，…，直到达到一个空单元，或者找到。缺点：会形成一次簇（cluster），从而降低查找时间。 线性探测法处理冲突123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215import java.util.ArrayList;public class MyHashMap&lt;K, V&gt; implements MyMap&lt;K, V&gt; &#123; private static int DEFAULT_INITIAL_CAPACITY = 4; private static int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; private int capacity; private static float DEFAULT_MAX_LOAD_FACTOR = 0.5f; private float loadFactorThreshold; private int size = 0; ArrayList&lt;MyMap.Entry&lt;K, V&gt;&gt; table; public MyHashMap() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_MAX_LOAD_FACTOR); &#125; public MyHashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_MAX_LOAD_FACTOR); &#125; public MyHashMap(int initialCapacity, float loadFactorThreshold) &#123; if (initialCapacity &gt; MAXIMUM_CAPACITY) this.capacity = MAXIMUM_CAPACITY; else this.capacity = trimToPowerOf2(initialCapacity); this.loadFactorThreshold = loadFactorThreshold; table = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) table.add(null); &#125; @Override public void clear() &#123; size = 0; removeEntries(); &#125; @Override public boolean containsKey(K key) &#123; if (get(key) != null) return true; else return false; &#125; @Override public boolean containsValue(V value) &#123; for (int i = 0; i &lt; capacity; i++) &#123; if (table.get(i) != null &amp;&amp; table.get(i).getValue() == value) return true; &#125; return false; &#125; @Override public java.util.Set&lt;MyMap.Entry&lt;K,V&gt;&gt; entrySet() &#123; java.util.Set&lt;MyMap.Entry&lt;K, V&gt;&gt; set = new java.util.HashSet&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) &#123; if (table.get(i) != null) &#123; set.add(table.get(i)); &#125; &#125; return set; &#125; @Override public V get(K key) &#123; int index = hash(key.hashCode()); while(table.get(index) != null) &#123; if (table.get(index).getKey().equals(key)) &#123; return table.get(index).getValue(); &#125; index++; index %= capacity; &#125; return null; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; @Override public java.util.Set&lt;K&gt; keySet() &#123; java.util.Set&lt;K&gt; set = new java.util.HashSet&lt;K&gt;(); for (int i = 0; i &lt; capacity; i++) &#123; if (table.get(i) != null) set.add(table.get(i).getKey()); &#125; return set; &#125; @Override /** Add an entry (key, value) into the map */ public V put(K key, V value) &#123; int index = hash(key.hashCode()); while (table.get(index) != null) &#123; // The key is already in the map if (table.get(index).getKey().equals(key)) &#123; Entry&lt;K, V&gt; entry = table.get(index); V oldvalue = entry.getValue(); // Replace old value with new value entry.value = value; table.set(index, entry); // Return the old value for the key return oldvalue; &#125; // Collision check if the next index is available index++; index %= capacity; &#125; // Check load factor if (size &gt;= capacity * loadFactorThreshold) &#123; if (capacity == MAXIMUM_CAPACITY) throw new RuntimeException("Exceeding maximum capacity"); rehash(); &#125; // Add a new entry (key, value) to hashtable table.set(index, new MyMap.Entry&lt;K, V&gt;(key, value)); size++; // Increase size return value; &#125; @Override /** Remove the entry for the specified key */ public void remove(K key) &#123; int index = hash(key.hashCode()); // Remove the entry that matches the key while (table != null) &#123; if (table.get(index).getKey().equals(key)) &#123; table.remove(index); size--; // Decrease size break; // Remove just one entry that matches the key &#125; index++; index %= capacity; &#125; &#125; @Override /** Return the number of entries in this map */ public int size() &#123; return size; &#125; @Override /** Return a set consisting of values in this map */ public java.util.Set&lt;V&gt; values() &#123; java.util.Set&lt;V&gt; set = new java.util.HashSet&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) &#123; if (table.get(i) != null) set.add(table.get(i).getValue()); &#125; return set; &#125; /** Hash function */ private int hash(int hashCode) &#123; return supplementalHash(hashCode) &amp; (capacity - 1); &#125; /** Ensure the hashing is evenly distributed */ private static int supplementalHash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; /** Return a power of 2 for initialCapacity */ private int trimToPowerOf2(int initialCapacity) &#123; int capacity = 1; while (capacity &lt; initialCapacity) &#123; capacity &lt;&lt;= 1; &#125; return capacity; &#125; private void removeEntries() &#123; table.clear(); &#125; /** Rehash the map */ private void rehash() &#123; java.util.Set&lt;Entry&lt;K, V&gt;&gt; set = entrySet(); capacity &lt;&lt;= 1; // Same as capacity *= 2. &lt;= is more efficient size = 0; // Reset size to 0 table.clear(); // Clear the hash table for (int i = 0; i &lt; capacity; i++) table.add(null); for (Entry&lt;K, V&gt; entry : set) &#123; put(entry.getKey(), entry.getValue()); &#125; &#125; @Override /** Return a string repesentation for this map */ public String toString() &#123; StringBuilder builder = new StringBuilder("["); for (Entry&lt;K, V&gt; entry: table) &#123; if (entry != null &amp;&amp; table.size() &gt; 0) builder.append(entry); &#125; builder.append("]"); return builder.toString(); &#125;&#125; 二次探测法二次探测法从索引 (k + j*j) % N位置的单元开始审查。 二次探测法处理冲突123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214import java.util.ArrayList;public class MyHashMap&lt;K, V&gt; implements MyMap&lt;K, V&gt; &#123; private static int DEFAULT_INITIAL_CAPACITY = 4; private static int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; private int capacity; private static float DEFAULT_MAX_LOAD_FACTOR = 0.5f; private float loadFactorThreshold; private int size = 0; ArrayList&lt;MyMap.Entry&lt;K, V&gt;&gt; table; public MyHashMap() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_MAX_LOAD_FACTOR); &#125; public MyHashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_MAX_LOAD_FACTOR); &#125; public MyHashMap(int initialCapacity, float loadFactorThreshold) &#123; if (initialCapacity &gt; MAXIMUM_CAPACITY) this.capacity = MAXIMUM_CAPACITY; else this.capacity = trimToPowerOf2(initialCapacity); this.loadFactorThreshold = loadFactorThreshold; table = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) &#123; table.add(null); &#125; &#125; @Override /** Remove all of the entries from this map */ public void clear() &#123; size = 0; removeEntries(); &#125; @Override /** Return true if the specified key is in the map */ public boolean containsKey(K key) &#123; if (get(key) != null) return true; else return false; &#125; @Override /** Return true if this map contains the value */ public boolean containsValue(V value) &#123; for (int i = 0; i &lt; capacity; i++) &#123; if (table.get(i) != null &amp;&amp; table.get(i).getValue() == value) return true; &#125; return false; &#125; @Override /** Return a set of entries in the map */ public java.util.Set&lt;MyMap.Entry&lt;K, V&gt;&gt; entrySet() &#123; java.util.Set&lt;MyMap.Entry&lt;K, V&gt;&gt; set = new java.util.HashSet&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) &#123; if (table.get(i) != null) &#123; set.add(table.get(i)); &#125; &#125; return set; &#125; @Override /** Return the value that matches the specified key */ public V get(K key) &#123; int index = hash(key.hashCode()); int j = 0; while (table.get(index) != null) &#123; if (table.get(index).getKey().equals(key)) &#123; return table.get(index).getValue(); &#125; index += Math.pow(j++, 2); index %= capacity; &#125; return null; &#125; @Override /** Return true if this map contains no entries */ public boolean isEmpty() &#123; return size == 0; &#125; @Override /** Return a set consisting of the keys in this map */ public java.util.Set&lt;K&gt; keySet() &#123; java.util.Set&lt;K&gt; set = new java.util.HashSet&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) &#123; if (table.get(i) != null) &#123; set.add(table.get(i).getKey()); &#125; &#125; return set; &#125; @Override /** Add an entry (key, value) into the map */ public V put(K key, V value) &#123; int index = hash(key.hashCode()); int j = 0; while (table.get(index) != null) &#123; // The key is already in the map if (table.get(index).getKey().equals(key)) &#123; Entry&lt;K, V&gt; entry = table.get(index); V oldValue = entry.getValue(); // Replace old value with new value entry.value = value; table.set(index, entry); // Return the old value for the key return oldValue; &#125; index += Math.pow(j++, 2); index %= capacity; &#125; // Check load factor if (size &gt;= capacity * loadFactorThreshold) &#123; if (capacity == MAXIMUM_CAPACITY) throw new RuntimeException("Exceeding maximum capacity"); rehash(); &#125; // Add a new entry(key, value) to hashtable table.set(index, new MyMap.Entry&lt;K, V&gt;(key, value)); size++; // Increase size return value; &#125; @Override /** Remove the entry for the specified key */ public void remove(K key) &#123; int index = hash(key.hashCode()); int j = 0; // Remove the first entry that matches the key while (table.get(index) != null) &#123; if (table.get(index).getKey().equals(key)) &#123; table.remove(index); size--; // Decrease size break; // Remove just one entry that matches key &#125; index += Math.pow(j++, 2); index %= capacity; &#125; &#125; @Override /** Return the number of entries in this map */ public int size() &#123; return size; &#125; @Override /** Return a set consisting of values in this map */ public java.util.Set&lt;V&gt; values() &#123; java.util.Set&lt;V&gt; set = new java.util.HashSet&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) &#123; if (table.get(i) != null) set.add(table.get(i).getValue()); &#125; return set; &#125; /** Hash function */ private int hash(int hashCode) &#123; return supplementalHash(hashCode) &amp; (capacity - 1); &#125; /** Ensure the hashing is evenly distributed */ private static int supplementalHash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; /** Return a power of 2 for initialCapacity */ private int trimToPowerOf2(int initialCapacity) &#123; int capacity = 1; while (capacity &lt; initialCapacity) &#123; capacity &lt;&lt;= 1; &#125; return capacity; &#125; /** Remove all entries from map */ private void removeEntries() &#123; table.clear(); &#125; /** Rehash the map */ private void rehash() &#123; java.util.Set&lt;Entry&lt;K, V&gt;&gt; set = entrySet(); capacity &lt;&lt;= 1; // Same as capacity *= 2. &lt;= is more efficient size = 0; table.clear(); for (int i = 0; i &lt; capacity; i++) table.add(null); for (Entry&lt;K, V&gt; entry : set) &#123; put(entry.getKey(), entry.getValue()); &#125; &#125; @Override /** Return a string repersentation for this map */ public String toString() &#123; StringBuilder builder = new StringBuilder("["); for (Entry&lt;K, V&gt; entry: table) &#123; if (entry != null &amp;&amp; table.size() &gt; 0) builder.append(entry); &#125; builder.append("]"); return builder.toString(); &#125;&#125; 再哈希法再哈希法处理冲突123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228import java.util.ArrayList;public class MyHashMap&lt;K, V&gt; implements MyMap&lt;K, V&gt; &#123; private static int DEFAULT_INITIAL_CAPACITY = 4; private static int MAMIMUM_CAPACITY = 1 &lt;&lt; 30; private int capacity; private static float DEFAULT_MAX_LOAD_FACTOR = 0.5f; private float loadFactorThreshold; private int size = 0; private ArrayList&lt;MyMap.Entry&lt;K, V&gt;&gt; table; public MyHashMap() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_MAX_LOAD_FACTOR); &#125; public MyHashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_MAX_LOAD_FACTOR); &#125; public MyHashMap(int initialCapacity, float loadFactorThreshold) &#123; if (initialCapacity &gt; MAMIMUM_CAPACITY) this.capacity = MAMIMUM_CAPACITY; else this.capacity = trimToPowerOf2(initialCapacity); this.loadFactorThreshold = loadFactorThreshold; table = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) &#123; table.add(null); &#125; &#125; @Override public void clear() &#123; size = 0; removeEntries(); &#125; @Override public boolean containsKey(K key) &#123; if (get(key) != null) return true; else return false; &#125; @Override public boolean containsValue(V value) &#123; for (int i = 0; i &lt; capacity; i++) &#123; if (table.get(i) != null &amp;&amp; table.get(i).getValue() == value) return true; &#125; return false; &#125; @Override public java.util.Set&lt;Entry&lt;K, V&gt;&gt; entrySet() &#123; java.util.Set&lt;Entry&lt;K, V&gt;&gt; set = new java.util.HashSet&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) &#123; if (table.get(i) != null) &#123; set.add(table.get(i)); &#125; &#125; return set; &#125; @Override public V get(K key) &#123; int hash1 = hash(key.hashCode()); int index = hash1; int j = 0; while (table.get(index) != null) &#123; if (table.get(index).getKey().equals(key)) &#123; return table.get(index).getValue(); &#125; // Secondary hash: (k + j * h'(key)) % N index = hash1 + j++ * hash2(hash1); index %= capacity; &#125; return null; &#125; @Override /** Return true if this map contains no entries */ public boolean isEmpty() &#123; return size == 0; &#125; @Override /** Return a set consisting of the keys in this map */ public java.util.Set&lt;K&gt; keySet() &#123; java.util.Set&lt;K&gt; set = new java.util.HashSet&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) &#123; if (table.get(i) != null) set.add(table.get(i).getKey()); &#125; return set; &#125; @Override /** Add an entry (key, value) into the map */ public V put(K key, V value) &#123; int hash1 = hash(key.hashCode()); int index = hash1; int j = 0; while (table.get(index) != null) &#123; // The key is already in the map if (table.get(index).getKey().equals(key)) &#123; Entry&lt;K, V&gt; entry = table.get(index); V oldValue = entry.getValue(); // Replace old value with new value entry.value = value; table.set(index, entry); // Return the old value for the key return oldValue; &#125; // Secondary hash: (k + j * h'(key)) % N index = hash1 + j++ * hash2(hash1); index %= capacity; &#125; // Check load factor if (size &gt;= capacity * loadFactorThreshold) &#123; if (capacity == MAMIMUM_CAPACITY) throw new RuntimeException("Exceeding maximum capacity"); rehash(); &#125; // Add a new entry(key, value) to hashtable table.set(index, new MyMap.Entry&lt;K, V&gt;(key, value)); size++; return value; &#125; @Override /** Remove the entry for the specified key */ public void remove(K key) &#123; int hash1 = hash(key.hashCode()); int index = hash1; int j = 0; // Remove the first entry that matched the key while (table.get(index) != null) &#123; if (table.get(index).getKey().equals(key)) &#123; table.remove(index); size--; // Decrease size break; // Remove just one entry that matches the key &#125; // Secondary hash: (k + j * h'(key)) % N index = hash1 + j++ * hash2(hash1); index %= capacity; &#125; &#125; @Override /** Return the number of entries in this map */ public int size() &#123; return size; &#125; @Override /** Return a set consisting of values in this map */ public java.util.Set&lt;V&gt; values() &#123; java.util.Set&lt;V&gt; set = new java.util.HashSet&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) &#123; if (table.get(i) != null) set.add(table.get(i).getValue()); &#125; return set; &#125; /** Hash function */ private int hash(int hashCode) &#123; return supplementalHash(hashCode) &amp; (capacity - 1); &#125; /** Ensure the hashing is evenly distributed */ private static int supplementalHash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; /** Secondary hash function */ private int hash2(int hash) &#123; return (7 - hash) &amp; (7 - 1); &#125; /** Return a power of 2 for initialCapacity */ private int trimToPowerOf2(int initialCapacity) &#123; int capacity = 1; while (capacity &lt; initialCapacity) &#123; capacity &lt;&lt;= 1; &#125; return capacity; &#125; /** Remove all entries from map */ private void removeEntries() &#123; table.clear(); &#125; /** Rehash the map */ private void rehash() &#123; java.util.Set&lt;Entry&lt;K, V&gt;&gt; set = entrySet(); capacity &lt;&lt;= 1; // Same as capacity *= 2. &lt;= is more efficient size = 0; // Reset size table.clear(); for (int i = 0; i &lt; capacity; i++) table.add(null); for (Entry&lt;K, V&gt; entry : set) &#123; put(entry.getKey(), entry.getValue()); &#125; &#125; @Override /** Return a string repersentation of this map */ public String toString() &#123; StringBuilder builder = new StringBuilder("["); for (Entry&lt;K, V&gt; entry : table) &#123; if (entry != null &amp;&amp; table.size() &gt; 0) &#123; builder.append(entry); &#125; &#125; builder.append("]"); return builder.toString(); &#125;&#125;]]></content>
      <categories>
        <category>HashMap</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[345. Reverse Volwels of a String]]></title>
    <url>%2Fleetcode%2F2019%2F03%2F08%2F345.html</url>
    <content type="text"><![CDATA[编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 错误点有两处，看代码注释 345. 反转字符串中的元音字母123456789101112131415161718192021222324252627282930class Solution &#123; public String reverseVowels(String s) &#123; char[] res = s.toCharArray(); int start = 0; int end = res.length - 1; while (start &lt; end) &#123; if (isVowels(res[start]) &amp;&amp; isVowels(res[end])) &#123; char tmp = res[start]; res[start] = res[end]; res[end] = tmp; start++; end--; &#125; else if (!isVowels(res[start])) &#123; start++; &#125; else if(!isVowels(res[end])) &#123; end--; &#125; &#125; //这里return一个字符串的方法要注意 return new String(res); &#125; public static boolean isVowels(char ch) &#123; //犯错的地方 //前面忘了写 ch= ch+32 和 ch+=32的区别 ch = ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z' ? ch += 32 : ch; return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u'; &#125;&#125;]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Two Pointers</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[344. Reverse String]]></title>
    <url>%2Fleetcode%2F2019%2F03%2F08%2F344.html</url>
    <content type="text"><![CDATA[编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组char[]的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用O(1)的额外空间解决这一问题。 头尾两个指针 344. 反转字符串12345678910111213class Solution &#123; public void reverseString(char[] s) &#123; int start = 0; int end = s.length - 1; while (start &lt; end) &#123; char tmp = s[start]; s[start] = s[end]; s[end] = tmp; start++; end--; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Two Pointers</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[828. Unique Letter String]]></title>
    <url>%2Fleetcode%2F2019%2F03%2F07%2F828.html</url>
    <content type="text"><![CDATA[如果一个字符在字符串S中有且仅有出现一次，那么我们称其为独特字符。对于给定字符串S，计算其所有非空子串的独特字符的个数，即 UNIQ(substring)。如果出现两个或者多个相同的子串，将其认为是不同的两个子串。 In each loop, We caculate cur[i], which represent the sum of Uniq() for all substrings whose last char is S.charAt(i). For example,S = ‘ABCBD’When i = 2, cur[2] = Uniq(‘ABC’) + Uniq(‘BC’) + Uniq(‘C’)When i = 3, cur[3] = Uniq(‘ABCB’) + Uniq(‘BCB’) + Uniq(‘CB’) + Uniq(‘B’) Notice, we append char ‘B’ into each previous substrings. Only in substrings ‘CB’ and ‘B’, the char ‘B’ can be identified as uniq. The contribution of ‘B’ from cur[2] to cur[3] is i - showLastPosition[‘B’]. At the same time, in substrings ‘ABCB’, ‘BCB’, the char ‘B’ can‘t’ be identified as uniq any more, the previous contribution of ‘B’ should be removed. So we have’cur[i] = cur[i - 1] - contribution[S.charAt(i)] + (i - showLastPosition[S.charAt(i)])Then the new contribution[S.charAt(i)] = i - showLastPosition[S.charAt(i)] The final result is the sum of all cur[i]. 828. 独特字符串12345678910111213141516171819class Solution &#123; public int uniqueLetterString(String S) &#123; int res = 0; if (S == null || S.length() == 0) return res; int[] showLastPosition = new int[128]; int[] contribution = new int[128]; int cur = 0; for (int i = 0; i &lt; S.length(); i++) &#123; char x = S.charAt(i); cur -= contribution[x]; contribution[x] = (i - (showLastPosition[x] - 1)); cur += contribution[x]; showLastPosition[x] = i + 1; res += cur; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>Hard</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[91. Decode Ways]]></title>
    <url>%2Fleetcode%2F2019%2F03%2F07%2F91.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Medium</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈、队列和优先队列]]></title>
    <url>%2Fleetcode%2F2019%2F03%2F06%2Fstack-queue-priorityQueue.html</url>
    <content type="text"><![CDATA[可以使用数组线性表实现栈，使用链表实现队列。 栈(Stack)将数组线性表定义为栈类中的数据域，而不是使用继承ArrayList的方法是因为，一般来说加强或扩展类的功能时才使用继承的方式。AbstractList &lt;— Vector &lt;— StackArrayList和Vector类是一样的。如果不需要同步使用ArrayList类。Stack方法： peak() 返回栈顶元素而不移除它 pop() 返回并移除栈顶元素 push(e) 添加元素到栈里 search(e) 检测指定元素是否在栈中 组合的方式实现栈GenericStack.java12345678910111213141516171819202122232425262728293031import java.util.ArrayList;public class Generictack &#123; private ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;(); public int getSize() &#123; return list.size(); &#125; public E peek() &#123; return list.get(getSize() - 1); &#125; public void push(E e) &#123; list.add(e); &#125; public E pop() &#123; E e = list.get(getSize() -1); list.remove(getSize() -1); return e; &#125; public boolean isEmpty() &#123; return list.isEmpty(); &#125; @Override public String toString() &#123; return "stack: " + list.toString(); &#125;&#125; 用栈存储素数TestGenericStack.java1234567891011121314151617181920212223242526272829303132public class TestGenericStack &#123; public static void main(String[] args) &#123; GenericStack&lt;Integer&gt; stack = new GenericStack&lt;&gt;(); final int NUMBER_OF_PRIMES = 50; int count = 0; for (int i = 2; count &lt; NUMBER_OF_PRIMES; i++) &#123; if (isPrime(i)) &#123; stack.push(i); count++; &#125; &#125; System.out.println("The first 50 prime numbers in descending order: "); for (int i = 1; !stack.isEmpty(); i++)&#123; if (i % 10 == 0) System.out.printf("%3d\n", stack.pop()); else System.out.printf("%3d ", stack.pop()); &#125; System.out.println(); &#125; private static boolean isPrime(int n) &#123; for (int i = 2; i &lt;= n / 2; i++) &#123; if (n % i == 0) return false; &#125; return true; &#125;&#125; 队列(Queue)java API中java.util.Queue是一个接口可以用Queue作为父类引用，LinkedList作为实例java.util.Queue&lt;TreeNode&gt; queue = new java.util.LinkedList&lt;&gt;(); Queue是LinkedList的父类接口继承关系：Collection &lt;— Queue &lt;— Deque &lt;— LinkedList Queue &lt;— AbstractQueue &lt;— PriorityQueueQueue的方法： offer(e) 插入元素e到队列中 poll() 获取并移除队头(front)元素，，队为空返回null remove() 获取并移除队头(front)元素，队为空抛出异常 peek() 获取但不移除对头元素，队为空返回null element() 获取但不移除对头元素，队为空抛出异常 使用继承和组合的方式实现队列和栈都是可行的，但是组合更好一点，因为可以定义一个全新的栈类和队列类，而不需要继承ArrayList和LinkedList中不必要和不合适的方法。 类仅在它们需要被加强或修改时，才会使用继承！！！！ 使用组合的方式实现队列组合的方式实现Queue1234567891011121314151617import java.util.LinkedList;public class GenericQueue&lt;E&gt; &#123; private LinkedList&lt;E&gt; list = new LinkedList&lt;&gt;(); public void enqueue(E e) &#123; list.addFirst(e); &#125; public E dequeu() &#123; return list.removeFirst(); &#125; public int getSize() &#123; return list.size(); &#125; @Override public String toString() &#123; return "Queue: " + list.toString(); &#125;&#125; 继承关系实现Queue继承关系实现Queue1234567891011121314public class GenericQueue&lt;E&gt; extends java.util.LinkedList&lt;E&gt; &#123; public void enqueue(E e) &#123; addLast(e); &#125; public E dequeue() &#123; return removeFirst(); &#125; public int getSize() &#123; return size(); &#125;&#125; 优先队列(PriorityQueue)对于使用Comparable和Comparator实现的Heap类见文章堆排序 用堆实现优先队列普通队列是一种先进先出的数据结构，元素在rear添加，在front删除。在优先队列中，元素被赋予优先级，当访问元素时，具有最高优先级的元素最先删除。Largest-in, first-Out 高进先出在java API中继承顺序如下：Queue &lt;— AbstractQueue &lt;— PriorityQueue 可以使用堆实现优先队列，其中根节点是队列中具有最高优先级的对象。 使用Comparable接口 用Comparable实现泛型PriorityQueue1234567891011121314public class MyPriorityQueue&lt;E extends Comparable&lt;E&gt;&gt; &#123; private Heap&lt;E&gt; heap = new Heap&lt;&gt;(); public void enqueue(E newOject) &#123; heap.add(newObject); &#125; public E dequeue() &#123; return heap.remove(); &#125; public int getSize() &#123; return heap.getSize(); &#125;&#125; 用Comparator实现泛型PriorityQueue用Comparator实现泛型PriorityQueue123456789101112131415161718192021import java.util.Comparator;public class MyPriorityQueue&lt;E&gt; &#123; private Comparator&lt;? super E&gt; comparator; private Heap&lt;E&gt; heap; MyPriorityQueue(Comparator&lt;? super E&gt; comparator) &#123; this.comparator = comparator; this.heap = new Heap&lt;&gt;(comparator); &#125; public void enqueue(E newObject) &#123; heap.add(newObject); &#125; public E dequeue() &#123; return heap.remove(); &#125; public int getSize() &#123; return heap.getSize(); &#125;&#125;]]></content>
      <categories>
        <category>List</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>Queue</tag>
        <tag>PriorityQueue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2Fleetcode%2F2019%2F03%2F05%2FLinkedList.html</url>
    <content type="text"><![CDATA[LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，而随机访问和遍历的速度则较慢。另外，它还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。 链表LinkedList由于ArrayList是用数组实现的，所以 get(int index) 和 set(int index, E e) 方法可以通过下标访问和修改元素，也可以用 add(E e) 方法在线性表末尾添加元素，它们是高效的。但是 add(int index, E e) 和 remove(int index) 方法的效率很低，因为需要移动潜在的大量元素。为了提高在表中开始位置添加和删除元素的效率，可以采用链式结构来实现线性表。 节点每个节点都包含元素和一个名为next的数据域，next指向下一个元素。如果节点是线性表中的最后一个，那么它的指针数据域next所包含的值是null。 LinkedList节点类12345678910 // This class is only used in LinkedList, so it is private. // This class does not need to access any // instance members of LinkedList, so it is defined static.private static class Node&lt;E&gt; &#123; E element; Node&lt;E&gt; next; public Node(E element) &#123; this.element = element; &#125;&#125; 实现addFirst(E e)方法addFirst(E e)方法12345678public void addFirst(E e) &#123; Node&lt;E&gt; newNode = new Node&lt;&gt;(e); newNode.next = head; head = newNode; size++; if (tail == null) tail = head;&#125; 实现addLast(E e)方法addLast(E e)方法12345678910public void addLast(E e) &#123; Node&lt;E&gt; newNode = new Node&lt;&gt;(e); if (tail == null) &#123; head = tail = newNode; &#125; else &#123; tail.next = newNode; tail = tail.next; &#125; size++;&#125; 实现add(int index, E e)方法add(int index, E e)方法1234567891011121314151617public void add(int index, E e) &#123; if (index == 0) &#123; //addFirst &amp;&amp; addLast contains size++ addFirst(e); &#125; else if (index &gt;= size) &#123; addLast(e); &#125; else &#123; Node&lt;E&gt; current = head; for (int i = 1; i &lt; index; i++) &#123; current = current.next; &#125; Node&lt;E&gt; tmp = current.next; current.next = new Node&lt;&gt;(e); (current.next).next = tmp; size++; &#125;&#125; 实现removeFirst()方法removeFirst()方法12345678910public E removeFirst() &#123; if (size == 0) &#123; return null; &#125; else &#123; Node&lt;E&gt; tmp = head; head = head.next; size--; return tmp.element; &#125;&#125; 实现removeLast()方法removeLast()方法123456789101112131415161718public E removeLast() &#123; if (size == 0) &#123; return null; &#125; else if (size == 1) &#123; Node&lt;E&gt; tmp = head; head = tail = null; size = 0; return tmp.element; &#125; else &#123; Node&lt;E&gt; current = head; for (int i = 0; i &lt; size - 2; i++) current = current.next; Node&lt;E&gt; tmp = tail; tail.next = null; size--; return tmp.element; &#125;&#125; 实现remove(int index)方法remove(int index)方法1234567891011121314151617public E remove(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; return null; &#125; else if (index == 0) &#123; return removeFirst(); &#125; else if (index == size -1) &#123; return removeLast(); &#125; else &#123; Node&lt;E&gt; previous = head; for (int i = 1; i &lt; index; i++) previous = previous.next; Node&lt;E&gt; current = previous.next; previous.next = current.next; size--; return current.element; &#125; &#125; MyLinkedList具体实现MyLinkedList具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247import java.util.Iterator;public class MyLinkedList&lt;E&gt; extends MyAbstractList&lt;E&gt; &#123; private Node&lt;E&gt; head, tail; public MyLinkedList() &#123; &#125; public MyLinkedList(E[] objects) &#123; super(objects); &#125; public E getFirst() &#123; if (size == 0) &#123; return null; &#125; else &#123; return head.element; &#125; &#125; public E getLast() &#123; if (size == 0) &#123; return null; &#125; else &#123; return tail.element; &#125; &#125; public void addFirst(E e) &#123; Node&lt;E&gt; newNode = new Node&lt;&gt;(e); newNode.next = head; head = newNode; size++; if (tail == null) tail = head; &#125; public void addLast(E e) &#123; Node&lt;E&gt; newNode = new Node&lt;&gt;(e); if (tail == null) &#123; head = tail = newNode; &#125; else &#123; tail.next = newNode; tail = tail.next; &#125; size++; &#125; @Override public void add(int index, E e) &#123; if (index == 0) &#123; //addFirst &amp;&amp; addLast contains size++ addFirst(e); &#125; else if (index &gt;= size) &#123; addLast(e); &#125; else &#123; Node&lt;E&gt; current = head; for (int i = 1; i &lt; index; i++) &#123; current = current.next; &#125; Node&lt;E&gt; tmp = current.next; current.next = new Node&lt;&gt;(e); (current.next).next = tmp; size++; &#125; &#125; @Override public void clear() &#123; size = 0; head = tail = null; &#125; @Override public boolean contains(E e) &#123; if (size == 0) &#123; return false; &#125; else &#123; Node&lt;E&gt; current = head; while (current != null) &#123; if (current.element == e) return true; current = current.next; &#125; &#125; return false; &#125; @Override public E get(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; return null; &#125; else if (index == 0) &#123; return getFirst(); &#125; else if (index == size -1) &#123; return getLast(); &#125; else &#123; Node&lt;E&gt; current = head.next; for (int i = 1; i &lt; index; i++) current = current.next; return current.element; &#125; &#125; @Override public int indexOf(E e) &#123; if (head.element == e) &#123; return 0; &#125; else if (tail.element == e) &#123; return size - 1; &#125; else &#123; Node&lt;E&gt; current = head.next; int index = 1; while (current != null) &#123; if (current.element == e) return index; current = current.next; index++; &#125; &#125; return -1; &#125; @Override public int lastIndexOf(E e) &#123; int index = -1; Node&lt;E&gt; current = head; for (int i = 0; i &lt; size; i++) &#123; if (current.element == e) index = i; current = current.next; &#125; return index; &#125; public E removeFirst() &#123; if (size == 0) &#123; return null; &#125; else &#123; Node&lt;E&gt; tmp = head; head = head.next; size--; return tmp.element; &#125; &#125; public E removeLast() &#123; if (size == 0) &#123; return null; &#125; else if (size == 1) &#123; Node&lt;E&gt; tmp = head; head = tail = null; size = 0; return tmp.element; &#125; else &#123; Node&lt;E&gt; current = head; for (int i = 0; i &lt; size - 2; i++) current = current.next; Node&lt;E&gt; tmp = tail; tail.next = null; size--; return tmp.element; &#125; &#125; @Override public E remove(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; return null; &#125; else if (index == 0) &#123; return removeFirst(); &#125; else if (index == size -1) &#123; return removeLast(); &#125; else &#123; Node&lt;E&gt; previous = head; for (int i = 1; i &lt; index; i++) previous = previous.next; Node&lt;E&gt; current = previous.next; previous.next = current.next; size--; return current.element; &#125; &#125; @Override public E set(int index, E e) &#123; if (index &lt; 0 || index &gt; size -1) &#123; return null; &#125; else &#123; Node&lt;E&gt; current = head; for (int i = 0; i &lt; index; i++) current = current.next; current.element = e; return current.element; &#125; &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder("["); Node&lt;E&gt; current = head; for (int i = 0; i &lt; size; i++) &#123; res.append(current.element); current = current.next; if (current != null) &#123; res.append(", "); &#125; else &#123; res.append("]"); &#125; &#125; return res.toString(); &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return new LinkedListIterator(); &#125; private class LinkedListIterator implements Iterator&lt;E&gt; &#123; private Node&lt;E&gt; current = head; @Override public boolean hasNext() &#123; return (current != null); &#125; @Override public E next() &#123; E e = current.element; current = current.next; return e; &#125; @Override public void remove() &#123; &#125; &#125; // This class is only used in LinkedList, so it is private. // This class does not need to access any // instance members of LinkedList, so it is defined static. private static class Node&lt;E&gt; &#123; E element; Node&lt;E&gt; next; public Node(E element) &#123; this.element = element; &#125; &#125;&#125; 抽象类和接口MyList接口MyList接口12345678910111213141516171819202122232425public interface MyList&lt;E&gt; extends Iterable&lt;E&gt; &#123; void add(E e); void add(int index, E e); void clear(); boolean contains(E e); E get(int index); int indexOf(E e); boolean isEmpty(); int lastIndexOf(E e); boolean remove(E e); E remove(int index); Object set(int index, E e); int size(); &#125; MyAbstractList抽象类MyAbstractList抽象类123456789101112131415161718192021222324252627282930313233343536public abstract class MyAbstractList&lt;E&gt; implements MyList&lt;E&gt; &#123; protected int size = 0 ; protected MyAbstractList() &#123; &#125;; protected MyAbstractList(E[] objects) &#123; for (int i = 0; i &lt; objects.length; i++) add(objects[i]); &#125; @Override public void add(E e) &#123; add(size, e); &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; @Override public boolean remove(E e) &#123; if (indexOf(e) &gt;= 0) &#123; remove(indexOf(e)); return true; &#125; else &#123; return false; &#125; &#125; @Override public int size() &#123; return size; &#125;&#125;]]></content>
      <categories>
        <category>List</category>
      </categories>
      <tags>
        <tag>List</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组线性表]]></title>
    <url>%2Fleetcode%2F2019%2F03%2F04%2FArrayList.html</url>
    <content type="text"><![CDATA[ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时，需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动时，代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。 List常用的List方法： add 在最后或特定位置加入新的元素 clear 清除所有元素 contains 是否含有指定元素 get 获取特定索引元素 indexOf 返回特定元素第一次出现的索引，没有则返回-1 lastIndexOf 返回特定元素最后一次出现的索引，没有则返回-1 isEmpty 判断是否为空 iterator 返回迭代器 remove 移除特定元素 size 返回List大小 subList 根据传入的两个索引返回子列表 常用的List实现类有: ArrayList： 擅长随机访问的列表 LinkedList： 擅长插入和删除操作的列表 Vector： 与ArrayList类似，线程安全的列表 MyArrayList和MyLinkedList可以使用ArrayList和LinkedList来存储线性表。使用数组实现ArrayList，使用链表实现LinkedList，前者开销比后者小。但是如果需要在线性表的开始位置插入和删除元素，那么LinkedList的效率会高一点。下表总结了ArrayList和LinkedList中方法的时间复杂度。 方法 ArrayList LinkedList add(e: E) O(1) O(1) add(index: int, e: E) O(n) O(n) clear() O(1) O(1) contains(e: E) O(n) O(n) get(index: int) O(1)** O(n) indexOf(e: E) O(n) O(n) isEmpty() O(1) O(1) lastIndexOf(e: E) O(n) O(n) remove(e: E) O(n) O(n) size() O(1) O(1) remove(index: int) O(n) O(n) set(index: int, e: E) O(n) O(n) addFirst(e: E) O(n) O(1)** removeFirst() O(n) O(1)** ArrayList部分细节使用数组来实现动态数据结构，处理方法是：当数组不能再存储线性表的新元素时，创建一个更大的新数组来替换当前数组。 add(int index, E e)添加元素到指定位置123456789101112131415public void add(int index, E e) &#123; ensureCapacity(); for (int i = size - 1; i &gt;= index; i--) &#123; data[i + 1] = data[i]; &#125; data[index] = e; size++; &#125;private void ensureCapacity() &#123; if (size &gt;= data.length) &#123; E[] newData = (E[]) new Object[2 * size + 1]; System.arraycopy(data, 0, newData, 0, size); data = newData; &#125;&#125; clear()通过创建一个新数组并且将其复制给data，老的数组和保存在数组中的数据变成垃圾，将自动被JVM回收。clear方法1234public void clear() &#123; data = (E[]) new Object[INITIAL_CAPACITY]; size = 0;&#125; remove(int index)最后一个元素不再使用，设置为null。remove方法123456789public E remove(int index) &#123; checkIndex(index); E e = data[index]; for (int j = index; j &lt; size - 1; j++) data[j] = data[j + 1]; data[size - 1] = null; size--; return e;&#125; ArrayList具体实现采用集合的实现模式，在MyList接口中提供通用的操作，抽象类部分实现了包括集合操作的addAll、removeAll和containsAll等方法，最后在MyArrayList类中实现了数组线性表。为了便于手机查看，采用倒序的显示方式。将接口、抽象类和测试用例放在最后。 MyArrayList实现类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144package algorithms.arrayList;import java.util.Iterator;public class MyArrayList&lt;E&gt; extends MyAbstractList&lt;E&gt; &#123; private static final int INITIAL_CAPACITY = 16; @SuppressWarnings("unchecked") private E[] data = (E[]) new Object[INITIAL_CAPACITY]; public MyArrayList() &#123; &#125;; public MyArrayList(E[] objects) &#123; for (int i = 0; i &lt; objects.length; i++) add(objects[i]); &#125; @Override public void add(int index, E e) &#123; ensureCapacity(); for (int i = size - 1; i &gt;= index; i--) &#123; data[i + 1] = data[i]; &#125; data[index] = e; size++; &#125; @SuppressWarnings("unchecked") @Override public void clear() &#123; data = (E[]) new Object[INITIAL_CAPACITY]; size = 0; &#125; @Override public boolean contains(E e) &#123; for (int i = 0; i &lt; size; i++) &#123; if (e.equals(data[i])) return true; &#125; return false; &#125; @Override public E get(int index) &#123; checkIndex(index); return data[index]; &#125; @Override public int indexOf(E e) &#123; for (int i = 0; i &lt; size; i++) &#123; if (e.equals(data[i])) return i; &#125; return -1; &#125; @Override public int lastIndexOf(E e) &#123; for (int i = size - 1; i &gt;= 0; i--) &#123; if (e.equals(data[i])) return i; &#125; return -1; &#125; @Override public E remove(int index) &#123; checkIndex(index); E e = data[index]; for (int j = index; j &lt; size - 1; j++) data[j] = data[j + 1]; data[size - 1] = null; size--; return e; &#125; @Override public E set(int index, E e) &#123; checkIndex(index); E old = data[index]; data[index] = e; return old; &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder("["); for (int i = 0; i &lt; size; i++) &#123; res.append(data[i]); if (i &lt; size - 1) res.append(", "); &#125; return res.toString() + "]"; &#125; @SuppressWarnings("unchecked") public void trimToSize() &#123; if (size != data.length) &#123; E[] newData = (E[]) new Object[size]; System.arraycopy(data, 0, newData, 0, size); data = newData; &#125; &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return new ArrayListIterator(); &#125; @SuppressWarnings("unchecked") private void ensureCapacity() &#123; if (size &gt;= data.length) &#123; E[] newData = (E[]) new Object[2 * size + 1]; System.arraycopy(data, 0, newData, 0, size); data = newData; &#125; &#125; private void checkIndex(int index) &#123; if (index &lt; 0 || index &gt;= size) throw new IndexOutOfBoundsException("index " + index + " ouf of bounds"); &#125; private class ArrayListIterator implements Iterator&lt;E&gt; &#123; private int current = 0; @Override public boolean hasNext() &#123; return (current &lt; size); &#125; @Override public E next() &#123; return data[current++]; &#125; @Override public void remove() &#123; MyArrayList.this.remove(current); &#125; &#125;&#125; 接口、抽象类和测试用例MyList接口MyList接口123456789101112131415161718192021222324252627282930313233package algorithms.arrayList;public interface MyList&lt;E&gt; extends Iterable&lt;E&gt; &#123; void add(E e); void add(int index, E e); void clear(); boolean contains(E e); E get(int index); int indexOf(E e); boolean isEmpty(); int lastIndexOf(E e); boolean remove(E e); E remove(int index); Object set(int index, E e); int size(); boolean addAll(MyList&lt;E&gt; otherList); boolean removeAll(MyList&lt;E&gt; otherList); boolean retainAll(MyList&lt;E&gt; otherList); &#125; MyAbstractList抽象类MyAbstractList抽象类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package algorithms.arrayList;public abstract class MyAbstractList&lt;E&gt; implements MyList&lt;E&gt; &#123; protected int size = 0 ; protected MyAbstractList() &#123; &#125;; protected MyAbstractList(E[] objects) &#123; for (int i = 0; i &lt; objects.length; i++) add(objects[i]); &#125; @Override public void add(E e) &#123; add(size, e); &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; @Override public boolean remove(E e) &#123; if (indexOf(e) &gt;= 0) &#123; remove(indexOf(e)); return true; &#125; else &#123; return false; &#125; &#125; @Override public int size() &#123; return size; &#125; @Override public boolean addAll(MyList&lt;E&gt; otherList) &#123; boolean changed = false; for ( int i = 0; i &lt; otherList.size(); i++) &#123; E e = otherList.get(i); if (!contains(e)) &#123; add(e); changed = true; &#125; &#125; return changed; &#125; @Override public boolean removeAll(MyList&lt;E&gt; otherList) &#123; boolean changed = false; for (int i = 0; i &lt; otherList.size(); i++) &#123; E e = otherList.get(i); if (contains(e)) &#123; remove(e); changed = true; &#125; &#125; return changed; &#125; @Override public boolean retainAll(MyList&lt;E&gt; otherList) &#123; boolean changed = false; for (int i = size - 1; i &gt;= 0; i--) &#123; E e = otherList.get(i); if (!otherList.contains(e)) &#123; remove(e); changed = true; &#125; &#125; return changed; &#125;&#125; MyArrayList测试用例MyArrayList测试用例123456789101112131415161718192021222324252627282930313233343536package algorithms.arrayList;public class TestMyArrayList &#123; public static void main(String[] args) &#123; String[] array1 = &#123;"Tom", "George", "Peter", "Jean", "Jane"&#125;; MyList&lt;String&gt; list1 = new MyArrayList&lt;&gt;(array1); String[] array2 = &#123;"Tom", "George", "Michael", "Michelle", "Daniel"&#125;; MyList&lt;String&gt; list2 = new MyArrayList&lt;&gt;(array2); System.out.println("Create two MyArrayLists:"); print(list1, list2); System.out.println("Invoke list1.addAll(list2):"); list1.addAll(list2); print(list1, list2); System.out.println("Recreate list1 and list2 with the same initial values," + "\ninvoke list1.removeAll(list2), and displays list1 and list2:"); list1.clear(); list1.addAll(new MyArrayList&lt;&gt;(array1)); list1.removeAll(list2); print(list1, list2); System.out.println("Recreate list1 and list2 with the same initial values," + "\ninvokes list1.retainAll(list2), and displays list1 and list2:"); list1.clear(); list1.addAll(new MyArrayList&lt;&gt;(array1)); list1.retainAll(list2); print(list1, list2); &#125; public static void print(MyList&lt;String&gt; list1, MyList&lt;String&gt; list2) &#123; System.out.println("List1: " + list1); System.out.println("List2: " + list2); System.out.println(); &#125;&#125;]]></content>
      <categories>
        <category>List</category>
      </categories>
      <tags>
        <tag>ArrayList</tag>
        <tag>List</tag>
      </tags>
  </entry>
</search>
